INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (1, 10000, 'Editor.md中emoji图标无法显示', 'Editor.md中emoji图标无法显示<br>今天写博客想换个富文本编辑器，选了Editor.md，感觉不错~&emsp;但是在打开表情时候，图片都403访问不到?<br>好吧自己动手丰衣足食吧~', '今天写博客想换个富文本编辑器，选了Editor.md，感觉不错~ 但是在打开表情时候，图片都403访问不到? \n好吧自己动手丰衣足食吧~ \n下载表情包：[表情包地址](https://github.com/SemiWarm/SemiWarmAdminPhotos/blob/master/emoji.zip)\n把下载的包情包放在editor/plugins/emoji-dialog/下边 具体怎么放，一会你学会了 自己去改！ 我提供一个思路。\n然后找到editormd.js修改如下：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/22/20210322185058image.png)\n改成你自己的目录文件夹，我的是：\n```\n// Emoji graphics files url path\n    editormd.emoji     = {\n        path  : \"./editor/plugins/emoji-dialog/emoji/\",\n        ext   : \".png\"\n    };\n```\n\n改好后,再次插入表情，试试~ 是不是显示了？\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/22/20210322185037image.png)\nok~ 今天Editor.md中emoji图标无法显示就说这么多！ 你搞定了吗？有问题可以给我留言哦~~~\n原文链接：https://www.liangjucai.com/article/343', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/202102/03/QQ%E6%88%AA%E5%9B%BE20201109095523.png', 0, 0, 2562, 1, '2020-10-14 16:07:47', '2022-2-15 19:35:36', 'https://www.liangjucai.com/article/343', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (2, 10000, '阿里云图标文件iconfont在JavaWeb项目中失效了？', '今天在做图标的时候，在下载下新图标的js文件替换原来的js文件时，突然发现iconfont.js失效了。<br>解决方法如下：<br>1.使用在线引入方式。<br>2.将下载到本地的iconfont.js文件或者cdn中的内容中，复制到已有的iconfont.js文件中。<br>3.。。。', '今天在做图标的时候，在下载下新图标的js文件替换原来的js文件时，突然发现iconfont.js失效了。  \n解决方法如下：  \n1.使用在线引入方式如：\n\n    <script src=\"http://at.alicdn.com/t/font_20856_x6kjqls7h9.js\"></script>\n2.将下载到本地的iconfont.js文件或者cdn中的内容中，复制到已有的iconfont.js文件中。  \n \n3.在换入新的iconfont后重构（Build->Rebulid Project）\n\n', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/202102/03/QQ%E6%88%AA%E5%9B%BE20201109100004.png', 0, 0, 1138, 1, '2020-10-14 16:08:07', '2022-2-15 19:35:05', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (3, 10000, '[Vue学习]实现点击谁谁变色', '实现点击谁谁变色，在单页应用中经常应用在导航栏上的效果', '如下代码，vue.js的位置根据自己的项目修改。\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>点击变色</title>\n    <style>\n        body{\n            background-color: aliceblue;\n        }\n        #app{\n            display: flex;\n        }\n        .nav{\n            display: flex;\n            justify-content: center;\n            align-items: center;\n            height: 70px;\n            width: 110px;\n            background-color: white;\n            margin: 0 5px;\n        }\n        .active{\n            color: white;\n            background-color: cadetblue;\n        }\n    </style>\n</head>\n<body>\n<div id=\"app\">\n    <div @click=\"show(index)\" v-for=\"(items,index) in navigations\" class=\"nav\" :class = \"{active:index === currentIndex}\">{{items}}</div>\n</div>\n<script src=\"../vue/js/vue.js\"></script>\n<script>\n    const app = new Vue({\n        el: \'#app\',\n        data: {\n            message: \'Vue模板\',\n            navigations: [\'主页\',\'创作\',\'生活\',\'问答\',\'关于我们\'],\n            currentIndex: 0\n        },\n        methods: {\n            show(index) {\n                this.currentIndex = index\n            }\n        }\n    })\n</script>\n</body>\n</html>\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 505, 1, '2020-10-3 16:08:14', '2021-3-10 14:22:27', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (5, 10000, '[JavaWeb学习01]request.setAttribute和session.setAttribute有什么区别', 'request.setAttribute(“curruser”,&emsp;curruser)这个方法是将curruser这个对象保存在request作用域中，然后在转发进入的页面就可以获取到你的值，如果你会一些框架的话，那些框架标签也可以获取到，比如struts标签，还有jstl。', '1，request.setAttribute(“curruser”, curruser)这个方法是将curruser这个对象保存在request作用域中，然后在转发进入的页面就可以获取到你的值，如果你会一些框架的话，那些框架标签也可以获取到，比如struts标签，还有jstl。如果这你都不会的话，那么你可以在jsp页面编写java小脚本来获取: `<% User myuser = (User)request.getAttribute(\"curruser\")%>`,\n在jsp页面显示值:`<%=myuser.getName()%>。`  \n2，`session.setAttribute(\"curruser\", curruser)`。这个方法和上面唯一的区别就是作用域，就是在你整个程序启动的时候，如果在session中保存了数据，那么在你这个无论你在哪个页面，在什么时候都可以获取到这个值，全局的，只要你的这个程序是启动的。session默认的过期时间是30分钟，过期无效，可以去修改这个值。\n\n关于两者的作用域：\n\n**request的生命周期是request请求域，一个请求结束，则request结束**  \n**session的生命周期是session会话域，打开一个浏览器请求一个网站的页面后，Session开始，当session超过时间限制后，session注销而失效**  \n或是人为使用session.invalidate();使用session失效；  \n或是关闭浏览器后，session还存在，但是这里已经无法获取session了，过一会它还是失效  \n\n#### 总结  \n1、request.setAttribute 作用域是请求和被请求页面之间。   \nrequest.setAttribute()是只在此action的下一个forward需要使用的时候使用 ；   \nrequest.setAttribute()可存放的参数是String和Object。   \n\n2、session.setAttribute 作用域是整个会话期间，在所有的页面都使用这些数据的时候使用。会话期间指的是浏览器打开该页面，到关闭。 一般用于存放用户信息。   \nrequest.setAttribute()可存放的参数是String和Object。\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 214, 1, '2020-10-6 16:08:22', '2021-3-13 19:22:51', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (6, 10000, '我的个人博客中使用的ajax通用模板', '进行前后端数据交互时，我们会用到ajax进行前后端数据交换，具体的使用的ajax模板如下...<br>我的项目在开发阶段并不是部署在服务器中Tomcat的root文件夹下的，所以这边我使用了两个URL，第一个URL是没加项目名的，在IDEA上运行的时候使用，第二个URL是部署在服务器上的。<br>params：传递的参数<br>type：请求的方法，get或者post<br>success：请求成功后执行的代码，一般在这里边处理后端发来的数据。<br>error：请求失败后执行的代码，一般在这里弹出错误提示。', '&emsp;&emsp;在进行前后端数据交互时，我们会用到ajax进行前后端数据交换，具体的使用的ajax模板如下\n\n    function fname(param) {\n        var url = \"/message/sendCode\";             //本地访问地址\n        // var url = \"/jellyblog/message/sendCode\";   //服务器访问地址\n        var params = {\"param\": param};\n        $.ajax({\n            url: url,\n            data: params,\n            type: \"get\",\n            success: function (data) {\n                codeTemp = data;\n            },\n            \"error\": function () {\n                alert(\"出现了意料之外的ajax错误[fname]，请联系开发者\");\n            }\n        });\n    }\n\n&emsp;&emsp;我的项目在开发阶段并不是部署在服务器中Tomcat的root文件夹下的，所以这边我使用了两个URL，第一个URL是没加项目名的，在IDEA上运行的时候使用，第二个URL是部署在服务器上的。  \nparams：传递的参数  \ntype：请求的方法，get或者post  \nsuccess：请求成功后执行的代码，一般在这里边处理后端发来的数据。  \nerror：请求失败后执行的代码，一般在这里弹出错误提示。   \n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 199, 1, '2020-10-2 16:08:27', '2020-12-9 10:40:05', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (7, 10000, '错误：ajax在本地测试是正常使用的，但是到了服务器上面却出现了异常', 'ajax的URL路径问题，服务器和本地的区别<br>发布项目时遇到的问题', '记录一下遇到的错误。  \n错误：ajax在本地测试是正常使用的，但是到了服务器上面却出现了异常，无法使用，使用alert测试到可以执行ajax里面的内容，但是却不执行success里面的内容，执行了error里面的内容，打开Egde的控制台后发现，ajax的URL出现了一些问题，正确的URL应该是： \nhttp://112.124.21.111/myblog/home/userCheck    \n  但是这个时候浏览器控制台里面的URL却是  \n href=\"http://112.124.21.111/home/userCheck\n  发现问题了吗？浏览器的URL里面少了个项目名myblog, 这个路径错误就是导致ajax错误的直接原因, 看来IDEA和服务器的URL在写法上还是有点差距的。  \n  总结一下解决方法：  \n  情况一：在本地访问项目(比如在IDEA上运行，使用localhost访问)，IDEA中访问的是localhost端口，不用加上项目名，即ajax的URL可以写成”/home/userCheck”;   \n  情况二：部署到服务器（我们需要使用域名或者其他方式访问），这时我们需要加上项目名（注意注意：如果你的项目是部署在Tomcat的webapps的ROOT文件夹下，这个时候，使用情况一的URL写法），写法是： “/myblog/home/userCheck”;对于情况二这种需要加项目名的URL，其实非常不方便，其实还有一种方法是&lt;%=path%&gt;,自行百度,这样就不需要每个ajax的url都需要设置项目名，需要注意一点，项目名前面也要加上斜杠，不然会出现URL出现两个项目名的情况，即 \n http://112.124.21.111/myblog/myblog/home/userCheck     \n修改完路径再次打包测试，发现成功的执行了success的代码，界面也进行了加载。  \n\n> 参考代码\n\n```\nfunction accountCheck() {\n    var url = \"/home/userCheck\";             //本地访问地址\n    // var url = \"/jellyblog/home/userCheck\";   //服务器访问地址\n    var telephone = $(\'input[name=\"telephone\"]\').val();\n    var password = $(\'input[name=\"password\"]\').val();\n    // var submit = $(\'#submitAccount\');\n    var accountSubmit = document.getElementById(\"submitAccount\");\n    var form = document.getElementById(\"accountForm\");\n    var prompt1 = document.getElementById(\"prompt1\");\n    var params = {\"telephone\": telephone, \"password\": password};\n    if (telephone == \"\" || password == \"\") {\n        // 账号密码为空，不允许提交\n        return false;\n    }\n    accountSubmit.innerHTML = \"验证中...\";\n    accountSubmit.disabled = true;\n    $.ajax({\n        url: url,\n        data: params,\n        type: \"post\",\n        // async : false,\n        success: function (data) {\n            // 参数为json类型的对象\n            // alert(data.message)\n            if (data == true) {\n                accountSubmit.innerHTML = \"正在登录...\";\n                prompt1.style.display = \"none\";\n                form.submit();\n            } else {\n                prompt1.style.display = \"flex\";\n                accountSubmit.disabled = false;\n                accountSubmit.innerHTML = \"登录\";\n            }\n        },\n        \"error\": function () {\n            alert(\"出现了意料之外的ajax错误[accountCheck]，请联系开发者\");\n            prompt1.style.display = \"flex\";\n            accountSubmit.disabled = false;\n            // submit.attr(\"disabled\", false);\n            accountSubmit.innerHTML = \"登录\";\n        }\n    });\n}\n```\n', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/bugrecord.svg', 0, 0, 178, 1, '2020-10-12 16:08:33', '2021-3-14 09:50:39', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (8, 10000, 'IDEA将项目打包成war时出现异常：Failed to execute....', 'IDEA打包war包出现异常', '<p><strong>错误</strong>：IDEA将项目打包成war时出现异常：Failed to execute goal org.apache.maven.plugirs:maven-war-plugin : 3.2.3:war (default-war) on project XXXX:Could not copy webapp classes [D:\\intellij Project\\XXXX\\target\\classes]<br><strong>原因</strong>：之前打包的数据还没清除，导致新打包的war包需要覆盖旧的war包，因此失败。<br><strong>解决方法</strong>：IDEA右上角找到<strong>Maven-&gt;打开你的项目文件夹-&gt;Lifecycle-&gt;clean（等待清除完毕）-&gt;package(重新打包)</strong>。这样就可以解决问题了。</p>\r\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 102, 1, '2020-10-16 13:03:11', '2020-10-16 13:03:11', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (9, 10000, '错误：An error happened during template parsing (template: \"class path resource [templates/XXXX.html]\")', '一个报错', '123', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/bugrecord.svg', 0, 0, 58, 1, '2020-10-16 13:11:15', '2021-3-14 20:37:51', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (10, 10000, '[JavaWeb学习02]JSP中九大内置对象 ', '分类：<br>(1)输入输出对象：request、response、Out<br>(2)通信控制对象：session、Applicaiton、PageContext<br>(3)Servlet对象：page、config<br>(4)错误处理对象：Execption', '**1、request**  \n　　客户端的请求被封装在request对象中，通过调用该对象相应的方法就可以获得封装的信息，即使用该对象获取用户提交的信息，然后做出响应。它是HTTPServletRequest类的实例，Request在完成客户端的请求之前，该对象一直有效。  \n　　作用域：request，即该次请求结束，生命周期结束。  \n　　重要方法：  \n　　(1)`getParameter(key)`   获取提交表单的数据  \n　　(2)`getParameterValues(key)`   获取提交表单的一组数据  \n　　(3)`request.setAttribute(key,Object)`  设置请求对象的属性  \n　　(4)`request.getAttribute(key)`   获取请求对象的属性  \n　　(5)`request.setCharasterEncoding(\"utf-8\")`    对请求数据重新编码  \n**2、response**  \n　　包括了响应客户请求的有关信息，用于对客户的请求做出动态响应，并向客户端发送数据，但在JSP中很少用到它。它是HttpServletResponse类的实例，response对象具有页面作用域，即访问一个页面时，该页面内的response对象只对该次访问有效，其他页面的response对象对当前页面无效。  \n　　作用域：page  \n　　重要方法：  \n　　`response.sendRedirect(\"页面\")`    页面跳转  \n　　`response.setCharacterEncoding(\"gbk\");`   设置响应编码  \n**3、Out**  \n　　Out对象用于各种对象的输出，是用来向客户端输出内容的对象。out对象是JspWriter类的实例。  \n　　作用域：page，每个页面都有一个自己的out对象。  \n　　重要方法：println()/print()/write()  \n**4、session**  \n　　session对象指的是客户端与服务器的一次对话，从客户端连到服务器的WebApplication开始，知道客户端与服务器断开连接为止。它是HttpSession类的实例。  \n　　session对象是一个JSP内置对象，它在第一个JSP页面被装载时自动创建，完成会话期管理。从一个客户打开浏览器并连到服务器开始，到客户关闭浏览器离开这个服务器结束，被称为一个会话。当一个客户方位一个服务器时，可能会在这个服务器的几个页面之间切换，服务器通过session对象知道这是同一个客户。session对象具有会话作用域。  \n　　作用域：session  \n　　重要方法： \n　　(1)`session.getid();`    取得session的id号，id是由Tomcat分配  \n　　(2)`session.isnew();`   判断session是否为新建  \n　　(3)`session.setAttribute(key,Object);`    往当前会话中设置一个属性  \n　　(4)`session.getAttribute(key);`  获取当前会话中的一个属性  \n　　(5)`session.removeAttribute(key);`   删除当前会话中的一个属性  \n　　(6)`session.setMaxInactiveInterval(1000*60*30);`  设置当前会话失效时间(ms)，Tomcat默认的会话时间为30分钟  \n　　(7)`session.invalidate();`   初始化当前会话对象(一般在退出的时候使用，可以删除当前会话的数据)\n　　会话结束条件(之一即可)：  \n　　(1)服务器关闭  \n　　(2)会话过期(一般会话时间默认为30分钟)  \n　　(3)手动终止会话  \n**5、Applicaiton**  \n　　Applicaiton对象实现了用户间数据的共享，可存放全局变量。它开始于服务器的启动，结束语服务器的关闭，在此期间，此对象一直存在。这样在用户的连接或不同用户之间的连接中，可以对此对象的同一属性进行操作；在任何地方对此对象的属性进行操作；都将影响到其他用户对此对象的访问。服务器的启动和关闭决定了Applicaiton对象的生命。它是ServletContext类的实例。  \n　　作用域：Applicaiton  \n**6、PageContext**  \n　　PageContext对象提供了对JSP页面内所有的对象及名字空间的访问，也就是说它可以访问到本页的session，也可以取本页所在的Application的某一属性值，他相当于页面中所有功能的集大成者，它的本类名也叫PageContext，是javax.servlet.jsp.PageContext的实例。  \n　　作用域：page\n**7、page**\n　　JSP网页本身的page对象是当前页面转换后的servlet类实例，page对象是指向当前jsp页面本身的，就像类中的this指针，它是Java.lang.Object类的实例。从转换后的servlet代码中，可以看到这样的关系 Object this = page，在jsp页面中很少使用page对象。  \n　　作用域：page  \n**8、config**  \n　　config对象是在一个Servlet初始化时，JSP引擎向它传递信息用的，此信息包括servlet初始化时所要用到的参数(通过属性名和属性值构成)以及服务器的有关信息(通过传递一个ServletContext对象)，config对象Javax.servlet.ServletConfig的实例，该实例代表JSP的配置信息。  \n　　作用域：page  \n　　注：事实上，JSP页面通常无需配置，也就不存在配置信息，因此该对象更多的是在servlet中有效。  \n**9、Execption**  \n　　Execption对象是一个例外对象，当一个页面在运行过程中发生了例外，就产生了这个对象。如果一个页面要应用此对象，就必须把isErrorPage设为true，否则无法编译，即在页面指令中设置`<%@page isErrorPage=\"true\"%>`，它实际上是java.lang.Throwable的实例，该实例代表其他页面的错误或异常。  \n　　作用域：page  \n　　JSP常见错误状态码：  \n　　403：禁止访问。比如IP地址被拒绝，站点访问被拒绝等。  \n　　404：找不到。没有找到文件或目录。  \n　　500：服务器由于遇到错误而不能完成该请求(代码错误)。Web服务器太忙。  \n  \n  参考链接：https://www.cnblogs.com/zying3/p/10245047.html\n\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 174, 1, '2020-10-16 21:17:32', '2021-3-13 19:24:07', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (11, 10000, 'SQL中查询指定数据的上一条或者下一条数据。', '我们在浏览网站的时候，一般都会在文章的末尾处显示一个“上一篇”或者“下一篇”，这个时候，对我们就得从数据库中取出当前文章的上一条记录或者下一条记录了。', '&emsp;&emsp;我们在浏览网站的时候，一般都会在文章的末尾处显示一个“上一篇”或者“下一篇”，这个时候，对我们就得从数据库中取出当前文章的上一条记录或者下一条记录了。\r\n\r\n假设**当前文章ID为表searchId**，我们要从数据库中查找出位于searchId上一条数据或者下一条数据。\r\n\r\n1.查询上一条数据：\r\n\r\n    select * from tbContent where id=(select max(id) from tbContent where id<searchId) \r\n    \r\n\r\n2.查询下一条数据：\r\n\r\n    select * from tbContent  where id=(select min(id) from tbContent  where id>searchId)\r\n    \r\n3.查询上一条和下一条数据：\r\n\r\n    select * from tbContent where \r\n    id in((select max(id) from tbContent where id< searchId), \r\n    (select min(id) from tbContent where id> searchId)) \r\n    \r\n	\r\n	\r\n\r\n原文链接：https://blog.csdn.net/ZeroRm/article/details/88552821\r\n\r\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/mysql.jpg', 0, 0, 488, 1, '2020-10-17 10:07:28', '2021-3-15 20:04:39', 'https://blog.csdn.net/ZeroRm/article/details/88552821', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (12, 10000, '使用IDEA打包war包出现process terminated', 'IDEA打包成war包出现process&emsp;terminated<br>解决方法：File->Setting->Build,Execution,Deployment->Build&emsp;Tools->Maven<br>其中的User&emsp;settings&emsp;file&emsp;和&emsp;Local&emsp;repository<br>这两个选项后面的override如果时勾选状态的，需要取消勾选，然后再进行打包。', 'IDEA打包成war包出现process terminated\n解决方法：File->Setting->Build,Execution,Deployment->Build Tools->Maven\n其中的User settings file 和 Local repository\n这两个选项后面的override如果时勾选状态的，需要取消勾选，然后再进行打包。\n![](http://112.124.21.222/images/blogImages/QQ截图20201031194125.png)\n这只是其中的一种情况，如有其他答案欢迎在下方留言，谢谢！\n### 123\n|column1|column2|column3|\n|-|-|-|\n|content1|content2|content3|\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 93, 1, '2020-10-17 12:57:43', '2021-5-16 10:43:11', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (13, 10000, 'tomcat报错：警告 [main]Cache.getResource 无法将位于....因为在清除过期缓存条目后可用空间仍不足 - 请考虑增加缓', 'tomcat运行报错', '错误提示：\norg.apache.catalina.webresources.Cache.getResource Unable to add the resource at xxx to the cache because there was insufficient free space available after evicting expired cache entries - consider increasing the maximum size of the cache\n\n解决办法：在 /conf/context.xml 的 \n```\n<Resources cachingAllowed=\"true\" cacheMaxSize=\"100000\" />\n```', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 37, 1, '2020-10-17 16:47:10', '2021-2-24 10:57:03', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (14, 10000, '同一Tomcat下部署多个项目，通过不同域名直接访问', '多个项目部署在一个服务器上，使用不同域名访问', '&emsp;&emsp;最近博主所在的公司上线了两套系统，因为这两个系统不是很复杂，所以将两个Web项目部署在了同一个Tomcat上，那么问题就来了，部署在同一个Tomcat目录下的webapps中的项目，总不能每次都通过在访问路径后面加项目名称进行区分吧？而且两个项目是两个不同的域名，那么可不可以通过一种配置，让……\r\n&emsp;&emsp;好了废话不多说，既然大家看到了这篇博文，就一定遇到了同样的问题，也许你会想到加一个Nginx这种类型的代理服务器，但其实根本不用，直接在Tomcat的server.xml中配置即可，直接上解决方案！\r\n&emsp;&emsp;此处两个项目的域名假设是www.aaa.com、www.bbb.com，在webapps下面对应的文件夹分别是a、b。\r\n&emsp;&emsp;首先打开Tomcat安装目录下的conf文件夹，然后打开并编辑server.xml，找到节点，在里面配置两个host标签即可：\r\n\r\n------------\r\n\r\n\r\n    <Host name=\"www.aaa.com\"  appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\">\r\n    	<Context  path=\"\"  docBase=\"D:\\tomcat\\webapps\\a\" reloadable=\"true\"/>\r\n    </Host>\r\n\r\n------------\r\n\r\n\r\n    <Host name=\"www.bbb.com\"  appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\">\r\n    	<Context  path=\"\"  docBase=\"D:\\tomcat\\webapps\\b\" reloadable=\"true\"/>\r\n    </Host>\r\n	\r\n\r\n------------\r\n\r\n参考链接：https://blog.csdn.net/wzy18210825916/article/details/88940962\r\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 50, 1, '2020-10-17 19:05:28', '2020-10-29 18:21:12', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (16, 10000, 'POST和GET的区别', 'POST和GET是HTTP请求的两种方式，都可实现将数据从浏览器向服务器发送带参数的请求。<br>HTTP请求底层协议都是TCP/IP，所以两者没有本质的区别。<br>GET是获取的意思，顾名思义就是获取信息。<br>GET是默认的HTTP请求方法。', '### POST和GET是什么？\r\n　　POST和GET是HTTP请求的两种方式，都可实现将数据从浏览器向服务器发送带参数的请求。\r\n　　HTTP请求底层协议都是TCP/IP，所以两者没有本质的区别。\r\n### GET方法\r\n　　GET是获取的意思，顾名思义就是获取信息。\r\n　　GET是默认的HTTP请求方法。\r\n　　GET方法把参数通过key/value形式存放在URL里面，如果参数是英文数字原样显示，如果是中文或者其他字符加密（Base64）URL长度一般有限制所以GET方法的参数长度不能太长。由于参数显示再地址栏所以不安全，一般需要保密的请求不使用GET。\r\n### POST方法\r\n　　POST是邮件的意思，顾名思义就像一封信一样将参数放在信封里面传输。它用于修改服务器上的数据，一般这些数据是应该保密的，就像信件一样，信的内容只能收信的人看见。例如当用户输入账号和密码登录时账号和密码作为参数通过HTTP请求传输到服务器，这时候肯定不能用GET方法将账号密码直接显示再URL上，这时候就应该用POST方法保证数据的保密性。\r\n### POST和GET的区别\r\nGET提交的数据放在URL中，POST则不会。这是最显而易见的差别。这点意味着GET更不安全（POST也不安全，因为HTTP是明文传输抓包就能获取数据内容，要想安全还得加密）\r\nGET回退浏览器无害，POST会再次提交请求（GET方法回退后浏览器再缓存中拿结果，POST每次都会创建新资源）\r\nGET提交的数据大小有限制（是因为浏览器对URL的长度有限制，GET本身没有限制），POST没有\r\nGET可以被保存为书签，POST不可以。这一点也能感受到。\r\nGET能被缓存，POST不能\r\nGET只允许ASCII字符，POST没有限制\r\nGET会保存再浏览器历史记录中，POST不会。这点也能感受到。\r\n总之，两者之间没有本质区别，区别就在于数据存储的位置。各自有适用环境，根据需求选择合适的方法即可。\r\n还有哪些HTTP请求方法\r\nGET和POST是最常用的HTTP请求方式。还有其他的请求方式。我没用过其他的，我只说我知道的把。以后遇到了再补充。\r\nPUT:\r\nHEAD\r\nDELETE\r\n...\r\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 41, 1, '2020-10-18 20:31:18', '2020-11-1 11:06:01', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (17, 10000, '[Vue学习]购物车案例', '要求:使用vue.js设计一个简单的购物车案例，包括购物车中商品数量的增加和商品的删除，并在下方计算出总价格，当购物车为空时显示：购物车为空', '&emsp;&emsp;要求:使用vue.js设计一个简单的购物车案例，包括购物车中商品数量的增加和商品的删除，并在下方计算出总价格，当购物车为空时显示：购物车为空\r\n先上效果图\r\n![](http://112.124.21.222/images/blogImages/QQ截图20201102173335.png)\r\nHTML文件\r\n\r\n    <!DOCTYPE html>\r\n    <html lang=\"en\">\r\n    <head>\r\n        <meta charset=\"UTF-8\">\r\n        <title>书籍购物车案例</title>\r\n        <link rel=\"stylesheet\" href=\"css/book.css\">\r\n    </head>\r\n    <body>\r\n    \r\n    <div id=\"app\">\r\n        <div v-if=\"bookList.length !== 0\">\r\n        <table>\r\n            <thead>\r\n            <tr>\r\n                <th></th>\r\n                <th>书籍名称</th>\r\n                <th>出版日期</th>\r\n                <th>价格</th>\r\n                <th>购买数量</th>\r\n                <th>操作</th>\r\n            </tr>\r\n            </thead>\r\n            <tbody>\r\n            <tr v-for=\"(items,index) in bookList\">\r\n                <td>{{index+1}}</td>\r\n                <td>{{items.name}}</td>\r\n                <td>{{items.date}}</td>\r\n                <!--<td>{{getFinalPrice(items.price)}}</td>-->\r\n                <!--上面是函数写法，下面是过滤器写法-->\r\n                <td>{{items.price | showPrice}}</td>\r\n                <td>\r\n                    <button @click=\"increment(items)\" :disabled=\"items.count<=1\">-</button>\r\n                    {{items.count}}\r\n                    <button @click=\"decrement(items)\">+</button>\r\n                </td>\r\n                <td>\r\n                    <button @click=\"removeBook(index)\">移除</button>\r\n                </td>\r\n            </tr>\r\n            </tbody>\r\n        </table>\r\n            <div>总价格为:{{totalPrice | showPrice}}</div>\r\n        </div>\r\n        <div v-else>购物车为空</div>\r\n    </div>\r\n    \r\n    <script src=\"../vue/js/vue.js\"></script>\r\n    <script src=\"js/book.js\"></script>\r\n    </body>\r\n    </html>\r\nCSS文件\r\n\r\n    tr {\r\n        height: 30px;\r\n        background-color: whitesmoke;\r\n        text-align: center;\r\n    }\r\n    \r\nJS文件\r\n\r\n    const app = new Vue({\r\n        el: \'#app\',\r\n        data: {\r\n            bookList: [\r\n                {\r\n                    id: 1,\r\n                    name: \'《算法导论》\',\r\n                    date: \'2006-9\',\r\n                    price: 85.00,\r\n                    count: 1\r\n                },\r\n                {\r\n                    id: 2,\r\n                    name: \'《UNIX编程艺术》\',\r\n                    date: \'2006-9\',\r\n                    price: 59.00,\r\n                    count: 1\r\n                },\r\n                {\r\n                    id: 3,\r\n                    name: \'《编程珠玑》\',\r\n                    date: \'2006-9\',\r\n                    price: 39.00,\r\n                    count: 1\r\n                },\r\n                {\r\n                    id: 4,\r\n                    name: \'《代码大全》\',\r\n                    date: \'2006-9\',\r\n                    price: 128.00,\r\n                    count: 1\r\n                },\r\n                {\r\n                    id: 5,\r\n                    name: \'《计算机网络》\',\r\n                    date: \'2006-9\',\r\n                    price: 58.00,\r\n                    count: 1\r\n                }\r\n            ]\r\n        },\r\n        computed: {\r\n            totalPrice() {\r\n                let totalPrice = 0;\r\n                for (let i = 0; i < this.bookList.length; i++) {\r\n                    totalPrice += this.bookList[i].price * this.bookList[i].count;\r\n                }\r\n                return totalPrice;\r\n            }\r\n        },\r\n        methods: {\r\n            getFinalPrice(price) {\r\n                return \'￥\' + price.toFixed(2);\r\n            },\r\n            increment(items) {\r\n                items.count--;\r\n            },\r\n            decrement(items) {\r\n                items.count++;\r\n            },\r\n            removeBook(index) {\r\n                this.bookList.splice(index, 1)\r\n            }\r\n        },\r\n        filters: {\r\n            showPrice(price) {\r\n                return \'￥\' + price.toFixed(2);\r\n            }\r\n        }\r\n    })', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 49, 1, '2020-10-18 20:45:25', '2020-11-9 11:46:57', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (18, 10000, 'JS高阶函数之fliter()、map()、reduce(),实例-计算一个数组中特定元素之和', '要求：<br>1.对一个数组进行筛选，保留小于等于50的元素<br>2.对1中的结果中的所有元素乘2<br>3.对2中的结果中的所有元素相加并返回结果', '### 高阶函数定义([引用地址](https://segmentfault.com/a/1190000019796451))\n`高阶函数`英文叫 `Higher-order function`。高阶函数是对其他函数进行操作的函数，操作可以是将它们作为参数，或者返回它们。简单总结为高阶函数是`一个接收函数作为参数`或者`将函数作为返回输出`的函数。\n\n\n要求：\n1.对一个数组进行筛选，保留小于等于50的元素 \n2.对1中的结果中的所有元素乘2 \n3.对2中的结果中的所有元素相加并返回结果 \n\n    let a = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];\n    //一般写法：不推荐\n    // 1.filter的使用,过滤\n    let b = a.filter(function (n) {\n        return n <= 50;\n    })\n    console.log(b);\n    \n    // 2.map的使用,乘2\n    let c = b.map(function (n) {\n        return n * 2;\n    })\n    console.log(c);\n    \n    // 3.reduce的使用,总和\n    let result1 = c.reduce(function (preValue, n) {\n        return preValue + n;\n    }, 0)\n    console.log(\"result1:\" + result1);\n    \n    //进阶写法：推荐但有更加简便的\n    let result2 = a.filter(function (n) {\n        return n <= 50;\n    }).map(function (n) {\n        return n * 2;\n    }).reduce(function (preValue, n) {\n        return preValue + n;\n    }, 0)\n    console.log(\"result2:\" + result2);\n    \n    //终极写法：推荐，一行完事\n    let result3 = a.filter(n => n <= 50).map(n => n * 2).reduce((pre, n) => pre + n, 0);\n    console.log(\"result3:\" + result3);\n    ', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 228, 1, '2020-10-18 20:54:17', '2022-2-28 15:33:16', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (20, 10000, '为什么Vue模板中的data必须是函数', '为什么Vue模板中的data必须是函数', '### Vue模板中的data必须是函数的原因是：使用函数的作用域\n\n如果不是函数会引起的错误：\n&emsp;&emsp;假设在计数器中，我们把计数器封装成为一个组件，并在同一个地方调用多次该计数器，如果data不是函数而是对象，那么，多个计数器共享一个counter(计数器值：变量)，这样会引起点击一个计数器中的加号或减号会引起所有的计数器的值发生改变。 \n\n&emsp;&emsp;使用函数时，由于函数有自己的作用域，所以各个计数器之间的data都是独立的，改变一个计数器的data不会影响其它计数器的data值。', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 34, 1, '2020-10-19 09:09:37', '2021-1-16 18:20:09', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (21, 10000, 'HTML中6种空白空格', 'HTML中6种空白空格,markdown使用必备', '<p><h2 id=\"h2-html-6-\"><a name=\"HTML中6种空白空格\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HTML中6种空白空格</h2><p><font size=3><br>HTML提供了5种空格实体（space entity），它们拥有不同的宽度，非断行空格（ ）是常规空格的宽度，可运行于所有主流浏览器。其他几种空格（ &ensp &emsp &thinsp &zwnj &zwj）在不同浏览器中宽度各异。\r\n<p>&amp;nbsp它叫不换行空格，全称No-Break Space，它是最常见和我们使用最多的空格，大多数的人可能只接触了 ，它是按下space键产生的空格。在HTML中，如果你用空格键产生此空格，空格是不会累加的（只算1个）。要使用html实体表示才可累加，该空格占据宽度受字体影响明显而强烈。</p><br><p>&amp;ensp它叫“半角空格”，全称是En Space，en是字体排印学的计量单位，为em宽度的一半。根据定义，它等同于字体度的一半（如16px字体中就是8px）。名义上是小写字母n的宽度。此空格传承空格家族一贯的特性：透明的，此空格有个相当稳健的特性，就是其占据的宽度正好是1/2个中文宽度，而且基本上不受字体影响。</p><br><p>&amp;emsp它叫“全角空格”，全称是Em Space，em是字体排印学的计量单位，相当于当前指定的点数。例如，1 em在16px的字体中就是16px。此空格也传承空格家族一贯的特性：透明的，此空格也有个相当稳健的特性，就是其占据的宽度正好是1个中文宽度，而且基本上不受字体影响。</p><br><p>&amp;thinsp它叫窄空格，全称是Thin Space。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。它是em之六分之一宽。</p><br><p>&amp;zwnj它叫零宽不连字，全称是Zero Width Non Joiner，简称“ZWNJ”，是一个不打印字符，放在电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制。Unicode中的零宽不连字字符映射为“”（zero width non-joiner，U+200C），HTML字符值引用为： ‌</p><br><p>&amp;zwj它叫零宽连字，全称是Zero Width Joiner，简称“ZWJ”，是一个不打印字符，放在某些需要复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果。零宽连字符的Unicode码位是U+200D (HTML: ‍ ‍）。</p><br><p>此外，浏览器还会把以下字符当作空白进行解析：空格（&amp;#x0020）、制表位（&amp;#x0009）、换行（&amp;#x000A）和回车（&amp;#x000D）还有（&amp;#12288）等等。<br><br>出处：<a href=\"http://www.oicqzone.com/pc/2015083122336.html\">http://www.oicqzone.com/pc/2015083122336.html</a></p>\r\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 17, 1, '2020-10-19 09:17:45', '2020-12-9 23:12:38', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (22, 10000, '使用editormd上传图片到服务器tomcat的webapp项目的同级文件夹下。', '使用editormd上传图片到服务器tomcat的webapp项目的同级文件夹下。<br>我们在使用editormd作为我们博客的编辑软件是，会发现一个问题，那就是图片上传不了，这会让我们舒适体验感大大降低，从而对我们的心理造成伤害，或者我们能上传图片了，但是上传到服务器tomcat文件夹下的项目文件夹中，这样我们每次部署新版的项目时都需要把...', '&emsp;&emsp;我们在使用editormd作为我们博客的编辑软件是，会发现一个问题，那就是图片上传不了，这会让我们舒适体验感大大降低，从而对我们的心理造成伤害，或者我们能上传图片了，但是上传到服务器tomcat文件夹下的项目文件夹中，这样我们每次部署新版的项目时都需要把图片问价夹拷贝出来，很不方便，容易把我们给累死。\r\n&emsp;&emsp;接下来教给大家一种绝对路径上传图片，把图片上传到webapp文件夹下而不是项目文件夹下，这样能省去很多麻烦，特备是我上面提到的要把图片文件夹拷贝到新版项目的目录下。\r\n&emsp;&emsp;其实很简单，把目录改成绝对路径不就行了吗？对啊，就是如此。具体代码如下。\r\n第一步：先开启editormd的上传图片功能：\r\n\r\n    var editor = editormd(\"article-editor\", {\r\n            width: \"90%\",\r\n            height: 700,\r\n            path: \"/tools/editormd/lib/\",   //editor.md插件的lib目录地址\r\n            codeFold: true,\r\n            searchReplace: true,\r\n            saveHTMLToTextarea: true,\r\n            imageUpload: true,   //开启图片上传\r\n            imageFormats: [\"jpg\", \"jpeg\", \"gif\", \"png\", \"bmp\", \"webp\"],\r\n            imageUploadURL: \"/uploadfile\",\r\n            htmlDecode: \"style,script,iframe|on*\",\r\n            lineNumbers: true,\r\n            emoji: true,\r\n            taskList: true,\r\n            tocm: true,\r\n            tex: true,\r\n            flowChart: true,\r\n            sequenceDiagram: true,\r\n        });\r\n\r\n\r\n第二步：设计controller类\r\n\r\n    import java.io.File;\r\n    import java.io.IOException;\r\n    import javax.servlet.http.HttpServletRequest;\r\n    import javax.servlet.http.HttpServletResponse;\r\n    \r\n    import com.alibaba.fastjson.JSONObject;\r\n    import org.apache.commons.io.FileUtils;\r\n    import org.springframework.stereotype.Controller;\r\n    import org.springframework.web.bind.annotation.RequestMapping;\r\n    import org.springframework.web.bind.annotation.RequestMethod;\r\n    import org.springframework.web.bind.annotation.RequestParam;\r\n    import org.springframework.web.bind.annotation.ResponseBody;\r\n    import org.springframework.web.multipart.MultipartFile;\r\n    @Controller\r\n    public class UploadController {\r\n        @ResponseBody\r\n        @RequestMapping(value = \"/uploadfile\", method = RequestMethod.POST)\r\n        public JSONObject hello(HttpServletRequest request, HttpServletResponse response,\r\n                                @RequestParam(value = \"editormd-image-file\", required = false) MultipartFile attach) {\r\n    \r\n            JSONObject jsonObject=new JSONObject();\r\n    \r\n            try {\r\n                request.setCharacterEncoding(\"utf-8\");\r\n                response.setHeader(\"Content-Type\", \"text/html\");\r\n                String rootPath = \"C:\\\\Program Files\\\\Apache Software Foundation\\\\Tomcat 9.0\\\\webapps\\\\images\\\\blogImages\";\r\n                System.out.println(\"editormd上传图片：\"+rootPath);\r\n                /**\r\n                 * 文件路径不存在则需要创建文件路径\r\n                 */\r\n                File filePath = new File(rootPath);\r\n                if (!filePath.exists()) {\r\n                    filePath.mkdirs();\r\n                }\r\n                // 最终文件名\r\n                File realFile = new File(rootPath + File.separator + attach.getOriginalFilename());\r\n                FileUtils.copyInputStreamToFile(attach.getInputStream(), realFile);\r\n                // 下面response返回的json格式是editor.md所限制的，规范输出就OK\r\n                jsonObject.put(\"success\", 1);\r\n                jsonObject.put(\"message\", \"上传成功\");\r\n                jsonObject.put(\"url\", \"http://111.111.111.111/images/blogImages/\"+attach.getOriginalFilename());\r\n            } catch (Exception e) {\r\n                jsonObject.put(\"success\", 0);\r\n            }\r\n            return jsonObject;\r\n        }\r\n    }\r\n\r\n看到了吗，rootpath:\r\n`String rootPath = \"C:\\\\Program Files\\\\Apache Software Foundation\\\\Tomcat 9.0\\\\webapps\\\\images\\\\blogImages\";`\r\nrootpath是我设置的根目录路径，这个时候，图片就被上传到了该文件夹下。\r\n但是如果想访问到的话，还是需要放在tomcat的webapp文件夹下的，这个时候通过绝对地址,即回显的URL：`jsonObject.put(\"url\", \"http://111.111.111.111/images/blogImages/\"+attach.getOriginalFilename());`\r\n（如：https://img-blog.csdnimg.cn/2018112415311259.png ），就可以访问到了。非常的方便。\r\n\r\njsonObject我用的是阿里云的fastJson，大家可以使用这个，附上依赖：\r\n\r\n    <dependency>\r\n    	<groupId>com.alibaba</groupId>\r\n    	<artifactId>fastjson</artifactId>\r\n    	<version>1.2.51</version>\r\n    </dependency>', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 43, 1, '2020-10-19 20:58:27', '2020-11-6 10:47:08', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (23, 10000, '[Vue学习]子组件和父组件的传值操作', '子组件和父组件的传值操作。<br>父组件到子组件：props<br>子组件到父组件：自定义函数', '#### 父组件到子组件：props\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Title</title>\n    </head>\n    <body>\n    <div id=\"app\">\n        <cpn :cmovies=\"movies\"></cpn>\n    </div>\n    \n    <template id=\"cpn\">\n        <div>\n            <div v-for=\"items in cmovies\">{{items}}</div>\n        </div>\n    </template>\n    \n    <script src=\"../vue/js/vue.js\"></script>\n    <script>\n        const cpn = {\n            template: `#cpn`,\n            props: [\'cmovies\']\n        }\n    \n        const app = new Vue({\n            el: \'#app\',\n            data: {\n                message: \'Vue模板\',\n                movies: [\'海王\',\'海贼王\',\'星际援救\',\'天空\']\n            },\n            components: {\n                cpn\n            }\n        })\n    </script>\n    </body>\n    </html>\n\nprops的写法\n![QQ截图20210117105507.png](http://112.124.21.222/images/blogImages/20210117105556QQ截图20210117105507.png)\n#### 子组件到父组件：自定义函数\n\n    <!DOCTYPE html>\n    <html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>Title</title>\n    </head>\n    <body>\n    <div id=\"app\">\n        <cpn @item-click=\"cpnClick\" class=\"hello\"></cpn>\n    </div>\n    \n    <template id=\"cpn\">\n        <div>\n            <button v-for=\"item in categories\" @click=\"btnClick(item)\">{{item.name}}</button>\n        </div>\n    </template>\n    \n    <script src=\"../vue/js/vue.js\"></script>\n    <script>\n        const cpn = {\n            template: `#cpn`,\n            data() {\n                return {\n                    categories: [\n                        {id: \'aaa\', name: \'热门推荐\'},\n                        {id: \'bbb\', name: \'手机数码\'},\n                        {id: \'ccc\', name: \'家用家电\'},\n                        {id: \'ddd\', name: \'电脑办公\'},\n                    ]\n                }\n            },\n            methods: {\n                btnClick(item) {\n                    this.$emit(\'item-click\', item)\n                }\n            }\n        }\n    \n        const app = new Vue({\n            el: \'#app\',\n            data: {\n                message: \'Vue模板\'\n            },\n            components: {\n                cpn\n            },\n            methods: {\n                cpnClick(item) {\n                    console.log(\'cpnClick\', item)\n                }\n            }\n        })\n    </script>\n    </body>\n    </html>', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 131, 1, '2020-10-19 21:06:59', '2021-1-17 10:56:38', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (24, 10000, 'js和jq获得浏览器和屏幕高度', 'js和jq获得浏览器和屏幕高度', '原生JS：\r\n\r\n    IE中：\r\n    document.body.clientWidth ==> BODY对象宽度\r\n    document.body.clientHeight ==> BODY对象高度\r\n    document.documentElement.clientWidth ==> 可见区域宽度\r\n    document.documentElement.clientHeight ==> 可见区域高度\r\n    \r\n    FireFox中：\r\n    document.body.clientWidth ==> BODY对象宽度\r\n    document.body.clientHeight ==> BODY对象高度\r\n    document.documentElement.clientWidth ==> 可见区域宽度\r\n    document.documentElement.clientHeight ==> 可见区域高度\r\n    \r\n    Opera中：\r\n    document.body.clientWidth ==> 可见区域宽度\r\n    document.body.clientHeight ==> 可见区域高度\r\n    document.documentElement.clientWidth ==> 页面对象宽度（即BODY对象宽度加上Margin宽）\r\n    document.documentElement.clientHeight ==> 页面对象高度（即BODY对象高度加上Margin高）\r\n    \r\n    alert(document.body.clientWidth);        //网页可见区域宽(body)\r\n    alert(document.body.clientHeight);       //网页可见区域高(body)\r\n    alert(document.body.offsetWidth);       //网页可见区域宽(body)，包括border、margin等\r\n    alert(document.body.offsetHeight);      //网页可见区域宽(body)，包括border、margin等\r\n    alert(document.body.scrollWidth);        //网页正文全文宽，包括有滚动条时的未见区域\r\n    alert(document.body.scrollHeight);       //网页正文全文高，包括有滚动条时的未见区域\r\n    alert(document.body.scrollTop);           //网页被卷去的Top(滚动条)\r\n    alert(document.body.scrollLeft);           //网页被卷去的Left(滚动条)\r\n    alert(window.screenTop);                     //浏览器距离Top\r\n    alert(window.screenLeft);                     //浏览器距离Left\r\n    alert(window.screen.height);                //屏幕分辨率的高\r\n    alert(window.screen.width);                 //屏幕分辨率的宽\r\n    alert(window.screen.availHeight);          //屏幕可用工作区的高\r\n    alert(window.screen.availWidth);           //屏幕可用工作区的宽\r\n	\r\nJQuery\r\n\r\n    alert($(window).height());                           //浏览器当前窗口可视区域高度\r\n    alert($(document).height());                        //浏览器当前窗口文档的高度\r\n    alert($(document.body).height());                //浏览器当前窗口文档body的高度\r\n    alert($(document.body).outerHeight(true));  //浏览器当前窗口文档body的总高度 包括border padding margin\r\n    alert($(window).width());                            //浏览器当前窗口可视区域宽度\r\n    alert($(document).width());                        //浏览器当前窗口文档对象宽度\r\n    alert($(document.body).width());                //浏览器当前窗口文档body的宽度\r\n    alert($(document.body).outerWidth(true));  //浏览器当前窗口文档body的总宽度 包括border padding margin\r\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 48, 1, '2020-10-19 21:08:21', '2020-11-6 21:26:43', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (25, 10000, '笔试题', '笔试题记录', '1.[JS基础---常见的Bom对象](https://www.cnblogs.com/vicky1018/p/7692386.html \"JS基础---常见的Bom对象\")\r\n\r\n2.[前端性能优化之重排和重绘](https://www.cnblogs.com/soyxiaobi/p/9963019.html \"前端性能优化之重排和重绘\")\r\n\r\n3.[为什么Vue生命周期函数不能使用箭头函数书写](https://blog.csdn.net/qq_40202869/article/details/106054286 \"为什么Vue生命周期函数不能使用箭头函数书写\")\r\n\r\n4.[CSS: 元素高度为自身宽度的一半](https://www.jianshu.com/p/e2540496370a \"CSS: 元素高度为自身宽度的一半\")\r\n\r\n5.[什么是跨域？跨域解决方法](https://blog.csdn.net/qq_38128179/article/details/84956552 \"什么是跨域？跨域解决方法\")\r\n\r\n6.[JS闭包的理解及常见应用场景](https://www.cnblogs.com/Renyi-Fan/p/11590231.html \"JS闭包的理解及常见应用场景\")\r\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 27, 1, '2020-10-19 21:15:31', '2020-11-7 15:02:40', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (26, 10000, 'textarea中的换行如何保存到数据库中并显示到前端页面。', '今天在做摘要的时候，发现textarea中的换行符不能保存到数据库中。但通过后台提取数据显示到html页面中时，却发现没有换行。原来这是因为数据库把换行符过滤掉了。<br>那该怎么办呢，其实可以用一种迂回的方法将其写入到数据库中，就是可以先把换行符转换为特定的字符串，读取出来的时候再替换回来。', '&emsp;&emsp;今天在做摘要的时候，发现textarea中的换行符不能保存到数据库中。但通过后台提取数据显示到html页面中时，却发现没有换行。原来这是因为数据库把换行符过滤掉了。  \n&emsp;&emsp;那该怎么办呢，其实可以用一种迂回的方法将其写入到数据库中，就是可以先把换行符转换为特定的字符串，读取出来的时候再替换回来。  \n&emsp;&emsp;比如，提交数据时利用 js 获取 textarea 中的内容，再把所有换行符转为br换行符。  \n&emsp;&emsp;保存换行的方法。  \n&emsp;&emsp;情况一：在js中处理换行。提交时先替换字符再存到数据库中。  \n\n    <script type=\"text/javascript\">\n                var content = $(\"#form1 textarea\").val();\n                content = content.replace(/\\n|\\r\\n/g,\"<br>\");\n    </script>\n\n&emsp;&emsp;读取出来的时候再替换回来。\n\n    <script type=\"text/javascript\">  \n            $(function() {  \n                var content =\'${blog.article}\'; //使用el表达式获取数据\n                content = content.replace(/<br>/g,\"\\n\");//将<br>替换为换行符 \"\\n\"   \n              //$(\"div_demo\").text(content);\n            });  \n    </script> \n    \n\n&emsp;&emsp;情况二，在java中处理。\n\n    	String hdText1 = detailPojos.getHdText1();\n        hdText1 = hdText1.replaceAll(\"(\\\\r\\\\n|\\\\n|\\\\n\\\\r)\",\"<br/>\");\n        logger.info(hdText1)\n    \n\n参考链接：\n情况一：https://blog.csdn.net/qq_23483671/article/details/79017609\n情况二：https://blog.csdn.net/sunshiine8080/article/details/105160729\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 25, 1, '2020-10-19 21:31:21', '2020-12-2 23:25:31', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (27, 10000, '安装npm时，报错rollbackFailedOptional: verb npm-session的解决办法', '安装npm时，报错rollbackFailedOptional:&emsp;verb&emsp;npm-session的解决办法', '先执行`npm config set registry http://registry.npm.taobao.org`\r\n\r\n再执行安装命令，如`npm install webpack@3.6.0 -g`', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 22, 1, '2020-10-19 23:07:22', '2020-11-8 15:20:31', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (28, 10000, '风景', '风景', '12', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 79, 1, '2020-10-20 13:57:16', '2021-8-13 11:40:41', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (29, 10000, 'vue学习关键词', 'vue学习关键词', 'webpack环境中集成vue\r\n\r\nvue响应式实现的核心：defineProperty()函数', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 22, 1, '2020-10-20 14:11:35', '2020-11-14 19:44:38', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (30, 10000, 'webpack', 'webpack', 'node.js', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webpacklogo.png', 0, 0, 80, 1, '2020-10-20 14:15:52', '2020-11-15 17:42:18', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (31, 10000, '[Vue学习]Runtime-Complier和Runtime-only的区别', 'Runtime-Complier和Runtime-only的区别', 'Runtime-Complier和Runtime-only的区别', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 19, 1, '2020-10-20 14:18:01', '2020-11-13 16:24:18', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (32, 10000, '总结下var、let 和 const 的区别', 'var&emsp;和&emsp;let&emsp;的区别是老生常谈，看到网上一些文章的总结，有的不太全面，甚至有的描述不太准确，在这里尽量全面的总结下这三者的区别。', 'let 是 ES6新增的变量类型，用来代替 var 的一些缺陷，跟 var 相比主要有以下区别：\r\n### 1. let 使用块级作用域\r\n在 ES6之前，ES5中js只有全局作用域和函数作用域，例如：\r\n\r\n    if(true) {\r\n       var a = \'name\'\r\n    }\r\n    console.log(\'a\',a) // name\r\n	\r\n作用域是一个独立的地盘，让变量不外泄出去，但是上例中的变量就外泄了出去，所以此时 JS 没有块级作用域的概念。\r\n\r\n    var a = 1;\r\n    function fn() {\r\n       var a = 2;\r\n       console.log(\'fn\',a);\r\n    }\r\n    console.log(\'global\',a);\r\n    fn();\r\n	\r\n全局作用域就是最外层的作用域，如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样的坏处就是很容易冲突。\r\nES6中加入块级作用域之后：\r\n\r\n    if(true) {\r\n       let a = \'name\'\r\n    }\r\n    console.log(\'a\',a) // Uncaught ReferenceError: a is not defined\r\n	\r\n块作用域内用 let 声明的变量，在块外是不可见的，如果引用的话就会报错。\r\n### 2. let 约束了变量提升而不是没有变量提升\r\n在 js 中变量和函数都会提升:\r\n\r\n    function fn() {\r\n       console.log(\'a\',a);\r\n       var a = 1;  // undefind\r\n    }\r\n    fn()\r\na其实已经在调用前被声明了，只是没有被初始化。JavaScript会把作用域里的所有变量和函数提到函数的顶部声明,相当于：\r\n\r\n    function fn() {\r\n       var a;\r\n       console.log(\'a\',a);\r\n       a = 1;  // undefind\r\n    }\r\n    fn()\r\n	\r\nJavaScript会使用undefined缺省值创建变量a,事实上浏览器并没有把声明语句放到作用域的顶部，在编译阶段，控制流进入域，该域所有的变量和函数的声明先进入内存，文中代码的相对位置不会变动。\r\n变量提升指的是变量声明的提升，不会提升变量的初始化和赋值。\r\n并且函数的提升优先级大于变量的提升:\r\n\r\n    function fn() {\r\n                console.log(\'a\', a);\r\n                var a = 1;\r\n                function a () {\r\n                    console.log(\'I am a function\');\r\n                }\r\n            }\r\n            fn() // ƒ a () {console.log(\'I am a function\');}\r\n在上例中， let 声明的变量的作用域之外引用该变量会报错，但是否可理解为 let 没有变量提升？\r\n\r\n    let a = \'outside\';\r\n    if(true) {\r\n       console.log(a);//Uncaught ReferenceError: a is not defined\r\n        let a = \"inside\";\r\n    }\r\n\r\n报出错误 a 没有被定义，而不是引用了全局作用域里的 a，说明 let 声明的 a 也被提升了。\r\n原因是 let 设计中的暂时性死区：\r\n当前作用域顶部到该变量声明位置中间的部分，都是该let变量的死区，在死区中，禁止访问该变量。由此，我们给出结论，**let声明的变量存在变量提升， 但是由于死区我们无法在声明前访问这个变量。**\r\n### 3. let 禁止重复声明变量\r\n使用 var 可以重复声明变量，但是 let 不允许在同一块作用域内重复声明同一个变量：\r\n\r\n    function fn (){\r\n       var a = 1;\r\n       let a = 2;\r\n       console.log(a); //SyntaxError\r\n    }\r\n    \r\n    function fn (){\r\n       let a = 1;\r\n       let a = 2;\r\n       console.log(a); //SyntaxError\r\n    }\r\n    \r\n    function fn (a){\r\n       let a = 2;\r\n       console.log(a); //SyntaxError\r\n    }\r\n上述代码会报语法错误；\r\n### 4. let不会成为全局对象的属性\r\n我们在全局范围内声明一个变量时，这个变量自动成为全局对象的属性（在浏览器和Node.js环境下，这个全局对象分别是window和global)，但let是独立存在的变量，不会成为全局对象的属性：\r\n\r\n    var a = 1;\r\n    console.log(window.a); //1\r\n    \r\n    let b = 2;\r\n    console.log(window.b); // undefined\r\n### 5. const 声明的常量\r\n以上 let 的规则同样适用于 const，但是跟 let 的区别是 const 声明的变量不能重新赋值，所以 const 声明的变量必须经过初始化。\r\n\r\n    const a = 1;\r\n    \r\n    a = 2; // // Uncaught TypeError: Assignment to constant variable\r\n    const b; // Uncaught SyntaxError: Missing initializer in const declaration\r\n## 最后\r\n以上大概是总结后的内容，看来，还是多用 let 、const 吧。\r\n> 参考资料：https://es6.ruanyifeng.com/#docs/let', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 285, 1, '2020-10-20 18:40:02', '2020-11-15 21:26:12', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (33, 10000, 'VUE的两种跳转push和replace对比区别', 'VUE的两种跳转push和replace对比区别', '#### router.push(location)  \n在vue.js中想要跳转到不同的 URL，需要使用 router.push 方法。  \n这个方法会向 history 栈添加一个新的记录，当用户点击浏览器后退按钮时，则回到之前的 URL。  \n当你点击  \n\n    <router-link>\n时，这个方法会在内部调用，所以说，点击  \n\n    <router-link :to=\"...\">\n等同于调用  \n\n    router.push(...)\n声明式：  \n\n    <router-link :to=\"...\">\n编程式：router.push(...)//该方法的参数可以是一个字符串路径，或者一个描述地址的对象。  \n\n    // 字符串\n    router.push(\'home\')\n    // 对象\n    this.$router.push({path: \'/login?url=\' + this.$route.path});\n    // 带查询参数，变成/backend/order?selected=2\n    this.$router.push({path: \'/backend/order\', query: {selected: \"2\"}});\n    // 命名的路由\n    router.push({ name: \'user\', params: { userId: 123 }})\n\n#### router.replace(location)\n设置 replace 属性（默认值: false）的话，当点击时，会调用 router.replace() 而不是 router.push()，于是导航后不会留下 history 记录。即使点击返回按钮也不会回到这个页面。\n> 加上replace: true后，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。\n\n    //声明式：\n        <router-link :to=\"...\" replace></router-link>\n    // 编程式:\n    router.replace(...)\n    //push方法也可以传replace\n    this.$router.push({path: \'/home\', replace: true})\n传参两种方式\n使用query:\n\n    this.$router.push({\n      path: \'/home\',\n      query: {\n        site: [],\n        bu: []\n    }\n    })\n\n使用params:\n\n    this.$router.push({\n      name: \'Home\',  // 路由的名称\n      params: {\n        site: [],\n        bu: []\n    }\n    })\n\n\n\n\n\n\n\n**params**：/router1/:id ，/router1/123，/router1/789 ,这里的id叫做params  \n**query**：/router1?id=123 ,/router1?id=456 ,这里的id叫做query。  \n### 两者都可以传递参数，区别是什么？  \nquery 传参配置的是path，而params传参配置的是name，在params中配置path无效  \nquery在路由配置不需要设置参数，而params必须设置  \nquery传递的参数会显示在地址栏中  \nparams传参刷新会无效，但是query会保存传递过来的值，刷新不变 ;  \n5.路由配置：\n\n    query 的写法\n    {\n    path: \'/home\',\n    name: Home,\n    component: Home\n    }\nparams写法：\n\n    {\n    path: \'/home/：site/:bu\',\n    name: Home,\n    component: Home\n    }\n> 如果路由上面不写参数，也是可以传过去的，但不会在url上面显示出你的参数，并且当你跳到别的页面或者刷新页面的时候参数会丢失，那依赖这个参数的http请求或者其他操作就会失败\n\n6,获取路由参数\n在接收的跳转的页面\n\n    created () {\n    let self = this\n    self.getParams()\n    },\n    watch () {\n    \'$route\': \'getParams\'\n    },\n    methods: {\n      getParams () {\n      let site = this.$route.query.site\n      let bu = this.$route.query.bu\n      // 如果是params 传参，那就是this.$route.params.site\n      上面就可以获取到传递的参数了\n     }\n    }\n> 注意：获取路由上面的参数，用的是$route，后面没有r\n\n> params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。  \nparams一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。  \nparams、query不设置也可以传参，但是params不设置的时候，刷新页面或者返回参数会丢失，query并不会出现这种情况，这一点的在上面说过了  \n\n### 最后总结：\n路由传递参数和传统传递参数是一样的，命名路由类似表单提交而查询就是url传递，在vue项目中基本上掌握了这两种传递参数就能应付大部分应用了，最后总结为以下：  \n1.命名路由搭配params，刷新页面参数会丢失  \n2.查询参数搭配query，刷新页面数据不会丢失  \n3.接受参数使用this.$router后面就是搭配路由的名称就能获取到参数的值  \n\n原文链接：https://www.jianshu.com/p/b3f4c1b3aab2\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 45, 1, '2020-10-21 11:39:48', '2020-11-28 23:17:28', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (34, 10000, 'iconfont的symbol引用方式如何在vue-cli中使用', 'iconfont的symbol引用方式如何在vue-cli中使用', '##### 一.首先下载好的iconfont.js放到目录下\r\n![](https://upload-images.jianshu.io/upload_images/5570465-5c1575a37d5b999b.png?imageMogr2/auto-orient/strip|imageView2/2/w/221/format/webp)\r\n##### 二.引入css 文件\r\n在同级目录下创建一个css文件\r\n![](https://upload-images.jianshu.io/upload_images/5570465-bbfedaeb9e90a55d.png?imageMogr2/auto-orient/strip|imageView2/2/w/246/format/webp)\r\n在css文件中添加代码\r\n\r\n    .icon {\r\n    width: 1em; height: 1em;\r\n    vertical-align: -0.15em;\r\n    fill: currentColor;\r\n    overflow: hidden;\r\n    }\r\n在main.js导入\r\n\r\n    import \'./assets/iconfont/iconfont.js\'\r\n    import \'./assets/iconfont/icon.css\'\r\n这样就可以使用了!然后使用官方的方式引入svg图标\r\n\r\n\r\n    <svg class=\"icon\" aria-hidden=\"true\">\r\n      <use xlink:href=\"#icon-xxx\"></use>\r\n    </svg>\r\n\r\nxlink:href后的用户名在lconfont官网可以看到->右键icon复制代码即可\r\n效果如下\r\n![](https://upload-images.jianshu.io/upload_images/5570465-df2f574bf93244f3.png?imageMogr2/auto-orient/strip|imageView2/2/w/636/format/webp)\r\n\r\n原文连接：https://www.jianshu.com/p/97949900fc36', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 37, 1, '2020-10-21 13:54:36', '2020-11-15 17:34:45', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (35, 10000, 'Promise的三种状态', 'Promise的三种状态', 'Promise的三种状态', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 53, 1, '2020-10-21 18:46:45', '2020-11-15 20:20:22', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (36, 10005, '老毛回忆录', '老毛，永远的神！', '作为舔舔主义的创始人兼国际舔狗联盟总会长的毛志华。经举报，于2020年10月22日，决定对毛志华开除舔狗籍，没收个人资产。2020年12月15日由于老毛同志在我们的舔狗群众四处发放色情信息，经群众举报，再次对老毛的行为。', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 217, 1, '2020-10-21 20:26:38', '2020-12-16 15:34:07', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (37, 10001, '你好啊，我是橘子', '欢迎使用！', '\r\n<pre><code class=\"lang-\">one two three </code></pre>', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 133, 1, '2020-10-22 10:52:33', '2020-10-22 10:52:33', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (38, 10000, '明天是1024程序员日', '程序员日，祝程序员们节日快乐！', '节日快乐 :smiley: :smiley:\n节日快乐节日快乐 :smiley: :smile:\n节日快乐节日快乐节日快乐 :smile: :smile:\n节日快乐节日快乐节日快乐节日快乐节日快乐', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 49, 1, '2020-10-23 18:35:01', '2021-3-22 11:25:17', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (39, 10000, 'Cli4把Vue项目提交到Github', 'git&emsp;add&emsp;.<br>git&emsp;commit&emsp;-m&emsp;\'修改\'<br>git&emsp;push', '```\ngit add .\ngit commit -m \'修改\'\ngit push\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 51, 1, '2020-10-26 14:44:28', '2020-12-18 21:30:27', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (41, 10000, 'Unexpected token / in JSON at position 89345 while parsing near \'...ansform\": \"^4.6.0\",', 'mavon-editor&emsp;markdown&emsp;编辑器安装报错', '错误信息：\n\n    npm ERR! Unexpected token / in JSON at position 89345 while parsing near \'...ansform\": \"^4.6.0\",\n    npm ERR! //        \"mini-css-...\'\n    \n    npm ERR! A complete log of this run can be found in:\n    npm ERR!     C:\\Users\\60231\\AppData\\Roaming\\npm-cache\\_logs\\2020-11-23T10_25_05_799Z-debug.log\n    \n    D:\\Intellij IDEA\\IntelliJ Project\\jellyvue\\jellyvue>npm i mavon-editor\n    npm ERR! Unexpected token / in JSON at position 89345 while parsing near \'...ansform\": \"^4.6.0\",\n    npm ERR! //        \"mini-css-...\'\n    \n    npm ERR! A complete log of this run can be found in:\n    npm ERR!     C:\\Users\\60231\\AppData\\Roaming\\npm-cache\\_logs\\2020-11-23T10_29_10_173Z-debug.log\n    \n	\n你自己先看看是不是mini-css-extract-plugin报出来的错误，如果是的话，继续往下看\n\n解决方法：重新安装mini-css-extract-plugin\n\n    npm install mini-css-extract-plugin -D\n	\n再安装mavon-editor\n\n    npm i mavon-editor\n	\n问题解决', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 24, 1, '2020-10-26 15:30:44', '2020-12-4 23:29:37', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (42, 10000, 'npm run build: WARNING in asset size limit: The following asset(s) exceed the recommended size limit', 'CLI3中npm&emsp;run&emsp;build错误:&emsp;WARNING&emsp;in&emsp;asset&emsp;size&emsp;limit:&emsp;The&emsp;following&emsp;asset(s)&emsp;exceed&emsp;the&emsp;recommended&emsp;size&emsp;limit', 'vue项目 npm run build 时，有时会报如下错误：\n\n![](https://img-blog.csdnimg.cn/20190220195501481.png)\n\n错误原因，资源(asset)和入口起点超过指定文件限制，需要在 vue.config.js 文件内做如下配置：\n```\nmodule.exports = {\n    //webpack配置\n	configureWebpack: {\n	    //关闭 webpack 的性能提示\n	    performance: {\n		    hints:false\n	    }\n \n	    //或者\n \n	    //警告 webpack 的性能提示\n	    performance: {\n	    	hints:\'warning\',\n	    	//入口起点的最大体积\n	    	maxEntrypointSize: 50000000,\n	    	//生成文件的最大体积\n	    	maxAssetSize: 30000000,\n	    	//只给出 js 文件的性能提示\n	    	assetFilter: function(assetFilename) {\n	    		return assetFilename.endsWith(\'.js\');\n	    	}\n	    }\n    }\n}\n```\n详细配置可见 webpack 官网：https://www.webpackjs.com/configuration/performance/\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 14, 1, '2020-10-28 15:00:45', '2020-12-9 19:45:08', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (43, 10000, '我不想上学了', '我不想上学了，因为我太冷太困了，学校里也没有人喜欢我。', '我不想上学了，因为我太冷太困了，学校里也没有人喜欢我。', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 14, 1, '2020-10-28 15:02:01', '2020-12-5 10:05:43', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (44, 10000, '外面的人好吵', '不要在图书馆外面嬉戏打闹了，声音那么大声影响大家学习。', '不要在图书馆外面嬉戏打闹了，声音那么大声影响大家学习。  \n文明一点，操场不能玩吗，你们打闹的地方周围都是教学楼和图书馆？', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 28, 1, '2020-10-29 21:12:30', '2020-12-13 21:26:50', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (45, 10005, '2020.10.29 JAVA日记', 'JAVA经典算法', '今天写了一道二分查找类的题：目标值在有序二位数（从左到右依次增大，下列的头位大于上列的末尾）组中的位置。\r\n\r\n    class Solution {\r\n      public boolean searchMatrix(int[][] matrix, int target) {\r\n        int m = matrix.length;\r\n        if (m == 0) return false;\r\n        int n = matrix[0].length;\r\n        // 二分查找\r\n        int left = 0, right = m * n - 1;\r\n        int pivotIdx, pivotElement;\r\n        while (left <= right) {\r\n          pivotIdx = (left + right) / 2;\r\n          pivotElement = matrix[pivotIdx / n][pivotIdx % n];\r\n          if (target == pivotElement) return true;\r\n          else {\r\n            if (target < pivotElement) right = pivotIdx - 1;\r\n            else left = pivotIdx + 1;\r\n          }\r\n        }\r\n        return false;\r\n      }\r\n    }\r\n其中pivotidx代表的就是中值  用来跟target值比较，而pivotelement就指的是，然后循环遍历就可以得到结果。\r\n时间复杂度：O(log(mn))；\r\n空间复杂度：O(1)；', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 70, 1, '2020-10-29 21:24:52', '2020-10-29 21:24:52', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (47, 10000, 'SpringBoot项目打包发布到个人服务器上', '说明：我项目使用的是JDK1.8+springboot内置tomcat，腾讯云服务器为window系列。已经尝试过打包成功且部署到服务器上。<br><br>如果你的版本和我的不一样，那么不能保证一定成功。', '说明：我项目使用的是JDK1.8+springboot内置tomcat，腾讯云服务器为window系列。已经尝试过打包成功且部署到服务器上。  \n如果你的版本和我的不一样，那么不能保证一定成功。  \n打包前注意：  \n```\n（1）第一步，首先保证你的项目本机上是可以跑起来运行的。\n\n（2）关于项目中关联的一些数据库，和绝对路径的配置，确保在服务器中能够连接得上以及路径能够访问。\n\n（3）服务器中的tomcat要求9.0版本，别的版本会报错，原因我会在下面讲。\n\n（4）项目开发时JDK用什么版本服务器就用什么版本。\n\n    确保以上4点，是我们部署成功的关键。\n```\n开始步骤：\n\n1、在pom.xml中如果要打war包，必须加上该行代码。\n\n```\n<packaging>war</packaging>\n```\n如下图所示：\n![img](https://img-blog.csdnimg.cn/20190214221240850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTY4MTcz,size_16,color_FFFFFF,t_70)\n2、pom.xml中继续加入以下代码：该代码用于spring boot中内嵌的tomcat包依赖排除，不然会产生冲突。  \n```\n<exclusions>\n   <exclusion>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-tomcat</artifactId>\n   </exclusion>\n</exclusions>\n```\n具体位置如下图：\n![img](https://img-blog.csdnimg.cn/201902142222564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTY4MTcz,size_16,color_FFFFFF,t_70)\n3、pom.xml中继续加入以下依赖：该代码用于开发时使用spring boot内嵌tomcat进行调试，生产时使用外部tomcat\n\nscope里的provided意思是只用于开发及测试阶段。\n```\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-tomcat</artifactId>\n    <scope>provided</scope>\n</dependency>\n```\n具体位置如下图：\n\n![img](https://img-blog.csdnimg.cn/2019021422313254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTY4MTcz,size_16,color_FFFFFF,t_70)\n4、找到项目中的application 然后让该类继承SpringBootServletInitializer，然后重写configure方法  \n```\n@Override\n protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {\n    return application.sources(你项目的apprication类名.class);\n}\n```\n如下图所示：\n\n![img](https://img-blog.csdnimg.cn/20190214223518684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTY4MTcz,size_16,color_FFFFFF,t_70)\n\n到这里，目前项目中需要打包配置的步骤已经完成，接下来进行打包\n\n1、点击idea右边的maven-》你的项目名-》Lifecycle-》双击package\n\n![img](https://img-blog.csdnimg.cn/20190214224317856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTY4MTcz,size_16,color_FFFFFF,t_70)\n点击运行控制台会打印打包的过程信息，主要看最后是不是显示成功。如果成功，说明前面步骤没问题。\n\n如果失败了，那么请再次检查上面的步骤以及注意的事项。\n\n![img](https://img-blog.csdnimg.cn/20190214224656650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTY4MTcz,size_16,color_FFFFFF,t_70)\n2、如下图打开target，打好的包就在该目录下，名称为项目名-0.0.1-SNAPSHOT.war，首先把名字改一下，改成ROOT.war，\n\n改名字为ROOT主要是不用打项目名，在服务器上测试直接可以localhost加端口号加你的项目登录路径就能打开系统页面。\n\n我们祭出ctrl+c，ctrl+v大法把该war包放到桌面，再移动到腾讯云服务器的tomcat中去。\n\n![img](https://img-blog.csdnimg.cn/20190214225055890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0MTY4MTcz,size_16,color_FFFFFF,t_70)\n包已经打好，那么我们接下来到服务器的tomcat中操作\n\n  首先一定要确保tomcat可以正常启动\n\n1、将war包移动到腾讯云服务器tomcat目录下的webapps中，不需要解压，不需要任何操作。  \n\n如果webapps目录中有ROOT文件夹，删除即可。\n\n2、启动tomcat\n\n现在解释为什么一定要tomcat9.0版本，因为我们的war包中默认打的tomcat的lib包为9.0版本\n\n如果我们尝试放在tomcat别的版本上，启动tomcat控制台就会报各种异常。\n\n如图所示：\n\n![img](https://img-blog.csdnimg.cn/20190214230728519.png)\n\n按道理是可以改版本的，但是由于太懒，所以没去找解决方案。。。\n\n最后跑完看一下控制台，看看是否有报错，然后在服务器的本地上进行测试吧。\n\n如果改名字为ROOT.war，在服务器上测试直接可以localhost+端口号+你的项目登录路径就能打开系统页面。\n\n如：localhost:8080/sys/login\n\n如果没改名字，还是原来项目名.war，在服务器上测试直接可以localhost+端口号+你的项目名+登录路径就能打开系统页面。\n\n如：localhost:8080/项目名/sys/login\n\n \n\n如果你们服务器上测试也没问题了，那么就要公网测试了，这个就不多说了，服务器能跑起来公网的问题其实注意两点就行\n\n1、腾讯云注意安全组开放端口，这里建议开放80端口的那个选项，然后把该服务器添加到安全组中，之后把tomcat的端口改成80。\n\n2、安全组开放了之后有可能还不能公网访问，那么就是防火墙的问题了，把防火墙关闭即可。\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 49, 1, '2020-11-5 11:00:36', '2021-1-6 22:41:53', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (48, 10000, 'Vue中v-bind:href的使用', 'Vue中v-bind:href的使用', '```\n<a:href=\"\'http://112.124.21.222/dist/#/article/\'+blogID\">链接名称</a>\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 14, 1, '2020-11-5 14:40:33', '2020-12-13 21:28:45', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (49, 10000, 'Vue怎么使用Props中的数据', 'Vue使用Props中的数据', 'props是父组件发给子组件的数据，我们该怎么在子组件中使用他呢\n```\nprops: [\'blog\'],    //子组件接收从父组件传来的数据\n```\n\n1.在HTML代码中使用\n\n```\n<a class=\"blog-button delete\" @click=\"deleteBlog(blog.blogID)\">删除文章</a>\n```\n\n2.在script标签中使用\n\n```\nconsole.log(\"13123:\"+this.blog.userID)\n```\n\n> 总结：把props中的数据当成data中的数据来使用就可以了\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 9, 1, '2020-11-5 20:19:16', '2020-12-18 15:56:54', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (50, 10000, 'push is not a function', '今天在使用push往数组里添加数据的时候发生了这样的错误：&emsp;push&emsp;is&emsp;not&emsp;a&emsp;function', '今天在使用push往数组里添加数据的时候发生了这样的错误： push is not a function\n\n原因是因为我定义的不是数组而是字符串，改成数组形式就行了\n\n错误的方式：\n\n```\nuserList: \'\'\n```\n\n正确的方式：\n\n```\nuserList: []\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 13, 1, '2020-11-8 17:55:54', '2020-12-18 17:02:08', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (51, 10000, 'Avoid mutating a prop directly since the value will be overwritten whenever', '子组件直接修改父组件传过来的props时引起的错误<br>无法直接修改props中数据的值', '子组件直接修改父组件传过来的props时引起的错误  \n无法直接修改props中数据的值  \n> 解决方法：使用计算属性computed\n```\n    props: [\'subStatus\'],\n    computed:{\n      subStatusReal(){\n        return this.subStatus\n      }\n    },\n```\n然后就可以直接使用subStatusReal来代替props中的subStatus了\n\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 5, 1, '2020-11-8 17:56:00', '2020-12-18 19:11:17', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (52, 10000, 'Vue项目判断用户是否登录', '1.从VueX中获取<br>2.从localStorage中获取', '1.从VueX中获取\n```\nJSON.stringify(this.$store.state.user) !== \'{}\'\n```\n2.从localStorage中获取\n```\nlocalStorage.getItem(\'user\') !== null\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 16, 1, '2020-11-8 17:56:17', '2020-12-19 14:45:09', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (53, 10000, '理解和使用Promise.all和Promise.race', 'Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。', '### 一、Pomise.all的使用  \nPromise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。\n\n具体代码如下：\n```\nlet p1 = new Promise((resolve, reject) => {\n  resolve(\'成功了\')\n})\n\nlet p2 = new Promise((resolve, reject) => {\n  resolve(\'success\')\n})\n\nlet p3 = Promse.reject(\'失败\')\n\nPromise.all([p1, p2]).then((result) => {\n  console.log(result)               //[\'成功了\', \'success\']\n}).catch((error) => {\n  console.log(error)\n})\n\nPromise.all([p1,p3,p2]).then((result) => {\n  console.log(result)\n}).catch((error) => {\n  console.log(error)      // 失败了，打出 \'失败\'\n})\n```\nPromse.all在处理多个异步处理时非常有用，比如说一个页面上需要等两个或多个ajax的数据回来以后才正常显示，在此之前只显示loading图标。\n\n代码模拟：\n```\nlet wake = (time) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(`${time / 1000}秒后醒来`)\n    }, time)\n  })\n}\n\nlet p1 = wake(3000)\nlet p2 = wake(2000)\n\nPromise.all([p1, p2]).then((result) => {\n  console.log(result)       // [ \'3秒后醒来\', \'2秒后醒来\' ]\n}).catch((error) => {\n  console.log(error)\n})\n```\n**需要特别注意的是，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，即p1的结果在前，即便p1的结果获取的比p2要晚。这带来了一个绝大的好处：在前端开发请求数据的过程中，偶尔会遇到发送多个请求并根据请求顺序获取和使用数据的场景，使用Promise.all毫无疑问可以解决这个问题。**\n\n### 二、Promise.race的使用\n顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。\n```\nlet p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve(\'success\')\n  },1000)\n})\n\nlet p2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    reject(\'failed\')\n  }, 500)\n})\n\nPromise.race([p1, p2]).then((result) => {\n  console.log(result)\n}).catch((error) => {\n  console.log(error)  // 打开的是 \'failed\'\n})\n```\n原理是挺简单的，但是在实际运用中还没有想到什么的使用场景会使用到。\n\n原文链接：https://www.jianshu.com/p/7e60fc1be1b2\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 14, 1, '2020-11-8 17:56:23', '2020-12-19 16:30:19', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (54, 10000, 'mavon-editor换行不显示', '使用mavon-editor编辑的markdown文本在mavon-editor的预览窗口中显示但是在发布后不显示换行。', '使用mavon-editor编辑的markdown文本在mavon-editor的预览窗口中显示但是在发布后不显示换行。\n如果你用的是 [chjj/marked](chjj/marked )，那么不换行的原因是没有开启回车换行功能。\n> 错误的方式\n\n```\nthis.blog.content = marked(res.content)\n```\n> 正确的方式\n```\nthis.blog.content = marked(res.content, {breaks: true});\n```\n这样回车就会正常显示了！', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 18, 1, '2020-11-8 17:56:34', '2020-12-19 17:12:11', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (55, 10000, 'Vue-Router在to中携带参数', 'Vue-Router在to中携带参数', 'Vue-Router在to中携带参数\n1.使用js方式：\n\n```\n{label: \'我的收藏\', to:{path:\'/personal/collect\',params:{currentPage:this.$route.params.currentPage}}},\n```\n\n2.在router-link标签中\n```\n<router-link :to=\"{name:\'article\',params:{blogID:blog.lastBlogID}}\" class=\"last\" id=\"lastArticle\">\n```\n\n> name或者path方式根据需求而定\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 17, 1, '2020-11-8 17:57:02', '2020-12-20 10:28:48', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (56, 10000, '关于Vue中，$this.router.push到当前页面，只是传入参数不同，页面不刷新的问题解决', '关于Vue中，$this.router.push到当前页面，只是传入参数不同，页面不刷新的问题解决.', '在页面的watch中，监听$router的变化\n```\nwatch: {\n    $route (to, from) {\n      this.$router.go(0)\n    }\n  }\n```\n实际应用\n```\nwatch: {\n      // 如果路由发生变化，再次执行该方法\n      \'$route\' (to, from) { //监听路由是否变化\n        if (to.name === from.name){\n          this.reload()\n        }\n      }\n    }\n```\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 23, 1, '2020-11-8 17:57:17', '2020-12-20 11:26:01', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (57, 10000, '解决因为elementUI的el-popup-parent--hidden而引起的滚动条显示问题', 'el-popup-parent--hidden是elementUI的mask遮罩体引起的，在mask被激活时，会多出来以下两个样式导致滚动条被隐藏。', 'el-popup-parent--hidden是elementUI的mask遮罩体引起的，在mask被激活时，会多出来以下两个样式导致滚动条被隐藏。\n\n![image.png](http://112.124.21.222/images/blogImages/20201220160102image.png)\n\n就是这个padding-right： 17px;和overflow：hidden;导致的滚动条消失\n\n**我想达到的效果：**\nelementui的组件正常显示却不影响页面其它组件,即滚动条正常显示，页面也不会移动17px\n\n> 解决方法\n\n在App.vue中添加以下样式\n```\n<style>\n  .el-popup-parent--hidden{\n    padding-left: 0!important;\n    overflow: visible!important;\n  }\n</style>\n```\n这样就可以正常显示了', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 17, 1, '2020-11-8 19:14:28', '2020-12-20 16:07:20', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (58, 10000, 'elementUI的Pagination分页和Popconfirm气泡确认框搭配使用出现的bug', 'elementUI的Pagination分页和Popconfirm气泡确认框搭配使用出现的bug，在第一页Popconfirm气泡确认框在点击按钮后正常显示，但是在第二页时却怎么点也没有效果了。', 'elementUI的Pagination分页和Popconfirm气泡确认框搭配使用出现的bug，在第一页Popconfirm气泡确认框在点击按钮后正常显示，但是在第二页时却怎么点也没有效果了。\n\n> 原因\n\n在使用v-for时忘记添加 :key 了导致文档不会重新渲染。\n错误的写法：\n```\n<div class=\"comment-box\" v-for=\"(items) in comments\">\n```\n\n\n正确的写法，添加上:key\n```\n<div class=\"comment-box\" v-for=\"(items) in comments\" :key=\"items.commentID\">\n```\nVue官方文档有这么一句话也可以解释这个错误：\n> v-for 的默认行为会尝试原地修改元素而不是移动它们。要强制其重新排序元素，你需要用特殊 attribute key 来提供一个排序提示：\n```HTML\n<div v-for=\"item in items\" :key=\"item.id\">\n  {{ item.text }}\n</div>\n```\n这就解释了为什么不会重新渲染的原因了，使用key就行了。\n\n问题解决\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 14, 1, '2020-11-8 19:14:59', '2021-3-22 16:37:24', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (59, 10000, 'Vue项目部署到Nginx服务器并访问部署在tomcat的后端', 'Vue项目部署到Nginx服务器并访问部署在tomcat的后端', '网站的前端部分使用Vue开发并将其部署在nginx服务器上，使用的时8000端口，后端部分部署在tomcat上，使用的是80端口（目前正在测试阶段所以这样部署）。\n\n在Vue项目中打包\n```\nnpm run build\n```\n\n将打包好的dist文件夹发送到服务器上，安装nginx的过程就不说了，这边给出nginx在windows系统下有三个常用的命令。\n```\n启动命令 start nginx\n强制停止命令 nginx.exe -s stop\n重启命令 nginx.exe -s reload\n```\n运行cmd,去到nginx根目录,执行启动命令。\n\n将打包好的dist文件夹放在服务器的C盘下如：C:\\dist  (不是固定的，放在你想要的位置就行了)\n\n打开nginx文件夹下的conf文件夹下的nginx.conf文件，添加如下配置\n\n\n```\n#user  nobody;\nworker_processes  1;\n\n#pid        logsinx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\nhttp {\n    include       mime.types;\n    default_type  application/octet-stream;\n\n    #log_format  main  \'$remote_addr - $remote_user [$time_local] \"$request\" \'\n    #                  \'$status $body_bytes_sent \"$http_referer\" \'\n    #                  \'\"$http_user_agent\" \"$http_x_forwarded_for\"\';\n\n    #access_log  logs/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    #keepalive_timeout  0;\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n        listen       8000;   #修改1：端口\n        server_name  111.111.111.111;  #修改2：访问路径，部署后使用 http://111.111.111.111:8000访问\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            root   C:\\dist;  #vue项目路径\n            index  index.html index.htm;\n        }\n\n    location /api {\n            proxy_pass http://111.111.111.111/api;  #修改3：后端跨域请求的地址\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection ‘upgrade’;\n            proxy_set_header Host $host;\n            proxy_cache_bypass $http_upgrade;\n    }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n}\n```\n**记得开启服务器的8000端口的安全组配置**\n\n保存nginx.conf，重启nginx，打开本地浏览器，访问http:\\\\\\111.111.111.111:8000\n\n\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 24, 1, '2020-11-8 19:19:25', '2020-12-23 20:31:45', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (60, 10000, 'axios模板', 'axios模板', '```\nthumbUpCom(commentID) {\n        request({\n          url: \'/article/incComThumb\',\n          params: {\n            commentID: commentID,\n          },\n        }).then((res) => {\n          if (res === 1) {\n            this.comThumbUpDis = true\n          }\n        }).catch((err) => {\n          console.log(err);\n        })\n      }\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 25, 1, '2020-11-8 19:23:35', '2020-12-24 15:24:59', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (61, 10000, '父组件传给子组件的props动态更新', '父组件传给子组件的props动态更新，数据在父组件中修改而在子组件中使用，实现动态更新。', '父组件中\n```\n<editor\n    :submit-disable=\"submitDisable\"\n    :blog-data=\"blogData\"\n    :submitButton=\"submitText\"\n    @blogSubmit=\"blogSubmit\"\n  >\n  </editor>\n\ndata(){\n  return(){\n    submitDisable: false,\n  }\n}\n\nblogSubmitRequest(){\n  this.submitDisable = true\n  if(成功的条件){\n    this.submitDisable = false\n  }\n}\n```\n子组件中：\n```\nprops: [\'submitDisable\'],\n```\n这样就可以了\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 10, 1, '2020-11-8 19:27:52', '2020-12-26 15:57:41', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (62, 10000, '旧版侧栏固定', '旧版侧栏固定', '### 首页固定\n```      \nbarFixed() {\n        let fixedBarHome = $(\'#fixedBarHome\');\n        onscroll = function () {\n          // console.log(document.documentElement.scrollTop)\n          let s = document.documentElement.scrollTop || document.body.scrollTop;\n          if (s < fixedBarHome.height() - window.screen.availHeight + 170) {\n            fixedBarHome.css(\"position\", \"relative\").css(\"bottom\", \"0\");\n          } else if (s > document.body.scrollHeight - window.screen.availHeight - 85) {\n            let bottom = s - (document.body.scrollHeight - window.screen.availHeight - 85)\n            fixedBarHome.css(\"position\", \"fixed\").css(\"bottom\", bottom + \"px\");\n          } else {\n            fixedBarHome.css(\"position\", \"fixed\").css(\"bottom\", \"5px\");\n          }\n        }\n      },\n```\n### 个人主页固定\n```\nleftBarFixed() {\n        let fixedBarArticle = $(\'#fixedBarArticle\');\n        onscroll = function () {\n\n          let s = document.documentElement.scrollTop || document.body.scrollTop;\n          if (s < fixedBarArticle.height() - window.screen.availHeight + 170) {\n            fixedBarArticle.css(\"position\", \"relative\").css(\"bottom\", \"0\");\n          } else if (s > document.body.scrollHeight - window.screen.availHeight - 85) {\n            let bottom = s - (document.body.scrollHeight - window.screen.availHeight - 85)\n            fixedBarArticle.css(\"position\", \"fixed\").css(\"bottom\", bottom + \"px\");\n          } else {\n            fixedBarArticle.css(\"position\", \"fixed\").css(\"bottom\", \"5px\");\n          }\n\n        }\n      },\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 16, 1, '2020-11-8 19:36:09', '2020-12-26 23:01:44', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (63, 10000, 'IDEA导入Maven项目后pom.xml报错', '今天在导入Maven项目时pom.xml报错', '今天在导入Maven项目时pom.xml报错\n有点不明白，记录一下错误，到时候解决。\n解决方法：\n\n修改一下SpingBoot的版本，比如我原来是2.3.0版本的，改成2.3.1版本的，然后点击reimport就可以下载依赖了。', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 8, 1, '2020-11-8 19:39:23', '2021-1-5 10:29:38', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (64, 10000, 'vue.nextTick()方法的使用详解（简单明了）', '什么是Vue.nextTick()？？<br>&emsp;<br><br>定义：在下次&emsp;DOM&emsp;更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的&emsp;DOM。<br><br>所以就衍生出了这个获取更新后的DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的&emsp;js代码；<br><br>理解：nextTick()，是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数，<br><br>', '### 什么是Vue.nextTick()？？\n \n\n定义：在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\n\n所以就衍生出了这个获取更新后的DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码；\n\n理解：nextTick()，是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：当数据更新了，在dom中渲染后，自动执行该函数，\n\n```\n<template>\n  <div class=\"hello\">\n    <div>\n      <button id=\"firstBtn\" @click=\"testClick()\" ref=\"aa\">{{testMsg}}</button>\n    </div>\n  </div>\n</template>\n \n<script>\nexport default {\n  name: \'HelloWorld\',\n  data () {\n    return {\n      testMsg:\"原始值\",\n    }\n  },\n  methods:{\n    testClick:function(){\n      let that=this;\n      that.testMsg=\"修改后的值\";\n      console.log(that.$refs.aa.innerText);   //that.$refs.aa获取指定DOM，输出：原始值\n    }\n  }\n}\n</script>\n```\n使用this.$nextTick()\n```\n  methods:{\n    testClick:function(){\n      let that=this;\n      that.testMsg=\"修改后的值\";\n      that.$nextTick(function(){\n        console.log(that.$refs.aa.innerText);  //输出：修改后的值\n      });\n    }\n  }\n```\n注意：Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。$nextTick 是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 $nextTick，则可以在回调中获取更新后的 DOM。\n\n### 什么时候需要用的Vue.nextTick()？？\n \n\n1、Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载已完成。\n```\n  created(){\n    let that=this;\n    that.$nextTick(function(){  //不使用this.$nextTick()方法会报错\n        that.$refs.aa.innerHTML=\"created中更改了按钮内容\";  //写入到DOM元素\n    });\n  },\n```\n2、当项目中你想在改变DOM元素的数据后基于新的dom做点什么，对新DOM一系列的js操作都需要放进Vue.nextTick()的回调函数中；通俗的理解是：更改数据后当你想立即使用js操作新的视图的时候需要使用它\n\n<template>\n  <div class=\"hello\">\n    <h3 id=\"h\">{{testMsg}}</h3>\n  </div>\n</template>\n \n<script>\nexport default {\n  name: \'HelloWorld\',\n  data () {\n    return {\n      testMsg:\"原始值\",\n    }\n  },\n  methods:{\n    changeTxt:function(){\n      let that=this;\n      that.testMsg=\"修改后的文本值\";  //vue数据改变，改变dom结构\n      let domTxt=document.getElementById(\'h\').innerText;  //后续js对dom的操作\n      console.log(domTxt);  //输出可以看到vue数据修改后DOM并没有立即更新，后续的dom都不是最新的\n      if(domTxt===\"原始值\"){\n        console.log(\"文本data被修改后dom内容没立即更新\");\n      }else {\n        console.log(\"文本data被修改后dom内容被马上更新了\");\n      }\n    },\n \n  }\n}\n</script>\n \n正确的用法是：vue改变dom元素结构后使用vue.$nextTick()方法来实现dom数据更新后延迟执行后续代码\n\n    changeTxt:function(){\n      let that=this;\n      that.testMsg=\"修改后的文本值\";  //修改dom结构\n       \n      that.$nextTick(function(){  //使用vue.$nextTick()方法可以dom数据更新后延迟执行\n        let domTxt=document.getElementById(\'h\').innerText; \n        console.log(domTxt);  //输出可以看到vue数据修改后并没有DOM没有立即更新，\n        if(domTxt===\"原始值\"){\n          console.log(\"文本data被修改后dom内容没立即更新\");\n        }else {\n          console.log(\"文本data被修改后dom内容被马上更新了\");\n        }\n      });\n    },\n \n\n3、在使用某个第三方插件时 ，希望在vue生成的某些dom动态发生变化时重新应用该插件，也会用到该方法，这时候就需要在 $nextTick 的回调函数中执行重新应用插件的方法。\n\n\n \n### Vue.nextTick(callback) 使用原理：\n原因是，Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。\n当你设置 vm.someData = \'new value\'，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。\n\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 22, 1, '2020-11-8 19:46:32', '2021-1-8 23:04:23', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (65, 10000, '$refs和$children和$parent和$root', '父访问子：$refs和$children<br>子访问父：$parent和$root', '当父组件想调用子组件的方法或者属性，我们可以使用children和refs方法，\n\n**children方法**\n\n①children得到的是一个所有组件的集合，保存到一个数组当中，所以子组件不固定数目的时候，使用children是不方便的,children使用的几率比较小\n\n②chlidren是在methods方法中使用的，this.$children返回一个数组,\n\n**refs方法**\n\n①refs是根据组件名字来取的响应组件的属性，所以必须在组件上使用ref=“name”定义一个名字，才可以在methods方法中使用this.$refs.name\n\n②refs适合拿具体某一个组件的方法和属性，他是根据名字拿的，所以无论添加多少个组件，对其没有影响\n\n> 注意\n\n 1、在methods中children和refs使用时前面都是要加$\n\n 2、 ref可以在绑定在组件上，可以拿到子组件的属性和方法，ref也可以绑定在普通html元素，通过this.$refs.name也可以拿到该元素。\n\n\n补充：https://www.jianshu.com/p/623c8b009a85\n\n这里再补充一点就是，prop和$ref之间的区别：\nprop 着重于数据的传递，它并不能调用子组件里的属性和方法。像创建文章组件时，自定义标题和内容这样的使用场景，最适合使用prop。\n$ref 着重于索引，主要用来调用子组件里的属性和方法，其实并不擅长数据传递。而且ref用在dom元素的时候，能使到选择器的作用，这个功能比作为索引更常有用到。\nhttps://www.jb51.net/article/140581.htm', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 27, 1, '2020-11-8 19:50:08', '2021-3-19 21:03:03', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (66, 10000, 'JS中toString()和String()的区别', 'JS中toString()和String()的区别', '![image.png](http://112.124.21.222/images/blogImages/20210125163925image.png)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 29, 1, '2020-11-8 19:52:24', '2021-1-25 16:41:26', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (67, 10000, 'JS中其它数据类型转换为Boolean', 'JS中其它数据类型转换为Boolean', '![image.png](http://112.124.21.222/images/blogImages/20210127112453image.png)66', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 6, 1, '2020-11-8 19:56:35', '2021-1-27 11:25:30', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (68, 10000, 'JS中基本数据类型和引用数据类型', 'JS中基本数据类型和引用数据类型', '#### JS中的两种数据类型\n![image.png](http://112.124.21.222/images/blogImages/20210128115743image.png)\n#### 基本数据类型存储方式：栈存储\n![image.png](http://112.124.21.222/images/blogImages/20210128120049image.png)\n#### 引用数据类型存储方式：堆存储\n![image.png](http://112.124.21.222/images/blogImages/20210128115917image.png)\n#### 将对象赋值为null的地址变化\n![image.png](http://112.124.21.222/images/blogImages/20210128120444image.png)\n\n扩展：分析下列代码在内存中的存储方式\n```\n   var obj3 = new Object();\n   var obj4 = new Object();\n   console.log(obj3 == obj4); //输出false\n```\n如下图所示\n![image.png](http://112.124.21.222/images/blogImages/20210128120855image.png)\n\n#### 结论：“值”的比较\n\n> 当比较两个基本数据类型的值时，就是比较值。\n而比较两个引用数据类型时，它是比较的对象的内存地址，\n如果两个对象是一模一样的,但是地址不同，它也会返回false', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 11, 1, '2020-11-8 20:00:01', '2021-1-28 12:11:28', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (69, 10000, 'JS中的立即执行函数', 'JS中的立即执行函数', 'JS声明函数的几种方法：[JS声明函数的几种方法](https://segmentfault.com/a/1190000012200022)\n一般我们在JS中声明函数使用的是**函数式声明**或者**函数表达式**。\n> 在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。\n\n这里以函数表达式为例：\n\n```\nvar fun = new function(a, b){\n  console.log(\"a = \"+a );\n  console.log(\"b = \"+b );\n}\n//这个函数中fun是一个变量，称为函数变量，用于接收等号后面定义的函数体\n```\n而函数是怎么调用的呢？\n函数调用：函数对象(), 即fun();\n\n再看一个概念：匿名函数\n匿名函数：没有函数名，只有函数体（函数对象）,可以有函数名，只不过没有使用变量去接收它。（顺便一提：匿名函数也是闭包的原理）\n```js\nfunction(a, b){\n  console.log(\"a = \"+a );\n  console.log(\"b = \"+b );\n}\n```\n\n立即执行函数\n```js\n(function (a, b) {\n    console.log(\"a = \" + a);\n    console.log(\"b = \" + b);\n})(123, 456)\n```\n另一种写法\n```js\n(function (a, b) {\n    console.log(\"a = \" + a);\n    console.log(\"b = \" + b);\n}(123, 456))\n```\n立即执行函数执行的是匿名函数，而匿名函数虽然没有函数名，却有函数体（函数对象），所以用（）包裹住函数体使它成为一个整体，然后再在后面添加括号来执行这个函数。这就是立即执行函数。适用于只需要执行一次的函数。\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 57, 1, '2020-11-8 20:00:41', '2022-4-1 17:15:53', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (70, 10000, 'JS之函数作用域与全局作用域', 'JS之函数作用域与全局作用域', '#### 全局作用域\n\n```\n直接编写在script标签中的JS代码，都在全局作用域\n全局作用域在页面打开时创建，在页面关闭时销毁\n在全局作用域中有一个全局对象window,\n   它代表的是一个浏览器的窗口，它由浏览器创建我们可以直接使用-在全局作用域中:\n   创建的变量都会作为window对象的属性保存创建的函数都会作为window对象的方法保存\n全局作用域中的变量都是全局变量，\n   在页面的任意的部分都可以访问的到\n```\n\n\n#### 函数作用域\n```\n调用函数时创建函数作用域，函数执行完毕以后，函数作用域销毁\n每调用一次函数就会创建一个新的函数作用域，他们之间是互相独立的\n在函数作用域中可以访问到全局作用域的变量\n    在全局作用域中无法访问到函数作用域的变量\n当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用\n    如果没有则向上一级作用域中寻找，直到找到全局作用域，\n    如果全局作用域中依然没有找到，则会报错ReferenceError\n在函数中要访问全局变量可以使用window对象\n```\n\n```\n在函数作用域也有声明提前的特性，\n使用var关键字声明的变量，会在函数中所有的代码执行之前被声明函数声明也会在函数中所有的代码执行之前执行\n\n在函数中,不使用var声明的变量都会成为全局变量\n\n定义形参就相当于在函数作用域中声明了变量\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 7, 1, '2020-11-8 20:03:04', '2021-1-31 11:49:57', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (71, 10000, 'JS的this指向', 'JS的this指向', '```\n解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是this, this指向的是一个对象，这个对象我们称为函数执行的上下文对象，\n根据函数的调用方式的不同，this会指向不同的对象\n  1.以函数的形式调用时, this永远都是window\n  2.以方法的形式调用时，this就是调用方法的那个对象 \n  3.以call()、apply()、bind()调用时，this是call()、apply()、bind()指定的对象\n  4.以构造函数(new)调用时，this就是新创建的那个对象。\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 31, 1, '2020-11-8 20:19:21', '2021-4-23 11:40:30', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (72, 10000, 'JavaScript原型prototype，工厂函数与构造函数的区别', '关于JavaScript原型prototype', '#### 原型（prototype）\n\n我们所创建的每一个**函数**，解析器都会向函数中添加一个属性`prototype`\n这个属性对应着一个对象，这个对象就是我们所谓的原型对象\n\n如果函数作为普通函数调用`prototype`没有任何作用\n当函数以构造函数的形式调用时，它所创建的对象中都会有一个隐含的属性，\n指向该构造函数的原型对象，我们可以通过`__proto__`来访问该属性\n\n原型对象就相当于一个公共的区域，所有同一个类的实例都可以访问到这个原型对象，\n我们可以将对象中共有的内容，统一设置到原型对象中。\n当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。\n\n以后我们创建构造函数时，可以将这些对象共有的属性和方法，统一添加到构造函数的原型对象中，\n这样不用分别为每一个对象添加，也不会影响到全局作用域，就可以使每个对象都具有这些属性和方法了\n\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/11/20210311201634image.png)\n\n也就是说，函数不以普通形式调用，而是以构造函数的方法调用，即使用`new`创建一个函数对象。这样所有使用同一个构造函数创建的对象的共享同一个`prototype`，可以把公共的方法和属性放进去，而不是每个都添加一次。\n```JavaScript\n    function MyClass() {\n        let a = 100;\n        // this.a = 100;\n    }\n\n    MyClass.prototype.a = \'原型中的a\'\n\n    let mc1 = new MyClass()\n    let mc2 = new MyClass()\n    let mc3 = new MyClass()\n\n    console.log(mc1.a)  //原型中的a\n    mc1.a = 2\n    console.log(mc1.a)  //2\n    console.log(mc2.a)  //原型中的a\n```\n\n构造函数的执行流程:\n- 1.立刻创建一个新的对象\n- 2.将新建的对象设置为函数中`this`,在构造函数中可以使用`this`来引用新建的对象\n- 3.逐行执行函数中的代码\n- 4.将新建的对象作为返回值返回\n\n\n原型链\n对象可以通过 `.__proto__` 这个方法找到该对象的原型，有一个特殊的对象——函数，函数通过.prototype找到该函数的原型对象，`.prototype`这个方法只有函数才可以调用，而找到的是原型对象，所以不能继续用`.prototype`这个方法。而`.__proto__`这个方法可以重复调用，通过`.__proto__.__proto__` 来找到最顶层的原型对象Object，这条线就称为原型链。\n不管是函数的原型还是实例对象的原型`.__proto__`后都找到Object，也就是{}\n关于原型和原型链：一篇写的不错的文章：https://zhuanlan.zhihu.com/p/27608119\n\n关于`prototype`和`__proto__`:https://www.jianshu.com/p/3d756c5bba16\n其中说到：\n```JavaScript\n//几行代码搞定的事情\nfunction Fn() {\n}\nvar fn = new Fn()\nFn.prototype===fn.__proto__ //true\n```\n不错的文章\njavascript原型对象、构造函数和实例对象：\nhttps://blog.csdn.net/neverland_7/article/details/20775077\n对象工厂函数和构造函数的区别\nhttps://blog.csdn.net/weixin_43799793/article/details/107753339\nhttps://segmentfault.com/a/1190000019054466', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 84, 1, '2020-11-8 20:19:50', '2022-3-31 14:15:29', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (73, 10000, '垃圾回收(GC)', '垃圾回收(GC)', '```\n垃圾回收（GC)\n   -就像人生活的时间长了会产生垃圾一样，程序运行过程中也会产生垃圾\n这些垃圾积攒过多以后，会导致程序运行的速度过慢，\n所以我们需要一个垃圾回收的机制，来处理程序运行过程中产生垃圾\n   -当一个对象没有任何的变量或属性对它进行引用，此时我们将永远无法操作该对象，\n此时这种对象就是一个垃圾，这种对象过多会占用大量的内存空间，导致程序运行变慢，所以这种垃圾必须进行\n清理。\n   -在js中拥有自动的垃圾回收机制，会自动将这些垃圾对象从内存中销毁，\n我们不需要也不能进行垃圾回收的操作\n   -我们需要做的只是要将不再使用的对象设置null即可\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 7, 1, '2020-11-8 20:24:35', '2021-2-1 21:38:06', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (74, 10000, 'ElementUI的Upload组件上传时如何携带参数', 'ElementUI的Upload组件上传时如何携带参数', '```\n<el-upload\n	class=\"avatar-uploader\"\n	action=\"/setmeal/updatePicture.do\"\n	:data={pictureName:this.imageName}\n	:auto-upload=\"autoUpload\"\n	name=\"imgFile\"\n	:show-file-list=\"false\"\n	:on-success=\"handleAvatarSuccess\"\n	:before-upload=\"beforeAvatarUpload\">\n</el-upload>\n```\n\n通过:data={参数} ,参数为键值对的形式{key1:value1,key2:value2},传递参数,如下\n```\n:data={pictureName:this.imageName}\n```\n\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 4, 1, '2020-11-8 20:27:47', '2021-2-3 11:13:54', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (75, 10000, 'JS生成x-y之间的随机数', 'JavaScript生成x-y之间的随机数', '生成一个x-y之间的随机数\n\n```\nMath.round(Math.random()*(y-x)+×)\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 11, 1, '2020-11-8 20:37:39', '2021-2-18 10:28:54', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (76, 10000, 'JS中对象中函数的声明和全局函数声明几种方式之间的区别', 'JS中对象中函数的声明和全局函数声明几种方式之间的区别', 'JS中对象中函数的声明和全局函数声明几种方式之间的区别\n\n```JavaScript\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<script>\n    let person = {\n        //对象的方法定义形式1:简写ES6\n        sayHello1() {\n            console.log(\"hello\")\n        },\n\n        //对象的方法定义形式2:ES5\n        sayHello2: function () {\n            console.log(\"hello\")\n        },\n\n        //报错，没有这种定义方式，这是全局函数的定义方式\n        let sayHello3 = function () {\n            console.log(\"hello\")\n        }\n    }\n\n    // 全局函数定义方式1：函数表达式（等号）\n    let sayHello = function () {\n        console.log(\"outer hello\")\n    }\n\n    // 全局函数定义方式2（函数声明式）\n    function sayHello() {\n        console.log(\"outer hello\")\n    }\n\n    //报错，没有这种定义方式，这是对象中函数的简写\n    sayHello(){\n        console.log(\"outer hello\")\n    }\n</script>\n</body>\n</html>\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 25, 1, '2020-11-8 20:39:18', '2021-3-8 19:58:04', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (77, 10000, 'Vue兄弟节点之间通信的几种方式', 'Vue兄弟节点之间通信的几种方式<br>1.子传父，父传子<br>2.VueX<br>3.eventBus', '### Vue兄弟节点之间通信的几种方式\n1. 子传父，父传子\n2. VueX\n3. eventBus\n\n1.https://www.cnblogs.com/zhilu/p/13851827.html\n3.https://segmentfault.com/a/1190000018520676?utm_source=tag-newest\n\nprops动态更新：https://www.cnblogs.com/_error/p/9701136.html', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 14, 1, '2020-11-8 21:26:31', '2021-3-9 14:43:23', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (78, 10006, '2020.11.9', '封面图片测试', '效果显示如图![](http://112.124.21.222/images/blogImages/1562681586963.jpg)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 8, 1, '2020-11-9 09:42:03', '2020-11-9 09:42:03', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (79, 10000, 'vue的component和extend的区别', 'vue的component和extend的区别', 'https://www.jianshu.com/p/2d2f42248dac', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 15, 1, '2020-11-28 16:16:19', '2021-3-9 16:21:44', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (80, 10000, 'Vue beforeRouteEnter 获取不到组件实例', '&emsp;&emsp;进入页面前获取上个页面的值，并赋值，但打印出来是undefinde。明明在上个页面是有值的，但在内部获取不到外部的this，方法、变量等都获取不到.<br>&emsp;&emsp;后来发页面，beforeRouteEnter&emsp;是页面进入之前调用，所以取不到实例<br><br>', '进入页面前获取上个页面的值，并赋值，但打印出来是 undefinde。明明在上个页面是有值的，但在内部获取不到外部的this，方法、变量等都获取不到\n\n后来发页面，beforeRouteEnter 是页面进入之前调用，所以取不到实例\n### 方法一(推荐)：\nbeforeRouteEnter 和 beforeRouteLeave 通过 vm 访问组件实例\n```JavaScript\nbeforeRouteEnter(to, from, next) {\n  next(vm => {\n    // 通过 `vm` 访问组件实例\n    const currentUserID = vm.$store.state.myDate\n  })\n},\n```\n### 方法二(不推荐，此方法在刷新该页面时容易报错)：\n```JavaScript\nconst store = from.matched[0].instances.default.$store.state.myDate\n```\n\n* * *\n\n### 项目实例\n```JavaScript\nbeforeRouteEnter(to, from, next) {\n      next(vm => {\n        // 通过 `vm` 访问组件实例\n        const currentUserID = vm.$store.state.myDate\n        if (currentUserID === 10000 || currentUserID === 10001) {\n          next()\n        } else {\n          next({\n            path: \'/blog/home\',\n          });\n          Vue.prototype.$message({\n            message: \'暂时没有权限访问该页面\',\n            type: \'warning\'\n          });\n        }\n      })\n      // const currentUserID = from.matched[0].instances.default.$store.state.user.userID\n      // const currentUserID = this.$store.state.user.userID\n    },\n```\n参考链接：https://blog.csdn.net/GrootBaby/article/details/114520537\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 11, 1, '2020-11-28 16:23:22', '2021-3-13 22:23:16', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (81, 10000, '防止修改localStorage', 'localStorage常常被我们用来存储用户数据，比如用户的账户信息，这样下次用户进入网站时，就可以直接使用之前的账号登录，但是localStorage是存储在用户主机上的持久化数据，可以被用户修改，这样就对我们网站的运行造成一些问题。用户可能通过直接修改localStorage来达到一些目的。', '&emsp;&emsp;localStorage常常被我们用来存储用户数据，比如用户的账户信息，这样下次用户进入网站时，就可以直接使用之前的账号登录，但是localStorage是存储在用户主机上的持久化数据，可以被用户修改，这样就对我们网站的运行造成一些问题。用户可能通过直接修改localStorage来达到一些目的。比如修改用户的账号来操作其它用户的数据，这是很危险的，所以我们应该避免这种行为。方法有很多种，以下列出两种简单的方式，**适用于将用户信息存储在localStorage的情况**。\n\n### 方法一：当localStorage值被修改的时候清除他并且跳转到登录页\n```JavaScript\n//Vue项目中，在main.js文件中添加\nwindow.addEventListener(\'storage\', function () {\n  localStorage.clear();\n  window.location.replace(\"/\");\n});\n```\n### 方法二：让localStorage值无法修改\n```JavaScript\n//Vue项目中，在main.js文件中添加\nwindow.addEventListener(\'storage\', function (e) {\n  localStorage.setItem(e.key, e.oldValue)\n});\n```\n### 补充：你还可以请求服务器数据来验证\n> 基本思想是把localStorage的数据上传到服务器验证，如果验证成功即可继续使用网站，否则清除localStorage的数据。这种方式对网络有要求（可以对方法一和方法二做一个二次验证），影响用户体验，只是一个思想，建议使用以上两种方式。\n\n参考链接：https://blog.csdn.net/qq_41812254/article/details/103088811\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 7, 1, '2020-11-28 16:29:50', '2021-3-13 10:08:04', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (82, 10000, 'Tomcat控制台中文乱码解决方法', 'Tomcat控制台中文乱码解决方法', '### Tomcat控制台中文乱码解决方法\n\n**1.控制台日志输出乱码**\n解决办法:\n\n​    1.在本地tomcat / conf 目录下,修改logging.properties配置文件,添加\n\n```\njava.util.logging.ConsoleHandler.encoding = GBK\n```\n\n完整示例:\n\n```\njava.util.logging.ConsoleHandler.level = FINE\njava.util.logging.ConsoleHandler.formatter = org.apache.juli.OneLineFormatter\njava.util.logging.ConsoleHandler.encoding = UTF-8\njava.util.logging.ConsoleHandler.encoding = GBK\n```\n\n​    2.重启tomcat', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 5, 1, '2020-11-28 16:30:25', '2021-3-16 22:34:21', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (85, 10000, '深入浅出Object.defineProperty()', '深入浅出Object.defineProperty()', 'https://www.jianshu.com/p/8fe1382ba135', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 24, 1, '2020-11-28 16:35:12', '2021-3-18 15:09:55', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (87, 10000, 'vue 阻止事件冒泡和取消默认行为', 'vue&emsp;阻止事件冒泡和取消默认行为', 'stop阻止冒泡\n\nprevent取消默认行为，比如超链接不会跳转等。\n\n capture监听事件\n\n使用不同的组合可以形成不同的事件链\n\n```JavaScript\n<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>vue阻止事件冒泡</title>\n    <script src=\"./vue.js\" charset=\"utf-8\"></script>\n</head>\n\n<body>\n<div id=\"app\" @click.capture=\"one\">\n    one\n    <div @click.stop=\"two\">\n        two\n        <div @click.stop=\"three\">\n            three\n        </div>\n    </div>\n\n    <a href=\"http://www.zhihu.com\" @click=\"one\">知乎</a>\n    <br/>\n    <a href=\"http://www.zhihu.com\" @click.prevent=\"one\">知乎</a>\n</div>\n</body>\n\n<script>\n    new Vue({\n        el: \"#app\",\n        methods: {\n            one: function () {\n                alert(\"one\")\n            },\n            two: function () {\n                alert(\"two\")\n            },\n            three: function () {\n                alert(\"three\")\n            }\n        }\n    })\n</script>\n\n</html>\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 35, 1, '2020-11-28 17:59:07', '2021-3-18 17:07:47', 'https://my.oschina.net/ahaoboy/blog/1615619', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (88, 10000, 'Vue中的keep-alive中的include和exclude用的name是组件自己的name还是路由中的name', 'Vue中的keep-alive中的include和exclude用的name是组件自己的name还是路由中的name。', 'Vue中的keep-alive中的include和exclude用的name是组件自己的name还是路由中的name。\n\n使用的是组件中的name属性，与路由中的name没有关系，路由中的name只做路由跳转使用。\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 13, 1, '2020-11-28 18:02:55', '2021-1-28 23:07:24', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (89, 10000, '疑问：Vue中methods使用data的疑问', '疑问：Vue中methods使用data的疑问', '代码是这样的,在data中定义了一个名为AnimatorChoices的属性并设置为false\n```\ndata() {\n      return {\n        AnimatorChoices: false\n      }\n},\n```\n\n在methods中打印\n```\nmethods: {\n      upOptions() {\n        console.log(this.AnimatorChoices)  //这里输出false\n        onscroll = function () {\n          let height = document.body.scrollTop || document.documentElement.scrollTop;\n          if (height > 80) {\n            console.log(this.AnimatorChoices)  //这里输出为什么为undefined\n            this.AnimatorChoices = true;  \n            console.log(this.AnimatorChoices)\n          }\n        }\n      }\n    },\n```\n\n方法在created声明周期函数中调用\n```\ncreated() {\n      this.upOptions()\n    }\n```\n\n为什么会输出undefined\n![](https://img-ask.csdnimg.cn/upload/1611997981215.png)\n\n> 回复1：\n```\n你在upOptions方法里面又建了一个方法onscroll， 此时onscroll的this不是当前vue对象。\n简单理解就是method的中的单层方法才可以直接调用data。\n解决方法一：使用回调函数\n解决方法二：that=this\n```\n解决方法2：\n```\nupOptions() {\n        let choices = document.getElementById(\'choices\')\n        let that = this\n        //console.log(this)  //vueComponent\n        onscroll = function () {\n          //console.log(this)  //Window\n          //console.log(that) //vueComponent\n          let height = document.body.scrollTop || document.documentElement.scrollTop;\n          if (height > 150) {\n            that.AnimatorChoices = true\n            // choices.classList.add(\"animate_choices\");\n          } else {\n            that.AnimatorChoices = false\n            // choices.classList.remove(\"animate_choices\");\n          }\n        }\n      }\n```\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 18, 1, '2020-11-28 18:06:05', '2021-1-30 20:53:45', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (90, 10000, '修改网站的滚动条样式', '修改网站的滚动条样式', '修改网站的滚动条样式\n\n```\n/*定义滚动条高宽及背景 高宽分别对应横竖滚动条的尺寸*/\n::-webkit-scrollbar {\n  width: 9px;\n  height: 9px\n}\n\n/*定义滚动条轨道*/\n::-webkit-scrollbar-track {\n  background-color: transparent;\n  -webkit-border-radius: 2em;\n  -moz-border-radius: 2em;\n  border-radius: 2em\n}\n\n/*定义滑块 内阴影+圆角*/\n::-webkit-scrollbar-thumb {\n  /*background-color: rgba(144,147,153,.3);*/\n  background-color: rgb(196,197,200);\n  -webkit-border-radius: 2em;\n  -moz-border-radius: 2em;\n  border-radius: 2em\n}\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 11, 1, '2020-11-28 18:09:35', '2021-1-31 10:45:21', 'https://www.cnblogs.com/mirage-mc/p/12642778.html', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (92, 10000, '【报错记录】阿里OSS报OSSException:The request signature we calculated does not match the signature you pro...', 'vue图标上传', '参考链接：https://blog.csdn.net/DCTANT/article/details/107917268\n原因是路径打错了，有两个“\\”，即“\\\\”所以报这个错误', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 7, 1, '2020-11-29 11:53:46', '2021-2-2 22:29:07', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (93, 10000, '【MyBatis】Could not autowire. No beans of \'CategoryService\' type found.', '【MyBatis】Could&emsp;not&emsp;autowire.&emsp;No&emsp;beans&emsp;of&emsp;\'CategoryService\'&emsp;type&emsp;found.报错的原因。', '【MyBatis】Could not autowire. No beans of \'CategoryService\' type found.报错的原因。\n\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202102/03/20210203110431image.png)\n\n没有加上Service注解，加上后正常\n\n```\n@Service\npublic class CategoryServiceImpl implements CategoryService {\n    @Autowired\n    private CategoryDao categoryDao;\n\n    @Override\n    public List<Category> getCategory() {\n        List<Category> categories = categoryDao.getCategory();\n        return categories;\n    }\n}\n```\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202102/05/20210205220516image.png)\n数据也正常返回\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202102/05/20210205220607image.png)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 9, 1, '2020-11-29 12:04:13', '2021-2-5 22:06:40', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (94, 10006, '图片测试', '2020.11.29', '图片测试2020.11.29![1542898409446.jpg](http://112.124.21.222/images/blogImages/1542898409446.jpg)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 10, 1, '2020-11-29 12:18:24', '2020-11-29 12:18:24', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (95, 10000, '如何让你的网站支持https访问', '如何让你的网站支持https访问', '先看阿里云官方文档：[阿里云SSL证书安装](https://help.aliyun.com/document_detail/98576.html)\n\n### 步骤1：申请证书\n在阿里云上申请SSL证书，一个人可以申请20个<font color=\"red\">免费</font>的证书\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202102/22/20210222113527image.png)\n\n然后就可以去控制台申请证书了\n啪的一下证书就下来了，很快啊，有没有！\n\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202102/22/20210222113648image.png)\n\n### 步骤2：下载证书，并发送到服务器上\n根据你的服务器类型下载对应的证书，这里我以Tomcat9.0+为例\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202102/22/20210222113919image.png)\n\n### 步骤3：安装证书\n\n#### 3.1\n解压已下载保存到本地的Tomcat证书文件。\n解压后您将看到文件夹中有2个文件，您可为两个证书文件重命名。\n- 证书文件（domain name.pfx）：以PFX为文件类型。\n- 密码文件（pfx-password.txt）：以TXT为文件类型。\n![](https://static-aliyun-doc.oss-accelerate.aliyuncs.com/assets/img/zh-CN/1242336851/p33514.png)\n\n#### 3.2 \n在Tomcat安装目录下新建cert目录，将解压的证书和密码文件拷贝到cert目录下。\n\n#### 3.3\n修改配置文件server.xml（路径：Tomcat安装目录/conf/server.xml），并保存。\n   去掉以下内容的注释：\n```\n<Connector  port=\"8443\"\nprotocol=\"HTTP/1.1\"\n  SSLEnabled=\"true\"\n  maxThreads=\"150\" scheme=\"https\" secure=\"true\"\n  clientAuth=\"false\" sslProtocol=\"TLS\" />\n```\n\n参照以下内容修改<Connector port=\"443\"标签内容。\n```\n<Connector port=\"443\"   #port属性根据实际情况修改（https默认端口为443）。如果使用其他端口号，则您需要使用https://yourdomain:port的方式来访问您的网站。\n    protocol=\"HTTP/1.1\"\n    SSLEnabled=\"true\"\n    scheme=\"https\"\n    secure=\"true\"\n    keystoreFile=\"Tomcat安装目录/cert/domain name.pfx\" #证书名称前需加上证书的绝对路径，请使用您证书的文件名替换domain name。\n    keystoreType=\"PKCS12\"\n    keystorePass=\"证书密码\"  #请替换为密码文件pfx-password.txt中的内容。\n    clientAuth=\"false\"\n    SSLProtocol=\"TLSv1+TLSv1.1+TLSv1.2\"\n    ciphers=\"TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256\"/>\n```\ntomcat关闭！tomcat启动！\n使用https测试你的网站：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202102/22/20210222114505image.png)\n有个小锁代表你的证书安装成功\n\n### 扩展：开启HTTP强制跳转HTTPS\n配置web.xml文件，开启HTTP强制跳转HTTPS。\n在文件</welcome-file-list>后添加以下内容：\n```\n<login-config>  \n    <!-- Authorization setting for SSL -->  \n    <auth-method>CLIENT-CERT</auth-method>  \n    <realm-name>Client Cert Users-only Area</realm-name>  \n</login-config>  \n<security-constraint>  \n    <!-- Authorization setting for SSL -->  \n    <web-resource-collection >  \n        <web-resource-name >SSL</web-resource-name>  \n        <url-pattern>/*</url-pattern>  \n    </web-resource-collection>  \n    <user-data-constraint>  \n        <transport-guarantee>CONFIDENTIAL</transport-guarantee>  \n    </user-data-constraint>  \n</security-constraint>\n```\n再次：tomcat关闭！tomcat启动！ 使用http访问你的网站时会自动标为https\n\n### 补充错误：配置https出现使用了不受支持的协议\n\n解决方案：去掉CDN加速，如果你使用了CDN加速的话\n免费版百度云加速是不支持SSL的，也就是说免费版百度云加速是不支持HTTPS的，哪怕是你自己想上传自己的证书也不可以。去掉CDN加速即可\n\n如果想使用CDN加速访问https的话可以开启CDN的https功能，不过这个功能所产生的流量不包含在CDN加速包中，需要额外收费。\n\n完结：有问题可以给我留言~~', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 27, 1, '2020-11-29 19:36:23', '2021-12-29 11:21:40', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (97, 10000, 'vue 用v-model绑定的input，直接在js里.value赋值无效', 'vue&emsp;用v-model绑定的input，直接在js里.value赋值无效', '今天发现Vue的一个特点\n即：vue 用v-model绑定的input，直接在js里.value赋值无效，不知道是不是bug\n这种情下使用js直接修改input或者textarea中的值时，v-model所绑定的值并不会发生改变。\n即用js添加文本，得到的还是空字符串。\n> 解决方法：需要在.value赋值后，手动触发input事件\n```\n//js修改dom元素的值\ndom元素.value = \"admin\"\n//手动触发input事件\ndom元素.dispatchEvent(new Event(\'input\'))\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 10, 1, '2020-11-29 19:40:30', '2021-2-26 18:58:35', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (98, 10000, '获取元素样式（兼容IE8）', '获取元素样式（兼容IE8）', '```\n    // obj: 要获取样式的元素\n    // name: 要获取的样式名\nfunction getStyle(obj, name) {\n      if (window.getComputedStyle) {\n        //正常浏览器的获取方式，具有getComputedStyle方法\n        return getComputedStyle(obj, null)[name];\n      } else {\n        //IE8的方式，没有getComputedStyle方法\n        return obj.currentStyle[name];\n    }\n    //简便写法\n    //return window.getComputedStyle ? getComputedStyle(obj, null)[name] : obj.currentStyle[name];\n}\n  //用法示例\n  let obj = document.getElementById(\"obj\");\n  console.log(getStyle(obj, \"width\"))\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 8, 1, '2020-11-29 19:41:44', '2021-2-28 10:17:46', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (99, 10000, '发布成功提示', '发布成功提示', '发布成功提示\n\n```\nreturn window.getComputedStyle ? getComputedStyle(obj, null)[name] : obj.currentStyle[name];return window.getComputedStyle ? getComputedStyle(obj, null)[name] : obj.currentStyle[name];\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 19, 1, '2020-11-30 16:52:27', '2021-2-28 10:57:33', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (100, 10000, 'Vue之$nextTick（关于$nextTick的补充）', '上次转载了一篇关于$nextTick的文章，感觉讲的不是通俗易懂，所以这次自己写一篇关于$nextTick具体作用的补充文章，让自己更加印象深刻。', '> 上次转载了一篇关于$nextTick的文章[上一次的文章](www.youyul.com/#/blog/10000/article/64)，感觉讲的不是通俗易懂，所以这次自己写一篇关于$nextTick具体作用的补充文章，让自己更加印象深刻。\n\n### 1. $nextTick是什么\n> 首先明白$nextTick是什么\n\n&emsp;&emsp;通俗的话说：在Vue里面对元素的操作（比如修改元素的innerHTML属性），DOM不是在你修改完后马上更新的，而是有一个更新队列，简单来说，**你更新了DOM，想马上获取更新后的数据是获取不到的，你能获取的只是更新之前的旧数据**，这显然不是我们想要的操作啊，**我们想要的是**：更新完DOM之后，马上获取DOM的值，获取到的是最新值，现在我获取的是旧数据，怎么办呢？这个时候，我们的主角$nextTick就派上用场了。\n\n### 2. $nextTick有什么用\n> 为什么$nextTick可以解决问题\n\n&emsp;&emsp;上一步说到了，更新完DOM之后，马上获取DOM的值，获取不到最新值，获取到的是旧数据。$nextTick恰好可以解决这个问题，为什么它可以解决这个问题？因为$nextTick是在下一次DOM更新之后执行的，也就是说放在$nextTick中的代码将在下一次DOM更新之后执行，那么DOM更新了，我获取的自然是最新值。\n\n### 3. 举例说明\n\n```\n<template>\n  <div class=\"hello\">\n    <div>\n      <button id=\"firstBtn\" @click=\"testClick()\" ref=\"aa\">{{testMsg}}</button>\n    </div>\n  </div>\n</template>\n\n<script>\n  export default {\n    name: \"Program\",\n    data() {\n      return {\n        testMsg: \"原始值\",\n      }\n    },\n    methods: {\n      testClick() {\n        this.$nextTick(function () {\n          let btn = document.getElementById(\"firstBtn\")\n          console.log(\"更新前：\" + btn.innerHTML) //输出 更新前：原始值\n          this.testMsg = \"456456\"\n          console.log(\"更新后：\" + btn.innerHTML) //输出 更新前：原始值\n          this.$nextTick(function () {\n            console.log(\"使用nextTick后：\" + btn.innerHTML)\n          });\n        });\n      }\n    },\n    created() {\n      // 情况一：不使用$nextTick，报错说明在created中获取DOM一定要在$nextTick中，因为created时DOM挂载未完成\n      // 报错：Error in created hook: \"TypeError: Cannot read property \'innerHTML\' of null\"\n      let btn = document.getElementById(\"firstBtn\")\n      // 更新前的DOM值\n      console.log(\"created更新前：\" + btn.innerHTML)\n      // 修改按钮的值\n      this.testMsg = \"456456\"\n      // 更新后的DOM值\n      console.log(\"created更新后：\" + btn.innerHTML)\n      this.$nextTick(function () {\n        console.log(\"created使用nextTick后：\" + btn.innerHTML)\n      });\n\n      // 情况二：使用$nextTick，输出正常\n      // created更新前：原始值\n      // created更新后：原始值\n      // created使用nextTick后：456456\n      this.$nextTick(function () {\n        let btn = document.getElementById(\"firstBtn\")\n        //更新前的DOM值\n        console.log(\"created更新前：\" + btn.innerHTML) //created更新前：456456\n        //修改按钮的值\n        this.testMsg = \"456456\"\n        //更新后的DOM值\n        console.log(\"created更新后：\" + btn.innerHTML) //created更新后：456456\n        this.$nextTick(function () {\n          console.log(\"created使用nextTick后：\" + btn.innerHTML) //created使用nextTick后：456456\n        });\n      });\n    },\n    mounted() {\n      // 情况一：不使用$nextTick，输出正常，说明使用$nextTick也可以，因为mounted时DOM挂载完毕\n      let btn = document.getElementById(\"firstBtn\")\n      // 更新前的DOM值\n      console.log(\"mounted更新前：\" + btn.innerHTML) //mounted更新前：原始值\n      // 修改按钮的值\n      this.testMsg = \"456456\"\n      // 更新后的DOM值\n      console.log(\"mounted更新后：\" + btn.innerHTML) //mounted更新后：原始值\n      this.$nextTick(function () {\n        console.log(\"mounted使用nextTick后：\" + btn.innerHTML) //mounted使用nextTick后：456456\n      });\n\n      // 情况一：使用$nextTick\n      this.$nextTick(function () {\n        let btn = document.getElementById(\"firstBtn\")\n        //更新前的DOM值\n        console.log(\"mounted更新前：\" + btn.innerHTML) //mounted更新前：原始值\n        //修改按钮的值\n        this.testMsg = \"456456\"\n        //更新后的DOM值\n        console.log(\"mounted更新后：\" + btn.innerHTML)  //mounted更新后：原始值\n        this.$nextTick(function () {\n          console.log(\"mounted使用nextTick后：\" + btn.innerHTML) //mounted使用nextTick后：456456\n        });\n      });\n    }\n  }\n</script>\n\n<style scoped>\n\n</style>\n```\n\n> 注意：\n\n1.$nextTick和DOM有关，直接输出data中的值获取的是最新值。$nextTick只和DOM有关的操作，与data无关，不要将二者弄混了，修改data中的数据，data马上就更新了，不存在延迟更新问题（**vue加载数据和dom的渲染是异步的** ）。\n2.另外在create中对DOM修改操作都应该放在`$nextTick`中，否则你是获取不到DOM的值的。\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 30, 1, '2020-11-30 16:55:04', '2022-2-25 16:28:42', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (101, 10006, '阿里云盘初体验', '阿里云盘初体验&emsp;下载速度如何', '今年阿里巴巴集团推出一款名为“阿里云盘”的独立APP，和百度网盘的作用一样，用来上传、下载、分享资料等一系列的操作，为用户提供服务，其网盘空间更大，下载速度更快。\n\n“阿里云盘”前段时间曾上架各大应用商店，但是不知道什么原因，又下架了，也许是阿里没有准备好。\n\n目前，“阿里云盘”已在苹果手机APP Store上架，最新版本为v1.0.1，其安卓手机并没有上架，但可以通过申请内测获取下载资格。\n![image.png](http://112.124.21.222/images/blogImages/image.png)\n但是，对于安卓用户也不用表示羡慕，我通过申请获得了邀请码，已经提前尝鲜了，虽然空间大小只有1T，但是也挺满足了。\n新上架的网盘，亮点主要包括：空间更大、速度更快、安全可靠、智能相册，同时还支持5G极速下载，这些都是网盘应有的功能。\n阿里云盘APP包含主要包含首页、文件、上传、相册以及个人中心5个主要功能模块，而且每个模块使用体验、包括动画效果都是特别的棒。\n其中，阿里云盘为了保护用户的重要文件，特意推出一个“虎符文件保险箱”，使用双重密码来保障用户的重要资料。\n\n大小分配为50G左右！\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 32, 1, '2020-11-30 20:40:10', '2020-11-30 20:40:10', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (106, 10000, '图书馆的座位爆满了', '每到期末都这样', '![684BC33E065E4E2CA2A52B43F58DD680.png](http://112.124.21.222/images/blogImages/684BC33E-065E-4E2C-A2A5-2B43F58DD680.png)![B3377ACB0FD44CCEAC2FD15018ED4626.png](http://112.124.21.222/images/blogImages/B3377ACB-0FD4-4CCE-AC2F-D15018ED4626.png)![A93E327F16A44073B282DEF01F39E81B.png](http://112.124.21.222/images/blogImages/A93E327F-16A4-4073-B282-DEF01F39E81B.png)![E59EC99DE4AB4FE1B63FE80124645238.png](http://112.124.21.222/images/blogImages/E59EC99D-E4AB-4FE1-B63F-E80124645238.png)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 10, 1, '2020-12-6 14:20:15', '2020-12-6 14:20:15', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (107, 10000, '事件的传播(捕获阶段、目标阶段、冒泡阶段)', '事件的传播(捕获阶段、目标阶段、冒泡阶段)', '事件的传播\n&emsp;-关于事件的传播网景公司和微软公司有不同的理解\n&emsp;-微软公司认为事件应该是由内向外传播，也就是当事件触发时，应该先触发当前元素上的事件，\n然后再向当前元素的祖先元素上传播，也就说事件应该在冒泡阶段执行。\n&emsp;网景公司认为事件应该是由外向内传播的，也就是当前事件触发时，应该先触发当前元素的最外层的祖先元素的事件,然后在向内传播给后代元素\n&emsp;- W3C综合了两个公司的方案，将事件传播分成了三个阶段\n1.捕获阶段\n&emsp;&emsp;-在捕获阶段时从最外层的祖先元素，向目标元素进行事件的捕获，但是默认此时不会触发事件\n2.目标阶段\n&emsp;&emsp;-事件捕获到目标元素，捕获结束开始在目标元素上触发事件\n3.冒泡阶段\n&emsp;&emsp;-事件从目标元素向他的祖先元素传递，依次触发祖先元素上的事件\n\n-如果希望在捕获阶段就触发事件，可以将addEventListener()的第三个参数设置为true,一般情况下我们不会希望在捕获阶段触发事件，所以这个参数一般都是false\n\n-IE8及以下的浏览器中没有捕获阶段', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 8, 1, '2020-12-8 22:38:56', '2021-3-3 11:07:36', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (108, 10000, '学校的猫可太瘦了', '学校里的猫是真的瘦啊！', '123', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 22, 1, '2020-12-8 22:42:10', '2021-9-9 16:23:10', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (109, 10000, 'JavaScript事件代理（事件委托）', 'JavaScript事件代理（事件委托）', 'https://blog.csdn.net/qq_38128179/article/details/86293394', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 16, 1, '2020-12-8 23:13:51', '2021-3-19 11:02:13', 'https://blog.csdn.net/qq_38128179/article/details/86293394', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (114, 10000, 'Vue.set()和vm.$set()分别在什么场景下调用', 'Vue.set()：一般在独立的js文件中<br>vm.$set()：vm是Vue实例，有实例的时候调用', 'Vue.set()：全局方法，一般在独立的js文件中，并有导入Vue的地方\n```JavaScript\nimport Vue from \'vue\'\n```\n\n\nvm.$set()：实例方法，vm是Vue实例，有实例的时候调用，大部分vm就是this，可以写成this.$set()', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 7, 1, '2020-12-12 19:52:06', '2021-3-19 15:45:51', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (115, 10000, 'transition和transition-group', 'transition:单个元素<br>transition-group:多个元素', '`<transition>` 元素作为单个元素/组件的过渡效果。`<transition>` 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。\n\n`<transition-group>` 元素作为多个元素/组件的过渡效果。`<transition-group>` 渲染一个真实的 DOM 元素。默认渲染 `<span>`，可以通过 `tag` attribute 配置哪个元素应该被渲染。\n\n注意，每个 `<transition-group>` 的子节点必须有独立的 key，动画才能正常工作', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 5, 1, '2020-12-12 20:49:03', '2021-3-22 19:11:27', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (116, 10000, 'offsetHeight、scrollHeight、clientHeight和offsetTop、scrollTop、clientTop', '关于offsetHeight、scrollHeight、clientHeight和offsetTop、scrollTop、clientTop之间的区别', '不错的文章https://blog.csdn.net/qq_27397357/article/details/52839355\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Document</title>\n    <style>\n        #box1 {\n            height: 300px;\n            width: 300px;\n            background-color: cadetblue;\n            overflow: scroll;\n            border: 10px solid skyblue;\n        }\n\n        #box2 {\n            height: 500px;\n            width: 500px;\n            background-color: rgba(136, 255, 0, .5);\n        }\n    </style>\n</head>\n\n<body>\n    <script>\n        window.onload = () => {\n            let box1 = document.getElementById(\"box1\");\n            console.log(box1.clientHeight); // 283\n            console.log(box1.offsetHeight); // 320\n            console.log(box1.scrollHeight); // 500\n\n            let box2 = document.getElementById(\"box2\");\n            console.log(box2.clientHeight); // 500\n            console.log(box2.offsetHeight); // 500\n            console.log(box2.scrollHeight); // 500\n\n            console.log(box1.offsetTop); // 8\n            console.log(box1.clientTop); // 10\n            console.log(box1.scrollTop); // 0\n\n            console.log(box2.offsetTop); // 18\n            console.log(box2.clientTop); // 0\n            console.log(box2.scrollTop); // 0\n\n            // 页面加载后滚动一段距离\n            setTimeout(() => {\n                console.log(box1.scrollTop); // 200\n                console.log(box2.scrollTop); // 0\n            }, 3000)\n        }\n\n    </script>\n\n    <div id=\"box1\">\n        <div id=\"box2\"></div>\n    </div>\n</body>\n\n</html>\n```\n\n总结\n`clientHeight`、`offsetHeight`、`scrollHeight`\n1. `clientHeight`: 元素内容体的显示高度，不包括滚动条和被折叠隐藏的部分。\n2. `offsetHeight`: 元素的显示高度，不包括被折叠隐藏的部分。\n3. `scrollHeight`: 元素的实际高度，包括被折叠隐藏的部分。\n\n\n`offsetTop`、`offsetTop`、`scrollTop`\n1. `offsetTop`：元素相对于父元素内容体顶部的高度。\n2. `clientTop`：元素上边框高度。\n3. `scrollTop`：元素发生滚动后，滚动的高度。\n\n\n![图片详情](https://www.runoob.com/wp-content/uploads/2021/10/L0hUTUw15byA5Y-R5paH5qGjL2ltYWdlcy9Dc3NCb3hNb2RlbC5wbmc.png)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 25, 1, '2020-12-12 20:50:11', '2022-4-21 13:45:35', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (117, 10000, '学习Javascript闭包（Closure）', '闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。<br>下面就是我的学习笔记，对于Javascript初学者应该是很有用的。<br>转载于阮一峰的博客', '原文链接：http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html#comment-text\n闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。\n\n下面就是我的学习笔记，对于Javascript初学者应该是很有用的。\n\n**一、变量的作用域**\n\n要理解闭包，首先必须理解Javascript特殊的变量作用域。\n\n变量的作用域无非就是两种：全局变量和局部变量。\n\nJavascript语言的特殊之处，就在于函数内部可以直接读取全局变量。\n\n```JavaScript\nvar n=999;\n\n　　function f1(){\n　　　　alert(n);\n　　}\n\n　　f1(); // 999\n```\n\n另一方面，在函数外部自然无法读取函数内的局部变量。\n\n```JavaScript\nfunction f1(){\n　　　　var n=999;\n　　}\n\n　　alert(n); // error\n```\n\n这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！\n\n```JavaScript\n　function f1(){\n　　　　n=999;\n　　}\n\n　　f1();\n\n　　alert(n); // 999\n```\n\n**二、如何从外部读取局部变量？**\n\n出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。\n\n那就是在函数的内部，再定义一个函数。\n\n```JavaScript\nfunction f1(){\n\n　　　　var n=999;\n\n　　　　function f2(){\n　　　　　　alert(n); // 999\n　　　　}\n\n　　}\n```\n\n在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的\"链式作用域\"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\n\n既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！\n\n```JavaScript\nfunction f1(){\n\n　　　　var n=999;\n\n　　　　function f2(){\n　　　　　　alert(n);\n　　　　}\n\n　　　　return f2;\n\n　　}\n\n　　var result=f1();\n\n　　result(); // 999\n```\n\n**三、闭包的概念**\n\n上一节代码中的f2函数，就是闭包。\n\n各种专业文献上的\"闭包\"（closure）定义非常抽象，很难看懂。我的理解是，闭包就是能够读取其他函数内部变量的函数。\n\n由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成\"定义在一个函数内部的函数\"。\n\n所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n\n**四、闭包的用途**\n\n闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。\n\n怎么来理解这句话呢？请看下面的代码。\n\n```JavaScript\nfunction f1(){\n\n　　　　var n=999;\n\n　　　　nAdd=function(){n+=1}\n\n　　　　function f2(){\n　　　　　　alert(n);\n　　　　}\n\n　　　　return f2;\n\n　　}\n\n　　var result=f1();\n\n　　result(); // 999\n\n　　nAdd();\n\n　　result(); // 1000\n```\n\n在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。\n\n为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。\n\n这段代码中另一个值得注意的地方，就是\"nAdd=function(){n+=1}\"这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。\n\n**五、使用闭包的注意点**\n\n1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。\n\n2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。\n\n**六、思考题**\n\n如果你能理解下面两段代码的运行结果，应该就算理解闭包的运行机制了。\n\n代码片段一。\n\n```JavaScript\nvar name = \"The Window\";\n\n　　var object = {\n　　　　name : \"My Object\",\n\n　　　　getNameFunc : function(){\n　　　　　　return function(){\n　　　　　　　　return this.name;\n　　　　　　};\n\n　　　　}\n\n　　};\n\n　　alert(object.getNameFunc()());  // 空白\n```\n\n代码片段二。\n\n```JavaScript\nvar name = \"The Window\";\n\n　　var object = {\n　　　　name : \"My Object\",\n\n　　　　getNameFunc : function(){\n　　　　　　var that = this;\n　　　　　　return function(){\n　　　　　　　　return that.name;\n　　　　　　};\n\n　　　　}\n\n　　};\n\n　　alert(object.getNameFunc()());  // My Object\n```\n参考链接\nhttps://segmentfault.com/a/1190000011612140\nhttps://zhuanlan.zhihu.com/p/122885549', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 23, 1, '2020-12-12 20:54:15', '2022-4-1 14:58:24', 'http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html#comment-text', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (118, 10000, 'ES的Promise对象', 'ES的Promise对象的一些基本信息', '# Promise 对象\n\n## Promise 的含义\n\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了`Promise`对象。\n\n所谓`Promise`，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。\n\n`Promise`对象有以下两个特点。\n\n（1）对象的状态不受外界影响。`Promise`对象代表一个异步操作，有三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是`Promise`这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。\n\n（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。`Promise`对象的状态改变，只有两种可能：从`pending`变为`fulfilled`和从`pending`变为`rejected`。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对`Promise`对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n注意，为了行文方便，本章后面的`resolved`统一只指`fulfilled`状态，不包含`rejected`状态。\n\n有了`Promise`对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，`Promise`对象提供统一的接口，使得控制异步操作更加容易。\n\n`Promise`也有一些缺点。首先，无法取消`Promise`，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。第三，当处于`pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n\n如果某些事件不断地反复发生，一般来说，使用 [Stream](https://nodejs.org/api/stream.html) 模式是比部署`Promise`更好的选择。\n\n## 基本用法\n\nES6 规定，`Promise`对象是一个构造函数，用来生成`Promise`实例。\n\n下面代码创造了一个`Promise`实例。\n\n```javascript\nconst promise = new Promise(function(resolve, reject) {\n  // ... some code\n\n  if (/* 异步操作成功 */){\n    resolve(value);\n  } else {\n    reject(error);\n  }\n});\n```\n\n`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。\n\n`resolve`函数的作用是，将`Promise`对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；`reject`函数的作用是，将`Promise`对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。\n\n`Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。\n\n```javascript\npromise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n```\n\n`then`方法可以接受两个回调函数作为参数。第一个回调函数是`Promise`对象的状态变为`resolved`时调用，第二个回调函数是`Promise`对象的状态变为`rejected`时调用。这两个函数都是可选的，不一定要提供。它们都接受`Promise`对象传出的值作为参数。\n\n下面是一个`Promise`对象的简单例子。\n\n```javascript\nfunction timeout(ms) {\n  return new Promise((resolve, reject) => {\n    setTimeout(resolve, ms, \'done\');\n  });\n}\n\ntimeout(100).then((value) => {\n  console.log(value);\n});\n```\n\n上面代码中，`timeout`方法返回一个`Promise`实例，表示一段时间以后才会发生的结果。过了指定的时间（`ms`参数）以后，`Promise`实例的状态变为`resolved`，就会触发`then`方法绑定的回调函数。\n\nPromise 新建后就会立即执行。\n\n```javascript\nlet promise = new Promise(function(resolve, reject) {\n  console.log(\'Promise\');\n  resolve();\n});\n\npromise.then(function() {\n  console.log(\'resolved.\');\n});\n\nconsole.log(\'Hi!\');\n\n// Promise\n// Hi!\n// resolved\n```\n\n上面代码中，Promise 新建后立即执行，所以首先输出的是`Promise`。然后，`then`方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以`resolved`最后输出。', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 7, 1, '2020-12-12 20:57:34', '2021-3-26 19:33:05', 'https://es6.ruanyifeng.com/#docs/promise', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (119, 10000, 'SpringBoot - 获取GET/POST请求参数详解', 'SpringBoot&emsp;-&emsp;获取GET/POST请求参数详解', 'GET:https://www.hangge.com/blog/cache/detail_2484.html\nPOST：https://www.hangge.com/blog/cache/detail_2485.html\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 7, 1, '2020-12-12 20:59:05', '2021-3-26 21:25:49', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (120, 10000, '在Vue/Cli4中添加sass-loader', '在Vue/Cli4中添加sass-loader,安装步骤和注意事项', '今天想在项目中写Scss代码，先要安装一下吧，于是我按照网上的教程，最终还是报了一大串错误，虽然不写SCSS代码还是可以运行，不过我们就是要写SCSS的，还是解决一下吧。\n以下是具体的解决方案：\n\n注意以下几点，：如果不对的话不保证能成功\n```Java\n1. CLI版本为4.0+的，我的是4.5.8\n2. 有没有安装style-loader\n```\n如果都有的话，那么：\n```Java\nnpm install --save-dev sass-loader@7.3.1\nnpm install --save-dev node-sass\n```\n注意以下版本，我直接执行`npm install --save-dev sass-loader`，安装的是11.0.1的，结果报了一大堆错误，其实很多错误都是版本问题导致的，文章结尾会展示版本。\n\n安装好了之后，打开vue.config.js ,添加以下代码\n\n```JavaScript\nconst path = require(\'path\')\nmodule.exports = {\n  pluginOptions: {\n    \'style-resources-loader\': {\n      preProcessor: \'sass\',\n      patterns: [\n        path.resolve(__dirname, \'./src/assets/styles/*.scss\')      //你的.scss文件所在目录\n      ]\n    }\n  }\n}\n```\nOK!  SCSS顺利编译。\n看一下版本吧。\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/27/20210327193321image.png)\n看一下编译效果CSS\nSCSS代码：\n```CSS\n<style lang=\"scss\" scoped>\n  #music-app {\n    height: 200px;\n    width: 200px;\n    background-color: cadetblue;\n    .title{\n      background-color: skyblue;\n    }\n    .content {\n      background-color: red;\n    }\n  }\n</style>\n```\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/27/20210327193357image.png)\n\n完结！', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/bugrecord.svg', 0, 0, 13, 1, '2020-12-12 22:30:48', '2021-3-27 19:36:59', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (121, 10000, 'mysql数据表按照某个字段分类输出', 'mysql数据表按照某个字段分类输出', 'select serialize,group_concat(area) as areas from area group by serialize；\n\n参考链接：https://www.jb51.net/article/69587.htm', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/mysql.jpg', 0, 0, 4, 1, '2020-12-12 22:32:28', '2021-3-28 14:59:54', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (122, 10000, 'React和Vue之类的“只关注视图”是什么意思', 'React和Vue之类的“只关注视图”是什么意思', '**React和Vue之类的“只关注视图”是什么意思**\n我们看到网页上的数据一般要经历这几个步骤\n```HTML\n第一步：浏览器向服务器请求数据\n第二步：处理浏览器接收的数据\n第三步：将处理好的数据在DOM上渲染\n```\nReact和Vue之类的“只关注视图”的意思就是只关注第三步DOM的渲染，第一步数据的请求和第二步数据的处理对于React和Vue并不管，这就是“只关注视图”', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 8, 1, '2020-12-12 22:32:41', '2021-3-29 15:55:27', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (123, 10000, 'VsCode修改代码提示和代码格式的快捷键', 'VsCode修改代码提示和代码格式的快捷键', '打开VSCode，点击File->Preference->Keybord shortcuts\n\n修改代码提示：输入`Trigger Sugget`查找\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/29/20210329192345image.png)\n修改文档格式校正提示：输入`Format Document`查找\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/29/20210329192506image.png)', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 17, 1, '2020-12-12 22:36:32', '2021-3-29 19:25:52', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (124, 10000, 'JSON.parse() 与 JSON.stringify()', 'JSON.parse()&emsp;与&emsp;JSON.stringify()的用法。', '### JSON.stringify()\n> JSON.stringify方法用于将一个 **值(一般为JS对象)** 转为 **JSON 字符串**。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。\n\n### JSON.parse()\n> JSON.parse()从一个**JSON字符串**中解析出**JS对象**,用于将 JSON 字符串转换成对应的**值(一般是JS对象)**。\n```JavaScript\n      let person = {\n        name: \"lin\",\n        age: 22\n      }\n      let person2 = {\n        \"name\": \"lin\",\n        \"age\": \"22\"\n      }\n      console.log(person)\n      console.log(person2)\n      // JSON.stringify方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。\n      let newPerson = JSON.stringify(person)\n      let newPerson2 = JSON.stringify(person2)\n      console.log(newPerson)\n      console.log(newPerson2)\n      // JSON.parse()从一个JSON字符串中解析出JS对象,用于将 JSON 字符串转换成对应的值。\n      console.log(JSON.parse(newPerson))\n      console.log(JSON.parse(newPerson2))\n      // console.log(JSON.parse(person))  //error\n      // console.log(JSON.parse(person2))  //error\n```\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/29/20210329204749image.png)\n参考连接：https://javascript.ruanyifeng.com/stdlib/json.html', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 21, 1, '2020-12-12 22:43:12', '2021-3-29 20:48:14', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (125, 10000, 'JS之call()、apply()、bind() ', 'JS之call()、apply()、bind()&emsp;', '其实是一个很简单的东西，认真看十分钟就从一脸懵B 到完全 理解！\n先看明白下面：\n**例1**\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/30/20210330150238image.png)\nobj.objAge;  //17\nobj.myFun()  //小张年龄undefined\n**例2**\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/30/20210330150315image.png)\nshows()  //盲僧　\n\n比较一下这两者this 的差别，第一个打印里面的this 指向obj，第二个全局声明的shows()函数   this 是window ；\n1，call()、apply()、bind() 都是用来重定义 this 这个对象的！\n如：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/30/20210330150341image.png)\nobj.myFun.call(db)；　　　　//德玛年龄99\n\n 　  obj.myFun.apply(db);　　　 //德玛年龄99\n\n 　  obj.myFun.bind(db)();　　　//德玛年龄99\n\n以上出了bind 方法后面多了个 () 外 ，结果返回都一致！\n由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行\n \n2，对比call 、bind 、 apply 传参情况下\n　　![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/30/20210330150411image.png)\nobj.myFun.call(db,\'成都\',\'上海\')；　　　　 //德玛 年龄 99  来自 成都去往上海\n\n　　obj.myFun.apply(db,[\'成都\',\'上海\']);        //德玛 年龄 99  来自 成都去往上海  \n\n　　obj.myFun.bind(db,\'成都\',\'上海\')();         //德玛 年龄 99  来自 成都去往上海\n\n 　  obj.myFun.bind(db,[\'成都\',\'上海\'])();　　 //德玛 年龄 99  来自 成都,上海去往undefined\n\n　　\n\n微妙的差距！\n从上面四个结果不难看出\n　　call 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：\n　　call的参数是直接放进去的，第二第三第n个参数全都用逗号分隔，直接放到后面  obj.myFun.call(db,\'成都\', ... ,\'string\' )；\n　　apply的所有参数都必须放在一个数组里面传进去  obj.myFun.apply(db,[\'成都\', ..., \'string\' ]);\n　　bind除了返回是函数以外，它 的参数和call 一样。\n　　　　\n　　当然，三者的参数不限定是string类型，允许是各种类型，包括函数 、 object 等等！', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 54, 1, '2020-12-13 11:22:41', '2021-3-30 15:06:13', 'https://www.cnblogs.com/Shd-Study/p/6560808.html', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (126, 10000, 'Vue的.sync 修饰符', 'Vue的.sync&emsp;修饰符的解释和案例', '在说vue 修饰符sync前，我们先看下官方文档：vue .sync 修饰符，里面说vue .sync 修饰符以前存在于vue1.0版本里，但是在在 2.0 中移除了 .sync 。但是在 2.0 发布之后的实际应用中，我们发现 .sync 还是有其适用之处，比如在开发可复用的组件库时。我们需要做的只是让子组件改变父组件状态的代码更容易被区分。从 2.3.0 起我们重新引入了 .sync 修饰符，但是这次它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。\n示例代码如下：\n```JavaScript\n<comp :foo.sync=\"bar\"></comp>\n```\n会被扩展为：\n```JavaScript\n<comp :foo=\"bar\" @update:foo=\"val => bar = val\"></comp>\n```\n当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：\n```JavaScript\nthis.$emit(\'update:foo\', newValue)\n```\n猛一看不明白，下边我么通过一个实例（弹窗的关闭事件）来说明这个代码到底是怎么运用的。\n```JavaScript\n<template>\n    <div class=\"details\">\n        <myComponent :show.sync=\'valueChild\' style=\"padding: 30px 20px 30px 5px;border:1px solid #ddd;margin-bottom: 10px;\"></myComponent>\n        <button @click=\"changeValue\">toggle</button>\n    </div>\n</template>\n<script>\nimport Vue from \'vue\'\nVue.component(\'myComponent\', {\n      template: `<div v-if=\"show\">\n                    <p>默认初始值是{{show}}，所以是显示的</p>\n                    <button @click.stop=\"closeDiv\">关闭</button>\n                 </div>`,\n      props:[\'show\'],\n      methods: {\n        closeDiv() {\n          this.$emit(\'update:show\', false); //触发 input 事件，并传入新值\n        }\n      }\n})\nexport default{\n    data(){\n        return{\n            valueChild:true,\n        }\n    },\n    methods:{\n        changeValue(){\n            this.valueChild = !this.valueChild\n        }\n    }\n}\n</script>\n```\n\n动态效果如下：\n\n[](https://upload-images.jianshu.io/upload_images/7579449-1567b35b54771fc6.gif)\n\nvue 修饰符sync的功能是：当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。如果我们不用.sync，我们想做上面的那个弹窗功能，我们也可以props传初始值，然后事件监听，实现起来也不算复杂。这里用sync实现，只是给大家提供一个思路，让其明白他的实现原理，可能有其它复杂的功能适用sync。\n\n这只是一个简单的例子，看完这个不知你是不觉得有个指令跟这个很相似，v-model？对，就是v-model在组件上使用的时候。\n具体的可以查看：vue 自定义组件使用v-model，可以实现同样的功能。也是以这个弹窗事件做演示的\n', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 11, 1, '2020-12-13 15:47:19', '2021-3-30 17:57:44', 'https://www.jianshu.com/p/6b062af8cf01', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (127, 10000, 'Vue2.4中$attrs和$listeners的使用-学习笔记', '尚未整理', 'https://www.cnblogs.com/badaozongcai/articles/12791262.html\nhttps://blog.csdn.net/songxiugongwang/article/details/84001967\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 17, 1, '2020-12-13 15:49:08', '2021-9-1 19:55:25', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (128, 10000, 'Vue项目如何使用CDN引入静态文件', '对于Vue.js、vue-router.js、VueX.js....等等这一类的静态资源文件我们不必把它包含在项目中占用服务器的带宽，我们完全可以使用各大平台提供的CDN文件来引入，这样我们网站加载的速度会快很多。', '对于Vue.js、vue-router.js、VueX.js....等等这一类的静态资源文件我们不必把它包含在项目中占用服务器的带宽，我们完全可以使用各大平台提供的CDN文件来引入，这样我们网站加载的速度会快很多。\n下面是在Vue/CLI4.0+引入CDN文件的方式。\n#### 第一步：在HTML文件中添加文件。\n打开项目中的index.HTML，引入如下几种文件（按照你的实际需求引入），我的是1个css，5个js文件\n```HTML\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0\">\n    <link rel=\"icon\" href=\"<%= BASE_URL %>favicon.ico\">\n    <title>MYPROJECT</title>\n    <!-- CDN加速 -->\n    <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/element-ui@2.13.2/lib/theme-chalk/index.css\">\n    <!-- CDN加速 -->\n  </head>\n  <body>\n    <noscript>\n      <strong>We\'re sorry but <%= htmlWebpackPlugin.options.title %> doesn\'t work properly without JavaScript enabled. Please enable it to continue.</strong>\n    </noscript>\n    <div id=\"app\"></div>\n    <!-- CDN加速 -->\n    <script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.min.js\" rel=\"stylesheet\" type=\"text/javascript\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/vuex@3.0.1/dist/vuex.min.js\" rel=\"stylesheet\" type=\"text/javascript\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/axios@0.19.0/dist/axios.min.js\" rel=\"stylesheet\" type=\"text/javascript\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/vue-router@3.4.5/dist/vue-router.min.js\" rel=\"stylesheet\" type=\"text/javascript\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/element-ui@2.13.2/lib/index.js\" rel=\"stylesheet\" type=\"text/javascript\"></script>\n    <!-- CDN加速 -->\n    <!-- built files will be auto injected -->\n  </body>\n</html>\n```\n#### 第二步：修改vue.config.js的内容\n```JavaScript\nmodule.exports = {\n	//打包是否生成.map文件\n	productionSourceMap: false,\n	lintOnSave: false,\n	configureWebpack: {\n		// 打包忽略文件\n		externals: {\n			\"element-ui\": \"ELEMENT\",\n			vue: \"Vue\",\n			\"vue-router\": \"VueRouter\",\n			vuex: \"Vuex\",\n			axios: \"axios\",\n		}\n	},\n}\n```\n#### 第三步：运行测试\n如果成功的话，页面应该是可以正常显示的。\n\n#### 疑问：是否要注释掉引入？？\n例如：import Vue from \'vue’这些，我看了一些博客说要注释掉，但是我测试了注释掉和不注释的，打包处来文件大小是一样的，应该是`CLI4.0`版本的脚手架做了处理了.\n#### 错误记录\n浏览器报错 `Uncaught TypeError: Cannot read property \'prototype\' of undefined` 的解决办法\n错误原因：js文件引入**顺序错误**，我的代码改过了直接复制应该没有问题，elementui.js要在vue.js后引入。。。。\n\n参考：\n[vue-cli4项目配置cdn引入静态资源](https://blog.csdn.net/weixin_35958891/article/details/106996168)\n\n[浏览器报错 Uncaught TypeError: Cannot read property \'prototype\' of undefined 的解决办法](https://blog.csdn.net/love_onefly/article/details/80612499)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 19, 1, '2020-12-13 15:56:59', '2021-4-17 18:04:37', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (129, 10000, 'React新的生命周期和旧的生命周期有什么区别', 'React新的生命周期和旧的生命周期有什么区别', '![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/31/20210331203529image.png)\n', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/ReactLogo.png', 0, 0, 16, 1, '2020-12-13 16:02:05', '2021-4-24 11:32:56', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (130, 10000, 'vue v-for更新了数据却不会触发nextTick？', 'vue&emsp;v-for更新了数据却不会触发nextTick？', 'vue v-for更新了数据却不会触发nextTick？\n\ncreate只执行一次？', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 35, 1, '2020-12-13 16:32:50', '2021-4-1 16:18:12', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (131, 10000, 'js内存泄露的几种情况详细探讨', 'js内存泄露的几种情况详细探讨', 'https://www.jb51.net/article/37685.htm', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 14, 1, '2020-12-13 16:41:44', '2021-4-6 16:46:41', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (132, 10000, 'vue中v-if和v-for不建议同时使用的坑', 'vue中v-if和v-for不建议同时使用的坑', '参考官方文档：[Vue官方文档](https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/conditional.html%23v-if-%25E4%25B8%258E-v-for-%25E4%25B8%2580%25E8%25B5%25B7%25E4%25BD%25BF%25E7%2594%25A8)\n在官方文档中明确指出v-for和v-if不建议一起使用。\n\n原因：v-for比v-if优先级高，所以使用的话，每次v-for都会执行v-if,造成不必要的计算，影响性能，尤其是当之需要渲染很小一部分的时候。\n```\n<ul>\n    <li v-for=\"user in users\" v-if=\"user.isActive\" :key=\"user.id\">\n      {{ user.name }}\n    </li>\n  </ul>\n```\n\n如上述情况，即使有100个user中只有一个需要使用v-if，也需要整个循环数组，这在性能上是极大的浪费。\n\n那难道就没有更好的解决办法，回答：当然是有解决方法的；我们可以使用computed\n\n示例：\n```\n<div>\n	<div v-for=\"(user,index) in activeUsers\" :key=\"user.index\" >\n		{{ user.name }} \n	</div>\n</div>\ndata () {  // 业务逻辑里面定义的数据\n    return {\n      users,: [{\n        name: \'111111\',\n        isShow: true\n      }, {\n        name: \'22222\',\n        isShow: false\n      }]\n    }\n  }\ncomputed: {\n	activeUsers: function () {\n		return this.users.filter(function (user) {\n			return user.isShow;//返回isShow=true的项，添加到activeUsers数组\n		})\n	}\n}\n```\n\n总结：v-for比v-if优先级高，一起使用在性能上会造成极大的浪费，并且官网也并不推荐我们这样做，所以我们可以选择使用computed过滤掉列表中不需要显示的项目。', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 17, 1, '2020-12-13 16:46:59', '2021-4-7 16:12:00', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (135, 10005, 'JDK源码解析 java.lang.String', '通过本质来解析JDK源码，更容易理解代码', '# 1、String类的定义：\n  ```\npublic final class String implements java.io.Serializable,Comparable<String>,CharSequence{}\n\n```\n\n&emsp;这是一个final声明的常量类,不能被任何类所继承，而且一旦一个String对象被创建，包含在这个对象中的字符序列是不被改变的，包括该类后续的所有方法都是不能修改该对象的，直至该对象被销毁，这是我们需要特别注意的（该类的一些方法看似改变了字符串，其实内部都是创建一个新的字符串）接着实现了Serializable接口，这是一个序列化标志接口，还实现了Comparable接口，用于比较两个字符串的大小（按顺序比较单个字符的ASCII码），后面会有具体方法实现；最后实现了CharSequence接口，表示是一个有序字符的集合，相应的方法后面也会介绍。\n\n# 2、字段属性：\n\n```\n/**用来存储字符串**/\nprivate final char value[];\n\n/**缓存字符串的哈希码**/\nprivate int hash;\n\n/**实现序列化标识**/\nprivate static final long seriaVersionUID = -6849794470754667710L; \n```\n一个String字符串实际上是一个char数组。\n\n# 3、构造方法\nString类的构造方法很多，可以通过初始化一个字符串，或者字符数组，或者字节数组等等来创建一个String对象。\n\n![image.png](http://112.124.21.222/images/blogImages/image.png)\n\n```\nString str1 = \"abc\";//注意这种字面量声明的区别，文末会详细介绍\n2 String str2 = new String(\"abc\");\n3 String str3 = new String(new char[]{\'a\',\'b\',\'c\'});\n```\n# 4、equals（Object anObject）方法\n```\n\npublic boolean equals(Object anObject){\n  if(this == anObject){\n     return 0;\n  }\n  if(anObject instanceof String){\n     String anotherString = (String)anObject;\n     int n = value.length;\n     if(n == anotherString.value.length){\n        char v1[] = value;\n        char v2[] = anotherString.value;\n        int i = 0;\n        while(n--!= 0){\n            if(v1[i]!=v2[i])\n               return false;\n            i++;\n        }\n        return true;        \n     }\n  }\n  return false;\n}\n\n```\nString类重写了equals方法，比较的是组成字符串的每一个字符是否相同，如果相同则返回true，否则返回false。\n\nhashCode()方法\n\n\n\n\n\n\n\n\n \n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 39, 1, '2020-12-16 15:32:23', '2020-12-16 16:41:13', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (136, 10000, 'params和data和query', 'params和data和query关系和区别', '1.params和data是用于axios的网络请求的，网络请求没有query这个类型。  \n\n2.query和params是路由间的传参\n\n两个都有params但是指的不是同一个params\n\n\nquery和params的区别：https://www.cnblogs.com/cxxb/p/11119702.html', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 14, 1, '2020-12-16 20:40:53', '2020-12-17 10:04:25', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (137, 10000, '理解vue的单向数据流', '对于Vue中单向数据流的理解', '所有的 `prop` 都使得其父子 `prop` 之间形成了一个单向下行绑定：父级 `prop` 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。\n\n额外的，每次父级组件发生更新时，子组件中所有的 `prop` 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 `prop`。如果你这样做了，Vue 会在浏览器的控制台中发出警告。\n\n这里有两种常见的试图改变一个 `prop` 的情形：\n\n1.这个 `prop` 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 `prop` 数据来使用。在这种情况下，最好定义一个本地的 `data` 属性并将这个 `prop` 用作其初始值：\n```js\nprops: [\'initialCounter\'],\ndata: function () {\n  return {\n    counter: this.initialCounter\n  }\n}\n```\n\n2.这个 `prop` 以一种原始的值传入且需要进行转换。在这种情况下，最好使用这个 `prop` 的值来定义一个计算属性：\n```js\nprops: [\'size\'],\ncomputed: {\n  normalizedSize: function () {\n    return this.size.trim().toLowerCase()\n  }\n}\n```\n\n注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 `prop` 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。\n```js\nprops: {\n  list: {\n    type: Array,\n    default: (() => [])\n  }\n},\nmethods: {\n  addFn () {\n    this.list.push(\'newValue\')\n  }\n}\n```\n\n单向数据流：父级 `prop` 的更新会向下流动到子组件中，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 8, 1, '2020-12-19 17:05:43', '2021-4-8 15:12:02', 'https://blog.csdn.net/wu_xianqiang/article/details/88946735', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (138, 10000, '为什么前端项目要使用webpack？', 'webpack官方文档说webpack是一个module&emsp;bundler(模块打包器)。第一次听到这个概念的时候，你可能会想这是什么鬼，我好好写我的代码，老老实实实现需求不就好了吗，为什么需要模块打包器呢。', '### webpack是什么\nwebpack官方文档说webpack是一个module bundler(模块打包器)。第一次听到这个概念的时候，你可能会想这是什么鬼，我好好写我的代码，老老实实实现需求不就好了吗，为什么需要模块打包器呢。\n\n要理解为什么webpack是什么，我们先记住这两个词：\n\n- 模块\n- 打包\n\n### 为什么要打包\n然后让我们从一个html页面说起，下面的代码可以看到，我在html页面中通过script标签引入了3个JavaScript文件`a.js`，`b.js`和`c.js`，每个文件中分别定义了一个函数并导出（export）给外部用。并且它们之间有一定的依赖关系，`c.js`依赖于`b.js`，`b.js`依赖于`a.js`。\n```HTML\n|- index.html\n|- main.css\n| - a.js\n| - b.js\n| - c.js\n```\n```HTML\n// index.html\n<!doctype html>\n<html>\n  <head><link href=\"main.css\" rel=\"stylesheet\"></head>\n  <body>\n    <div>hello world</div>\n    <script type=\"text/javascript\" src=\"a.js\"></script>\n    <script type=\"text/javascript\" src=\"b.js\"></script>\n    <script type=\"text/javascript\" src=\"c.js\"></script>\n  </body>\n</html>\n```\n\n```js\n// a.js\nexport default function () {\n  return a + b;\n}\n```\n\n```js\n// b.js\nimport add from \'a\';\nexport default function (c, d) {\n  return c / add(c, d);\n}\n```\n```js\n// c.js\nimport percentage from \'b\';\nexport default function (e, f) {\n  console.log(percentage(e, f));\n}\n```\n\n\n因为有3个js文件，所以浏览器需要发送三次http 请求来获取这三个文件，然后依次执行其中的代码，如果其中有一个文件因为网络问题而延误了时间，那么整个页面的显示也会被延误。3个文件还好，而当我们的项目逐渐变大，有几十个到上百个JavaScript文件的时候，那问题会更严重，不但有延迟问题，还会遇到很难维护的问题 — 想想如何维护上百个文件的依赖关系？\n\n这时候你会想，是不是我把所有JavaScript文件合成一个文件就好了呢？没错，我们确实可以这样做，这样就减少了http请求数量，让我们的页面加载和显示更快。不过这个合并的阶段是在开发完成之后才进行的，也就是说开发阶段我仍然是有`a.js`，`b.js`和`c.js`等等这些文件的，这样才好开发和维护，因为如果开发阶段就合并的话，就相当于我基于一个可能上万行的文件进行开发，这样的代码是没法维护的。\n\n在开发后完成的这个合并的过程就是打包，这样你就明白为什么要打包了吧。webpack在打包过程中，会分析各个文件之间的依赖关系，然后生成一个依赖图并用文件的形式保存下来，未来浏览器运行代码的时候就可以读取这个文件，就知道了各个代码块之间的关联以及如何调用了。\n\nwebpack\n\n上面只是用JavaScript文件来举例子，实际上webpack可以支持多种文件类型的打包，如`css`，`sass`，`jpg`，`svg`等等。如果感兴趣，可以去webpack的官方网站去探索 https://webpack.js.org。\n### 什么是模块\n上面的3个文件，每个文件都可以看做是一个模块，在JavaScript中可以把模块看做是一堆代码，这堆代码可以被复用，执行某个具体的操作，从表象上来看就是一个模块就是一个文件，其中包含了export这样的关键字用来将模块的功能导出给外部用。\n```js\n// b.js\nimport add from \'a\';\nexport default function (c, d) {\n  return c / add(c, d);\n}\n```\n\n\n从`b.js`这个文件/模块中就可以看出，首先从a模块中导入了一个函数，然后定义了一个新的函数，并通过`export` 导出。\n\n### 总结\n打包是webpack最核心的功能，webpack其它所有的功能都是为了让打包这个功能更好。我们从一个简单的html页面介绍了通过webpack对模块进行打包，既保留了单个模块的可维护性，又减少了页面的http请求，减少了页面加载时间，从而增加了页面的显示速度，让整个应用的体验更好。\n', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webpacklogo.png', 0, 0, 10, 1, '2020-12-20 20:32:15', '2021-4-12 15:20:46', 'https://www.jianshu.com/p/d9c998911561', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (139, 10005, '小超', '小超——新一代\"做题家\"', '  2020年12月21日,《中国青年报》带头讽刺中国的“小镇做题家”，而我们的好同志，小超他站了出来！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 19, 1, '2020-12-21 17:23:38', '2020-12-21 17:23:38', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (140, 10000, '猪猪考研加油', '猪猪考研加油，加油！加油！加油！', '猪猪考研加油！加油加油加油！！！', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 21, 1, '2020-12-26 07:38:05', '2020-12-26 07:39:36', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (141, 10000, '关于Vue.use()详解', '关于Vue.use()详解', 'https://juejin.cn/post/6844903833450053640\n\nhttps://segmentfault.com/a/1190000021629648', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 8, 1, '2020-12-26 07:40:25', '2021-4-15 15:17:11', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (142, 10000, 'Vue中父子组件的生命周期执行的顺序', 'Vue中父子组件的生命周期执行的顺序', '- 加载渲染过程\n　　父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted\n\n- 子组件更新过程\n　　父beforeUpdate->子beforeUpdate->子updated->父updated\n\n- 父组件更新过程\n　　父beforeUpdate->父updated\n\n- 销毁过程\n　　父beforeDestroy->子beforeDestroy->子destroyed->父destroyed\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 7, 1, '2020-12-26 09:12:30', '2021-4-18 14:42:57', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (143, 10000, 'js之防抖和节流', 'js之防抖和节流', '概念：\n**函数防抖(debounce)** ：触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。\n\n**函数节流(throttle)** ：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率。\n\n函数节流（throttle）与 函数防抖（debounce）都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟，假死或卡顿的现象。\n\n**1、函数防抖(debounce)**\n\n实现方式：每次触发事件时设置一个延迟调用方法，并且取消之前的延时调用方法\n缺点：如果事件在规定的时间间隔内被不断的触发，则调用方法会被不断的延迟\n补充：虽然如此，但是我们依然可以根据定时器的原理将函数在短时间的高频调用转化成**初次点击的立即调用**\n方式1：短时间内的多次触发，只有最后一次可以被延迟响应。\n```js\nfunction debounce1(cb, timer) {\n            var t = null\n            return function () {\n                clearTimeout(t)\n                t = setTimeout(() => {\n                    cb.apply(this, arguments)\n                }, timer)\n            }\n        }\n```\n方式二：短时间内的多次触发，只有第一次触发会被立即响应。\n```js\nfunction debounce(cb, timer) {\n            var t = null\n            return function () {\n                clearTimeout(t)\n                if (!t) {    //如果不存在定时器\n                    cb.apply(this, arguments)\n                }\n                t = setTimeout(() => {\n                    t = null\n                }, timer)\n            }\n        }\n```\n\n**2、函数节流(throttle)**\n\n实现方式：每次触发事件时，如果当前有等待执行的延时函数，则直接return\n```js\n        function throttle(cb, delay) {\n            let canRun = true; // 通过闭包保存一个标记\n            return function () {\n                // 在函数开头判断标记是否为true，不为true则return\n                if (!canRun) {\n                    return\n                }\n                // 立即设置为false\n                canRun = false;\n                cb.apply(this, arguments);  //可以根据需求将此段代码放进setTimeout可以实现在延时尾调用，此处表示延时头调用（立即调用）\n                // 将外部传入的函数的执行放在setTimeout中\n                setTimeout(() => {\n                    // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。\n                    // 当定时器没有执行的时候标记永远是false，在开头被return掉\n                    canRun = true;\n                }, delay);\n            };\n        }\n```\n\n总结：\n**函数防抖**：将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。\n\n**函数节流**：使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行。\n\n**区别**： 函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。 比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。\n\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 52, 1, '2020-12-26 10:20:06', '2021-8-18 14:07:16', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (144, 10000, '回调地狱、Promise、async/await', '回调地狱、Promise、async/await之间的区别', '#### 1. 传统的回调地狱\n> 传统的回调地狱产生导致难维护，灵活性差的问题，嵌套一层又一层，不方便修改，而且当某写回调需要改变执行顺序时，可能要移动很大一部分代码，非常的不方便。于是我们使用Promise来代替传统的回调地狱。\n```js\n// 传统回调地狱,函数作为参数\nfunction add1(cb) {\n    setTimeout(() => {\n        cb && cb()\n    }, 1000)\n}\n\nadd1(() => {\n    console.log(1)\n    add1(() => {\n        console.log(2)\n        add1(() => {\n            console.log(3)\n        })\n    })\n})\n```\n#### 2. Promise\n> Promise避免了地狱回调的问题，它使用向`then`里面传递回调函数作为参数的的方式执行回调函数，代码清晰更利于维护，而且修改回调的执行顺序也比较简单。\n```js\n// Promise异步方式\nlet add = function () {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve()\n        }, 1000)\n    })\n}\n\nadd().then(() => {\n    console.log(1)\n    return add()\n}).then(() => {\n    console.log(2)\n    return add()\n}).then(() => {\n    console.log(3)\n})\n```\n\n#### 3. async/await配合promise实现异步\n> 可以理解成更方便的`Promise`，使用`async`和`await`关键字将异步代码写成同步代码的形式，更加清晰。可以把`async`和`await`理解成是`Promise`和`then`的语法糖, `async`可以单独使用，把一个函数转换成		`Promise`对象，而`await`要搭配`async`使用，如果不这样会出错`await is only valid in async function`\n```js\n// async/await配合Promise实现异步\nfunction add1(a) {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(a)\n            resolve(a)\n        }, 1000)\n    })\n}\n\nasync function add() {\n    let a = await add1(1)\n    // console.log(a)\n    let b = await add1(a + 1)\n    // console.log(b)\n    let c = await add1(b + 1)\n    // console.log(c)\n\n}\n\nadd()\n```\n>### 还是不太理解async和await的作用吗？\n#### `async/await` 的优势在于处理 then 链\n单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。\n\n举个例子吧\n```js\nfunction foo() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            return resolve(\'success\')\n        }, 1000)\n    })\n}\n```\n思考一下，如果你想获得这段代码resolve的值`success`，你会怎么做？用then来获取！\n```js\nfoo().then((res) => {\n    console.log(res)  //success\n})\n```\n用`async/await`怎么做？\n```js\nasync function bar() {\n    let res = await foo()\n    console.log(res)   //success\n}\n```\n那不是一样吗？有什么用？想象一下，假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果，发生then链怎么办？\n\n我们要写一个长长的Promise链\n```js\n/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n + 200，这个值将用于下一步骤\n */\nfunction takeLongTime(n) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(n + 200), n);\n    });\n}\n\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step2(n) {\n    console.log(`step2 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step3(n) {\n    console.log(`step3 with ${n}`);\n    return takeLongTime(n);\n}\n```\n现在用 Promise 方式来实现这三个步骤的处理\n```js\nfunction doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => step2(time2))\n        .then(time3 => step3(time3))\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeEnd(\"doIt\");\n        });\n}\n\ndoIt();\n\n// c:\\var\\test>node --harmony_async_await .\n// step1 with 300\n// step2 with 500\n// step3 with 700\n// result is 900\n// doIt: 1507.251ms\n```\n输出结果 result 是 step3() 的参数 700 + 200 = 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd() 计算的结果一致。\n\n如果用 async/await 来实现呢，会是这样\n```js\nasync function doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time2);\n    const result = await step3(time3);\n    console.log(`result is ${result}`);\n    console.timeEnd(\"doIt\");\n}\n\ndoIt();\n```\n结果和之前的 `Promise` 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样。\n\n我们上面说的都是Promise被`resolve`的情况，那也有可能被`reject`啊，那我们怎么在`async/await`中处理`reject`的情况？\n写法1：\n```js\n//await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。\nasync function bar() {\n    try {\n        let res = await foo()\n        console.log(res)\n    } catch (err) {\n        console.log(err)\n    }\n}\n```\n写法2：\n```js\nasync function bar() {\n    let res = await foo().catch(function (err){\n        console.log(err);\n    });\n    console.log(res)\n}\n```\n总结：`async`其实可以理解成是`Promise`和`then`的语法糖，我们本来要在`Promise`在`resolve`之后,用`then(res=>{})`中的`res`来接收`resolve`的值，但是现在我们使用`async/await`，我们不在使用`then`(但是还是要搭配`Promise`，`async/await`只是改变了数据的接收方式)，我们直接使用`let res = await foo()`，来获取数据，`await`会自动等待异步操作`foo`完成，并将其`resolve`的结果赋值给`res`,注意，等待的是`resolve`中的结果，而不是`Promise`本身, 这样，这个`res`就等于`then(res)`中的`res`了，我们可以像写同步代码一样对`res`进行操作，而不用写在`then()`的回调中, 代码简洁了很多。\n\n#### 思考题1\n判断下列代码的输出顺序：\n```js\nfunction timer() {\n    console.log(\'进入timer\')\n    return new Promise((resolve) => {\n        console.log(\'Promise开始处理\')\n        setTimeout(() => {\n            console.log(\'定时器执行\')\n            resolve(\'success\')\n            console.log(\'定时器结束\')\n        }, 1000)\n    })\n}\n\nasync function testAsync() {\n    console.log(1)\n    let result = await timer()\n    console.log(2)\n    console.log(result)\n    return \'async finish\'\n    // return Promise.resolve(\'async finish\') // 等同于 return \'async finish\'\n}\n\nconsole.log(3)\nlet a = testAsync()\nconsole.log(a)\na.then((value) => {\n    console.log(value)\n})\nconsole.log(4)\n```\n答案：\n```js\n3\n1\n进入timer\nPromise开始处理\nPromise { <pending> }\n4\n定时器执行\n定时器结束\n2\nsuccess\nasync finish\n```\n分析：\n- `\'3\'`先输出，这个没有疑问，因为它在函数调用之前就输出。\n- 然后调用`testAsync`这个`async`函数，函数内先按同步顺序执行输出`\'1\'`。\n- 而后使用`await`调用`timer`函数，函数体先开始同步执行，输出`进入timer`和`Promise开始处理`。\n- 继续执行，遇到setTimeout异步函数，由于`timer`函数返回的是一个包装了异步操作（一个定时器）的Promise对象，意味着await的后面是一个Promise对象，于是`async`和`await`搭配，将`let result = await timer()`这条语句后面的操作阻塞，即timer()中的异步操作将会添加到EventLoop同步任务之后执行，并等待`let result = await timer()`完成后继续执行函数中剩下的代码，但是该操作不会阻塞函数外侧的代码，于是`console.log(a)`及其后面的代码继续同步执行，由于`async`返回的是一个Promise对象，于是输出`Promise { <pending> }`，表示该Promise对象还在执行当中。\n- 由于a还处于`pending`状态，于是`a.then....`代码还未到执行时机，代码继续同步执行，输出`\'4\'`。\n- 此时，所有外侧的代码同步执行全部结束，即EventLoop中的同步事件已全部完成，定时器被添加到EventLoop队列最后端，于是在等待1000ms（可能时1000ms,但是也可能大于1000ms,定时器只能保证函数不会提前执行，但有可能延后执行，原因是可能在setTimeout中的回调函数被添加到EventLoop中时，前面还有未完成的同步代码，这就是定时器为什么不准的原因）之后，定时器回调函数被添加到EventLoop后面等待执行，执行回调函数时，输出`定时器执行`，随后Promise被resolve.\n- 在resolve之后还有一个输出的同步任务，于是输出`定时器结束`。上面代码中，调用resolve(\'success\')以后，后面的console.log(\'定时器结束\')还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。\n- resolve执行之后，这意味着Promise的状态从`pending`变为`fulfilled`，表明`let result = await timer()`语句执行结束，`async`中之前被`await`阻塞的代码可以继续同步执行，于是输出`2`。\n- 接着输出`await`等待的结果即result，输出`success`。\n- 继续执行`return \'async finish\'`，`return`代表`async`返回的Promise被resolve，于是`a.then....`中的回调函数开始调用，输出resolve返回的结果，即输出`async finish`。\n\n#### 思考题2\n```js\nnew Promise((resolve, reject) => {\n    console.log(\'Promise1执行\')\n    setTimeout(() => {\n        console.log(\'setTimeout1执行\')\n        new Promise((resolve, reject) => {\n            console.log(\'Promise2执行\')\n            setTimeout(() => {\n                console.log(\'setTimeout2执行\')\n                resolve(\'Promese2被resolve\')\n            },3000)\n        }).then((res)=>{\n            resolve(\'Promese1被resolve,\'+res)\n        })\n    }, 1000)\n}).then((res) => {\n    console.log(res)\n})\n\n// Promise1执行\n// setTimeout1执行\n// Promise2执行\n// setTimeout2执行\n// Promese1被resolve,Promese2被resolve\n```\n\n> 注意：`await`后面接受的是一个结果，类似字符串，数字，对象等等，而不会是一个Promise对象，这样我们就可以定义一个变量来接受这个返回的结果，然后对结果进行操作，而不需要像Promise一样在`.then`里面操作，这样使得代码更像同步代码，更加整洁。\n\n\n#### 来自评论区的回复思考题：\n```js\nfunction testAsync() {\n    return new Promise((resolve, reject) => {\n        setTimeout(function() {\n            resolve(1);\n        }, 1000);\n    }).then(res => {\n        console.log(\"trace1: 第一个 Proimise 的异步结果\", res);     // <== 加个跟踪\n        setTimeout(function() {\n            console.log(\"trace3: 这会在 1 秒后看到\");\n            return 2;\n        }, 1000);\n    });\n}\n\nasync function test() {\n    const result = await testAsync();\n    console.log(\"trace2: testAsync 的异步结果\", result);            // <== 标明位置\n}\n\ntest();\n\n\n// trace1: 第一个 Proimise 的异步结果 1\n// trace2: testAsync 的异步结果 undefined\n// trace3: 这会在 1 秒后看到\n```\n这里执行步骤：\n\n1. `new` 一个 `Promise` 对象（假设为`p1`）\n2. 通过 `then()`等待 `p1` 执行完成，输出 `trace1`，然后执行同步代码 `setTimeout()`，这里注意：\n- `setTimeout()` 是同代码，但是里面的 `function() { return 2; }` 是异步代码，1 秒后执行。\n- `then` 的回调 `res => {}` 本身没有返回任何异步对象，它没有 `return` 语句，返回的 `undefined`\n3. `then` 的返回值会被封装成 `Promise` 对象，即 `Promise.resolve(undefined)`（假设为`p2`），这个对象是最终从 `testAsync()` 中返回的\n4. 在 `test()` 中用 `await` 等待 `testAsync()` 的结果，即 `p2`\n5. 由于 `p2` 没有封装异步过程，只是封装了一个值 `undefiend`，所以没有等待，直接赋给了 `result`\n6. 输出 `result`，也就是 `trace2: testAsync` 的异步结果 `undefined`\n7. 第 2 步 `setTimeout` 中的代码还在等待，1 秒后终于执行，输出 `trace3`\n\n如果用 `async` 改写 `testAsync` 会是这样的\n```js\nasync function testAsync() {\n    // 第 1 步\n    const p1 = new Promise((resolve, reject) => {\n        setTimeout(function() { resolve(1); }, 1000);\n    });\n\n    // 第 2 步，等待 p1 完成，得到 res，输出 trace1\n    const res = await p1;\n    console.log(\"trace1: 第一个 Proimise 的异步结果\", res);\n    \n    // 第 2 步继续\n    // 同步执行 setTimeout\n    // 但它的回调是异步的，会在一秒后执行\n    setTimeout(function() {\n        console.log(\"trace3: 这会在 1 秒后看到\");\n        return 2;\n    }, 1000);\n    \n    // 这里什么也没有返回，相当于 return undefined\n    // 对于 async 函数来说，相当于普通函数返回 Promise.resolve(undefined)\n}\n```\n\nasync/await参考链接：\nhttps://segmentfault.com/a/1190000007535316\nhttps://www.jianshu.com/p/b4fd76c61dc9', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 78, 1, '2020-12-26 11:27:33', '2022-2-23 17:07:23', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (145, 10000, 'CSS知识篇（持续更新....）', 'CSS的内容，持续更新中......', 'float:\nhttps://blog.csdn.net/qq_36595013/article/details/81810219\n\ndisplay: flex;\nhttp://www.ruanyifeng.com/blog/2015/07/flex-grammar.html', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 16, 1, '2020-12-26 11:45:07', '2021-4-24 17:24:34', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (146, 10000, '浏览器从输入URL并回车到页面呈现的过程中发生了什么', '浏览器从输入URL并回车到页面呈现的过程中发生了什么', '#### 1.输入URL并回车，寻找域名对应的IP地址\n1. 寻找url对应的ip地址，才能从服务器上获取数据。\n2. 它首先去找本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有，再去找DNS服务器。一般用户很少去编辑修改hosts文件。\n3. 如果没有，就去问本地域名服务器，具体过程如下\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202104/24/20210424114303image.png)\n\n#### 2.建立TCP链接\n费了九牛二虎之力，终于找到了ip地址了，这下可以问服务器要数据，不过，首先得“三次握手”\n#### 3.传递数据\n\n#### 4.关闭连接\n\n#### 5.处理数据HTML，CSS等\n   浏览器渲染引擎工作流程都差不多，大致分为5步，创建DOM树——创建StyleRules——创建Render树——布局Layout——绘制Painting\n\n    第一步，用HTML分析器，分析HTML元素，构建一颗DOM树(标记化和树构建)。\n\n    第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。\n\n    第三步，将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。每个DOM节点都有attach方法，接受样式信息，返回一个render对象(又名renderer)。这些render对象最终会被构建成一颗Render树。\n\n    第四步，有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。\n\n    第五步，Render树和节点显示坐标都有了，就调用每个节点paint方法，把它们绘制出来。 \n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202104/24/20210424114954image.png)\n\n参考链接\n[细说浏览器输入URL后发生了什么](https://segmentfault.com/a/1190000012092552)\n[一个网页的形成过程](https://segmentfault.com/a/1190000018384726)\n[vue核心之虚拟DOM(vdom)](https://www.jianshu.com/p/af0b398602bc)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 13, 1, '2020-12-26 11:47:38', '2021-4-24 11:55:44', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (147, 10000, 'Vue知识（持续更新。。。）', 'Vue知识（持续更新。。。）', 'vue的v-model原理简述：\nhttps://www.jianshu.com/p/ceaab8df4e78\n\nvue核心之虚拟DOM(vdom)\nhttps://www.jianshu.com/p/af0b398602bc\n\n前端工程化\nhttps://www.jianshu.com/p/88ed70476adb\n\nNPM和webpack的关系（转载）\nhttps://blog.csdn.net/CWH0908/article/details/90769823\n\n浅谈Vue的双向绑定\nhttps://www.jianshu.com/p/5fe2664ff5f7', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 18, 1, '2020-12-26 11:59:30', '2021-5-18 22:15:17', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (148, 10000, 'Springboot知识（持续更新中......）', 'Springboot知识（持续更新中......）', '[【springBoot】controller，service，dao，mapper，model层的作用](https://blog.csdn.net/bandaoyu/article/details/104759030/)\n\n[ajax和axios、fetch的区别](https://www.jianshu.com/p/8bc48f8fde75)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/spring.png', 0, 0, 5, 1, '2020-12-26 12:01:40', '2021-5-17 16:48:53', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (149, 10000, '在Vue中使用和风天气小组件', '和风天气小组件，在你的网站上显示天气信息。', '今天发现了一个天气插件———和风天气小组件，可以在你的网站上显示天气信息。\n```js\n<template>\n  <div id=\"he-plugin-standard\"></div>\n</template>\n\n<script>\n\n  export default {\n    name: \"WeatherStandard\",\n    created() {\n      window.WIDGET = {\n        \"CONFIG\": {\n          \"layout\": \"2\",\n          \"width\": \"248\",\n          \"height\": \"280\",\n          \"background\": \"2\",\n          \"dataColor\": \"000000\",\n          \"key\": \"e5e24e394c434747b495cb208979dfdf\"\n        }\n      };\n      (function (d) {\n        var c = d.createElement(\'link\')\n        c.rel = \'stylesheet\'\n        c.href = \'https://widget.heweather.net/standard/static/css/he-standard.css?v=1.4.0\'\n        var s = d.createElement(\'script\')\n        s.src = \'https://widget.heweather.net/standard/static/js/he-standard.js?v=1.4.0\'\n        var sn = d.getElementsByTagName(\'script\')[0]\n        sn.parentNode.insertBefore(c, sn)\n        sn.parentNode.insertBefore(s, sn)\n      })(document)\n    }\n  }\n</script>\n\n<style>\n  #he-plugin-standard {\n    background: linear-gradient(45deg, #FFE8EA, #EDF3FF, #EDF2FB) !important;\n  }\n</style>\n\n```\n效果\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202106/27/20210627114245image.png)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 17, 1, '2020-12-26 12:02:31', '2021-6-27 11:43:01', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (150, 10000, 'Vue安装脚手架报错：npm ERR! cb() never called! npm ERR! This is an error with....', 'Vue安装脚手架报错：npm&emsp;ERR!&emsp;cb()&emsp;never&emsp;called!&emsp;npm&emsp;ERR!&emsp;This&emsp;is&emsp;an&emsp;error&emsp;with....的解决方法。', '今天在安装Vue脚手架时出现了一个错误\n\n```js\nnpm ERR! cb() never called! npm ERR! This is an error with....\n```\n\n解决方法：\n```js\nnpm cache clean -f\n```\n在此之前我执行了`npm install`\n\n有可能是包没下完整？\n或者是sass问题？\n\n参考链接：\nhttps://blog.csdn.net/weixin_43502157/article/details/113698539', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 25, 1, '2020-12-26 12:03:43', '2021-9-1 08:33:44', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (151, 10000, 'nginx下部署Vue应用的history模式【本站为例，详细配置】', '今天想把网站改成Vue-Router的history模式，但是搞了一个上午也没有什么起色，中午仔细想了一下细节的问题，下午一会就成功了，这篇文章就来说一下我的部署过程以及一些注意事项。', '今天想把网站改成Vue-Router的history模式，但是搞了一个上午也没有什么起色，中午仔细想了一下细节的问题，下午一会就成功了，这篇文章就来说一下我的部署过程以及一些注意事项。\n\n如果你也在这个问题上逗留了很久，那么相信下面这段话你也看过很多次了，但是我还是想复述一遍。\n\n以下是从[Vue-Router](https://router.vuejs.org/zh/guide/essentials/history-mode.html)官网上复制下来的内容。\n\n---\n\n`vue-router` 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。\n\n如果不想要很丑的 hash，我们可以用路由的 **history 模式**，这种模式充分利用 `history.pushState` API 来完成 URL 跳转而无须重新加载页面。\n\n```js\nconst router = new VueRouter({\n  mode: \'history\',\n  routes: [...]\n})\n```\n\n当你使用 history 模式时，URL 就像正常的 url，例如 `http://yoursite.com/user/id`，也好看！\n\n不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 `http://oursite.com/user/id` 就会返回 404，这就不好看了。\n\n所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 `index.html` 页面，这个页面就是你 app 依赖的页面。\n\n## 后端配置例子\n\n**注意**：下列示例假设你在根目录服务这个应用。如果想部署到一个子目录，你需要使用 [Vue CLI 的 `publicPath` 选项 (opens new window)](https://cli.vuejs.org/zh/config/#publicpath)和相关的 [router `base` property (opens new window)](https://router.vuejs.org/zh/api/#base)。你还需要把下列示例中的根目录调整成为子目录 (例如用 `RewriteBase /name-of-your-subfolder/` 替换掉 `RewriteBase /`)。\n\n#### [#](https://router.vuejs.org/zh/guide/essentials/history-mode.html#apache)Apache\n\n```text\n<IfModule mod_rewrite.c>\n  RewriteEngine On\n  RewriteBase /\n  RewriteRule ^index\\.html$ - [L]\n  RewriteCond %{REQUEST_FILENAME} !-f\n  RewriteCond %{REQUEST_FILENAME} !-d\n  RewriteRule . /index.html [L]\n</IfModule>\n```\n\n除了 `mod_rewrite`，你也可以使用 [`FallbackResource` (opens new window)](https://httpd.apache.org/docs/2.2/mod/mod_dir.html#fallbackresource)。\n\n#### [#](https://router.vuejs.org/zh/guide/essentials/history-mode.html#nginx)nginx\n\n```nginx\nlocation / {\n  try_files $uri $uri/ /index.html;\n}\n```\n\n#### [#](https://router.vuejs.org/zh/guide/essentials/history-mode.html#原生-node-js)原生 Node.js\n\n```js\nconst http = require(\'http\')\nconst fs = require(\'fs\')\nconst httpPort = 80\n\nhttp.createServer((req, res) => {\n  fs.readFile(\'index.html\', \'utf-8\', (err, content) => {\n    if (err) {\n      console.log(\'We cannot open \"index.html\" file.\')\n    }\n\n    res.writeHead(200, {\n      \'Content-Type\': \'text/html; charset=utf-8\'\n    })\n\n    res.end(content)\n  })\n}).listen(httpPort, () => {\n  console.log(\'Server listening on: http://localhost:%s\', httpPort)\n})\n```\n\n---\n\n这些内容其实就是解释了为什么生产情况下Vue-Router使用history模式无法工作以及在各个服务器下的解决方案。\n\n\n\n下面，我将从Vue应用，nginx服务器这两方面进行详细的配置阐述。\n\n### 正文开始！\n\n#### Vue应用详细配置\n\n```\n明确几个要点\n1. 路由的index.js中base的值\n2. vue.config.js中publicPath的值。\n```\n\n##### 1.路由的index.js中base的值\n\n```\nmode: \'history\',\n// base: process.env.BASE_URL, \n//因为我目前nginx下只部署了一个dist前端文件，所以这里我把base注释掉了，如果你配备了多个前端资源文件，那就要把base改成相应的值如 \'/home/\',\'/data/www/\'等，注意这是在index.js文件中配置的内容，所以结尾也是\'/\'，但是在nginx上就不需要\'/\'结尾了。\nroutes,\n```\n\n##### 2.vue.config.js中publicPath的值。\n\n```\nmodule.exports = {\n  publicPath: \'/\',   //这个必须要写！引入静态资源需要从根路径引入，否则会找不到静态资源\n}\n```\n\nVue中的详细配置我们就说到这里，接下来看看nginx中的配置。\n\n#### nginx服务器\n\n打开conf下的`nginx.conf`文件,添加下面的这一行配置。\n\n```\nlocation / {\n  try_files $uri $uri/ /index.html; //添加这一行\n}\n```\n\n好了，Vue应用，nginx服务器这两方面的配置以及全部结束，接下来就是刷新应用了（如果你用到了CDN技术的化，在重新部署静态资源记得刷新CDN），然后我们就可以看到我们的网站正常使用history模式了。\n\n参考文件：\nhttps://blog.csdn.net/Stand_Fast/article/details/118525267\nhttps://www.cnblogs.com/snaillu/p/14123388.html', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 17, 1, '2020-12-26 12:04:57', '2021-8-14 16:46:26', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (152, 10000, 'Vuex状态管理-mapState的基本用法详细介绍', '当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用&emsp;mapState&emsp;辅助函数帮助我们生成计算属性，让你少按几次键', '注：本文主要介绍`mapState`的具体用法，`mapGetters`、`mapActions`、`mapMutations`用法类似。\n### 使用vuex集中管理状态\n- Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化\n\n```js\n// store.js\n\n/*\nvuex的核心管理对象模块:store\n */\nimport Vue from \'vue\'\nimport Vuex from \'vuex\'\n\nVue.use(Vuex)\n// 状态对象\nconst state = { // 初始化状态 这里放置的状态可以被多个组件共享\n  count: 1,\n  name: \'daming\'\n}\nconst mutations = {}\nconst action = {}\nconst getters = {}\n\nexport default new Vuex.Store({\n  state, // 状态\n  mutations, // 包含多个更新state函数的对象\n  actions, // 包含多个队形事件回调函数的对象\n  getters // 包含多个getter计算属性函数的对象\n})\n```\n\n```js\n// main.js\n\n/*\n入口JS\n */\nimport Vue from \'vue\'\nimport App from \'./App.vue\'\nimport store from \'./store\'\n\n// 创建vm\n/* eslint-disable no-new */\nnew Vue({\n  el: \'#app\',\n  components: {App}, // 映射组件标签\n  template: \'<App/>\', // 指定需要渲染到页面的模板\n  store // 所有的组件对象都多了一个属性:$store\n})\n```\n### 在组件中获取vuex状态\n\n虽然将所有的状态放入Vuex，会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。如果有些状态严格属于单个组件，最好还是作为组件的局部状态，比如temp变量,tempcount,tempcount2作为组件的局部状态。\n```js\n<!-- App.vue -->\n\n<template>\n  <div id=\"example\">\n    {{count}}\n    {{name}}\n    {{nameAlias}}\n  </div>\n</template>\n\n<script>\nimport { mapState } from \'vuex\'   // 引入mapState\nexport default {\n  data () {\n    return {\n      // 使用 Vuex 并不意味着你需要将所有的状态放入 Vuex。虽然将所有的状态放到 Vuex 会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。\n      // 如果有些状态严格属于单个组件，最好还是作为组件的局部状态。你应该根据你的应用开发需要进行权衡和确定。\n      // 下面的temp变量,tempcount,tempcount2作为组件的局部状态\n      temp: \'hello\',\n      tempcount: 1，\n      tempcount2: 2\n    }\n  },\n  computed: {\n      // tempCountPlusTempCount2 这个计算属性并没有涉及到vuex管理的状态\n      tempCountPlusTempCount2() { \n          return this.tempcount+this.tempcount2\n      } \n      \n      // 由于 Vuex 的状态存储是响应式的，所以可以使用计算属性来获得某个状态\n      // 当状态改变时，都会重新求取计算属性，并且触发更新相关联的 DOM\n      // 通过下面的计算属性，就可以在当前组件中访问到count,name,nameAlias等了 在模板中我们通过大括号符号打印出来\n      \n      // 下面的计算属性涉及到了vuex管理的状态\n      \n	  count () { // 这实际上是ES6中对象的简化写法 完整写法是 count: function { return this.$store.state.count }\n          return this.$store.state.age\n      },\n      name () { // 这实际上是ES6中对象的简化写法 完整写法是 name: function { return this.$store.state.age }\n          return this.$store.state.age\n      },\n      nameAlias () {\n        return this.$store.state.name\n      }\n      countplustempcount: function (state) {\n        return this.tempcount + this.$store.state.count\n      },\n      countplustempcount2 (state) {\n        return this.tempcount2 + this.$store.state.count\n      } \n      \n      // 但有一个问题\n      // 当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。比如上面的name(),count(),nameAlias(),显得重复，代码冗长\n      // 为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键：\n  }\n}\n</script>\n```\n但有一个问题，当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。比如上面的name(),count(),nameAlias(),显得重复，代码冗长。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键\n\n### mapState接收一个对象\nmapState函数的可以接受一个对象Object<string | function>。对象中可以包含字符串或函数。mapState()函数的返回结果是一个对象。\n```js\n<template>\n  <div id=\"example\">\n    {{count}}\n    {{name}}\n    {{nameAlias}}\n  </div>\n</template>\n\n<script>\nimport { mapState } from \'vuex\'\nexport default {\n  data () {\n    return {\n      temp: \'hello\',\n      tempcount: 1，\n      tempcount2: 2\n    }\n  },\n  computed: mapState({\n    count: \'count\',  // string    映射 this.count 为 store.state.count的值\n    // 箭头函数可使代码更简练\n    name: (state) => state.name, // function   映射 this.name 为 store.state.name的值\n    nameAlias: \'name\', // string   映射 this.nameAlias 为 store.state.name的值\n    countplustempcount: function (state) { // 用普通函数this指向vue实例,但是在箭头函数中this就不是指向vue实例了，所以这里必须用普通哈数\n      return this.tempcount + state.count\n    },\n    countplustempcount2 (state) {\n      return this.tempcount2 + state.count\n    }   \n  })\n}\n</script>\n```\n- 我们继续看上面的mapState函数\n\n```js\ncomputed: mapState({\n    count: \'count\',  // string    映射 this.count 为 store.state.count的值\n    // 箭头函数可使代码更简练\n    name: (state) => state.name, // function   映射 this.name 为 store.state.name的值\n    nameAlias: \'name\', // string   映射 this.nameAlias 为 store.state.name的值\n    countplustempcount: function (state) { // 用普通函数this指向vue实例,但是在箭头函数中this就不是指向vue实例了，所以这里必须用普通哈数\n      return this.tempcount + state.count\n    },\n    countplustempcount2 (state) {\n      return this.tempcount2 + state.count\n    } \n})\n```\n- 上面mapState()函数接收了一个对象。\n对象的第一个属性是string类型的，`count: \'count\'`, 这条语句映射出了this.count， 值等于store.state.count的值。\n\n对象的第二个属性是一个箭头函数，`name: (state) => state.name,`，映射 this.name 为 store.state.name的值。\n\n对象的第三个属性是一个string类型，`nameAlias: \'name\'`，映射 this.nameAlias 为 store.state.name的值， 和第一个属性的用法本质是一致的，不过这里映射出的计算属性的名称与 state 的子节点名称不同。\n\n对象的第四个属性是一个普通函数，普通函数和箭头函数的不同之处在于，普通函数中的this指向了vue实例，因为可以访问到当前组件的局部状态，比如this.tempcount。\n\n对象的第五个属性是一个普通函数，第五个和第四个的用法本质是一样的，只不过第五个用了ES6中对象的简化写法。\n\n- 上面的mapState函数的返回值是一个对象，我们可以看作是这样的\n\n```js\ncomputed:\n{ // 这个对象就是mapState的返回值\n    count () {\n       return this.$store.state.count\n    },\n    name () {\n        return this.$store.state.name\n    }\n    nameAlias () {\n        return this.$store.state.name\n    }\n    countplustempcount: function (state) {\n      return this.tempcount + this.$store.state.count\n    },\n    countplustempcount2 (state) {\n      return this.tempcount2 + this.$store.state.count\n    } \n}\n```\n把这个对象赋值给computed不就和原始的写法一样了吗，所以mapState起到了简化的作用。但是我们可以发现比起直接给computed赋值，这里少了tempCountPlusTempCount2这个计算属性。tempCountPlusTempCount2不是有vuex状态计算而来的，是根据组件内的局部状态计算来的。\n\n### mapState函数结合对象的扩展运算符运算符使用\n对象的扩展运算符（`...`）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。为什么要用扩展运算符呢，我们观察到上面直接将mapState函数的返回值赋给computed对象的话，那么computed中就只有对vuex状态的获取，而没有了当前组件的局部状态，比如tempCountPlusTempCount2就没地方放了，所以我们用扩展运算符。\n```js\nlet z = { a: 3, b: 4 };\nlet n = { ...z }; // 对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中\nn // { a: 3, b: 4 }\n```\n所以利用扩展运算符将下面mapState函数的返回值对象\n```js\ncomputed:{\n    ...mapState({\n        count: \'count\',  // string    映射 this.count 为 store.state.count的值\n        // 箭头函数可使代码更简练\n        name: (state) => state.name, // function   映射 this.name 为 store.state.name的值\n        nameAlias: \'name\', // string   映射 this.nameAlias 为 store.state.name的值\n        countplustempcount: function (state) { // 用普通函数this指向vue实例,但是在箭头函数中this就不是指向vue实例了，所以这里必须用普通哈数\n          return this.tempcount + state.count\n        },\n        countplustempcount2 (state) {\n          return this.tempcount2 + state.count\n        } \n    })\n}\n```\n上面的结果\n```js\ncomputed:{\n	count () {\n       return this.$store.state.count\n    },\n    name () {\n        return this.$store.state.name\n    }\n    nameAlias () {\n        return this.$store.state.name\n    }\n    countplustempcount: function (state) {\n      return this.tempcount + this.$store.state.count\n    },\n    countplustempcount2 (state) {\n      return this.tempcount2 + this.$store.state.count\n    } \n}\n```\n于是可以将组将内的计算属性和获取vuex状态的计算属性写在一起了。\n```js\ncomputed:{\n    tempCountPlusTempCount2() { \n          return this.tempcount+this.tempcount2\n    }, \n    ...mapState({\n        count: \'count\',  // string    映射 this.count 为 store.state.count的值\n        // 箭头函数可使代码更简练\n        name: (state) => state.name, // function   映射 this.name 为 store.state.name的值\n        nameAlias: \'name\', // string   映射 this.nameAlias 为 store.state.name的值\n        countplustempcount: function (state) { // 用普通函数this指向vue实例,但是在箭头函数中this就不是指向vue实例了，所以这里必须用普通哈数\n          return this.tempcount + state.count\n        },\n        countplustempcount2 (state) {\n          return this.tempcount2 + state.count\n        } \n    })\n}\n```\n这就是mapState的基本用法。\n\n### mapState函数接受一个数组\n当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 `mapState` 传一个字符串数组。\n```js\ncomputed: mapState([\n  // 映射 this.count 为 store.state.count\n  \'count\',\n  \'name\'\n])\n```\n上面的写法可以看作\n```js\ncomputed: {\n    count () {\n       return this.$store.state.count\n    },\n    name () {\n        return this.$store.state.name\n    }\n}\n```\n### 最终版的mapState\n```js\ncomputed: {\n    tempCountPlusTempCount2() { \n          return this.tempcount+this.tempcount2\n    }, \n    ...mapState([\'count\',\'name\']),\n    ...mapState({\n        nameAlias: \'name\', // string   映射 this.nameAlias 为 store.state.name的值\n        countplustempcount: function (state) { // 用普通函数this指向vue实例,但是在箭头函数中this就不是指向vue实例了，所以这里必须用普通哈数\n          return this.tempcount + state.count\n        },\n        countplustempcount2 (state) {\n          return this.tempcount2 + state.count\n        } \n    })\n}\n```\n\n\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 57, 1, '2020-12-26 15:44:36', '2021-8-30 08:57:03', 'https://blog.csdn.net/chenjie9230/article/details/108883055', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (153, 10000, 'IDEA中给Maven配置代理', 'IDEA中给Maven配置代理', '打开IDEA下的\nFile | Settings | Build, Execution, Deployment | Build Tools | Maven | Importing\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 6, 1, '2021-1-12 16:41:27', '2021-9-2 17:55:19', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (154, 10000, 'SpringBoot - 获取Get请求参数详解（附样例：非空、默认值、数组、对象）', '利用&emsp;Spring&emsp;Boot&emsp;来制作&emsp;Web&emsp;应用，就必定会涉及到前端与后台之间互相传递参数。下面演示&emsp;Controller&emsp;如何接收以&emsp;GET&emsp;方式传递过来的参数。', '利用 Spring Boot 来制作 Web 应用，就必定会涉及到前端与后台之间互相传递参数。下面演示 Controller 如何接收以 GET 方式传递过来的参数。\n\n> ### 一、参数直接在路径中\n\n（1）假设请求地址是如下这种 **`RESTful`** 风格，`hangge` 这个参数值直接放在路径里面：\n```js\nhttp://localhost:8080/hello/hangge\n```\n（2）Controller 可以这么获取该参数： \n```js\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.GetMapping;\n \n@RestController\npublic class HelloController {\n    @GetMapping(\"/hello/{name}\")\n    public String hello(@PathVariable(\"name\") String name) {\n        return \"获取到的name是：\" + name;\n    }\n}\n```\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906214827image.png)\n> ### 二、参数跟在 ? 号后面\n#### 1，获取参数的基本方法\n（1）假设请求地址是如下这种传统方式，参数跟在问号后面：\n```js\nhttp://localhost:8080/hello?name=hangge\n```\n（2）Controller 可以这么获取该参数：\n```js\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.GetMapping;\n \n@RestController\npublic class HelloController {\n    @GetMapping(\"/hello\")\n    public String hello(@RequestParam(\"name\") String name) {\n        return \"获取到的name是：\" + name;\n    }\n}\n```\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906214945image.png)\n#### 2，参数没有传递的情况\n（1）如果没有传递参数 Controller 将会报错，我们可以使用 required = false 标注参数是非必须的。\n```js\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.GetMapping;\n \n@RestController\npublic class HelloController {\n    @GetMapping(\"/hello\")\n    public String hello(@RequestParam(name = \"name\", required = false) String name) {\n        return \"获取到的name是：\" + name;\n    }\n}\n```\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906215052image.png)\n\n（2）或者可以指定个默认值，当没有传递参数时自动使用默认值：\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.GetMapping;\n \n@RestController\npublic class HelloController {\n    @GetMapping(\"/hello\")\n    public String hello(@RequestParam(name = \"name\", defaultValue = \"xxx\") String name) {\n        return \"获取到的name是：\" + name;\n    }\n}\n```\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906215112image.png)\n\n#### 3，使用 map 来接收参数\n（1）Controller 还可以直接使用 map 来接收所有的请求参数：\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.GetMapping;\n \nimport java.util.Map;\n \n@RestController\npublic class HelloController {\n    @GetMapping(\"/hello\")\n    public String hello(@RequestParam Map<String, Object> params) {\n        return \"name：\" + params.get(\"name\") + \"<br>age：\" + params.get(\"age\");\n    }\n}\n```\n（2）下面是一个简单的测试样例：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906215142image.png)\n \n#### 4，接收一个数组\n（1）假设请求地址是如下这种，有多个同名参数：\n```java\nhttp://localhost:8080/hello?name=hangge&name=google\n```\n（2）我们可以定义一个数组类型的参数来接收：\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.GetMapping;\n \n@RestController\npublic class HelloController {\n    @GetMapping(\"/hello\")\n    public String hello(@RequestParam(\"name\") String[] names) {\n        String result = \"\";\n        for(String name:names){\n            result += name + \"<br>\";\n        }\n        return result;\n    }\n}\n```\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906215216image.png)\n> ### 附：使用对象来接收参数\n1，基本用法\n（1）如果一个 get 请求的参数太多，我们构造一个对象来简化参数的接收方式：\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.GetMapping;\n \n@RestController\npublic class HelloController {\n    @GetMapping(\"/hello\")\n    public String hello(User user) {\n        return \"name：\" + user.getName() + \"<br> age：\" + user.getAge();\n    }\n}\n```\n（2）User 类的定义如下，到时可以直接将多个参数通过 getter、setter 方法注入到对象中去：\n```java\npackage com.example.demo;\n \npublic class User {\n    private String name;\n    private Integer age;\n \n    public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n \n    public Integer getAge() {\n        return age;\n    }\n \n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n```\n（3）下面是一个简单的测试样例：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906215348image.png)\n\n（4）如果传递的参数有前缀，且前缀与接收实体类的名称相同，那么参数也是可以正常传递的：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906215403image.png)\n\n2，指定参数前缀\n（1）如果传递的参数有前缀，且前缀与接收实体类的名称不同相，那么参数无法正常传递：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906215413image.png)\n\n（2）我们可以结合 @InitBinder 解决这个问题，通过参数预处理来指定使用的前缀为 u.\n> 除了在 Controller 里单独定义预处理方法外，我们还可以通过 @ControllerAdvice 结合 @InitBinder 来定义全局的参数预处理方法，方便各个 Controller 使用。具体做法参考我之前的文章：\nSpringBoot - @ControllerAdvice的使用详解3（请求参数预处理 @InitBinder）\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.*;\n \n@RestController\npublic class HelloController {\n    @GetMapping(\"/hello\")\n    public String hello(@ModelAttribute(\"u\") User user) {\n        return \"name：\" + user.getName() + \"<br> age：\" + user.getAge();\n    }\n \n    @InitBinder(\"u\")\n    private void initBinder(WebDataBinder binder) {\n        binder.setFieldDefaultPrefix(\"u.\");\n    }\n}\n```\n（3）重启程序可以看到参数以及成功接收了：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906215535image.png)\n\n3，构造多个对象来接收参数\n（1）如果一个 get 请求的参数分属不同的对象，也可以使用多个对象来接收参数：\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.RestController;\nimport org.springframework.web.bind.annotation.GetMapping;\n \n@RestController\npublic class HelloController {\n    @GetMapping(\"/hello\")\n    public String hello(User user, Phone phone) {\n        return \"name：\" + user.getName() + \"<br> age：\" + user.getAge()\n                + \"<br> number：\" + phone.getNumber();\n    }\n}\n```\n（2）新增的 Phone 类定义如下：\n```\npackage com.example.demo;\n \npublic class Phone {\n    private String number;\n \n    public String getNumber() {\n        return number;\n    }\n \n    public void setNumber(String number) {\n        this.number = number;\n    }\n}\n```\n（3）下面是一个简单的测试样例：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906215609image.png)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/spring.png', 0, 0, 21, 1, '2021-1-12 16:57:19', '2021-9-7 16:10:04', 'https://www.hangge.com/blog/cache/detail_2484.html', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (155, 10000, 'SpringBoot - 获取POST请求参数详解（附样例：表单数据、json、数组、对象）', '在前文中我介绍了&emsp;Controller&emsp;如何接收通过&emsp;GET&emsp;方式传递过来的参数（点击查看），下面接着演示如何接收通过&emsp;POST&emsp;方式传递过来的参数。', '在前文中我介绍了 Controller 如何接收通过 GET 方式传递过来的参数（[点击查看](https://www.hangge.com/blog/cache/detail_2484.html)），下面接着演示如何接收通过 POST 方式传递过来的参数。\n>### 一、接收 Form 表单数据\n#### 1，基本的接收方法\n（1）下面样例 Controller 接收 form-data 格式的 POST 数据：\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n \n@RestController\npublic class HelloController {\n    @PostMapping(\"/hello\")\n    public String hello(@RequestParam(\"name\") String name,\n                        @RequestParam(\"age\") Integer age) {\n        return \"name：\" + name + \"\\nage：\" + age;\n    }\n}\n```\n（2）下面是一个简单的测试样例：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906220121image.png)\n\n#### 2，参数没有传递的情况\n（1）如果没有传递参数 Controller 将会报错，这个同样有如下两种解决办法：\n- 使用 required = false 标注参数是非必须的。\n- 使用 defaultValue 给参数指定个默认值。\n\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n \n@RestController\npublic class HelloController {\n    @PostMapping(\"/hello\")\n    public String hello(@RequestParam(name = \"name\", defaultValue = \"xxx\") String name,\n                        @RequestParam(name = \"age\", required = false) Integer age) {\n        return \"name：\" + name + \"\\nage：\" + age;\n    }\n}\n```\n\n（2）下面是一个简单的测试样例：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906222456image.png)\n\n#### 3，使用 map 来接收参数\n（1）Controller 还可以直接使用 map 来接收所有的请求参数：\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n \nimport java.util.Map;\n \n@RestController\npublic class HelloController {\n    @PostMapping(\"/hello\")\n    public String hello(@RequestParam Map<String,Object> params) {\n        return \"name：\" + params.get(\"name\") + \"\\nage：\" + params.get(\"age\");\n    }\n}\n```\n（2）下面是一个简单的测试样例：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906222711image.png)\n\n#### 4，接收一个数组\n（1）表单中有多个同名参数，Controller 这边可以定义一个数据进行接收：\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n \nimport java.util.Map;\n \n@RestController\npublic class HelloController {\n    @PostMapping(\"/hello\")\n    public String hello(@RequestParam(\"name\") String[] names) {\n        String result = \"\";\n        for(String name:names){\n            result += name + \"\\n\";\n        }\n        return result;\n    }\n}\n```\n（2）下面是一个简单的测试样例：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906222731image.png)\n\n#### 5，使用对象来接收参数\n（1）如果一个 post 请求的参数太多，我们构造一个对象来简化参数的接收方式：\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RestController;\n \n@RestController\npublic class HelloController {\n    @PostMapping(\"/hello\")\n    public String hello(User user) {\n        return \"name：\" + user.getName() + \"\\nage：\" + user.getAge();\n    }\n}\n```\n（2）User 类的定义如下，到时可以直接将多个参数通过 getter、setter 方法注入到对象中去：\n```java\npackage com.example.demo;\n \npublic class User {\n    private String name;\n    private Integer age;\n \n    public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n \n    public Integer getAge() {\n        return age;\n    }\n \n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n```\n（3）下面是一个简单的测试样例：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906222825image.png)\n\n（4）如果传递的参数有前缀，且前缀与接收实体类的名称相同，那么参数也是可以正常传递的：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906222847image.png)\n\n（5）如果一个 get 请求的参数分属不同的对象，也可以使用多个对象来接收参数：\n```java \npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RestController;\n \n@RestController\npublic class HelloController {\n    @PostMapping(\"/hello\")\n    public String hello(User user, Phone phone) {\n        return \"name：\" + user.getName() + \"\\nage：\" + user.getAge()\n                + \"\\nnumber：\" + phone.getNumber();\n    }\n}\n```\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906222931image.png)\n\n#### 6，使用对象接收时指定参数前缀\n（1）如果传递的参数有前缀，且前缀与接收实体类的名称不同相，那么参数无法正常传递：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906222953image.png)\n\n（2）我们可以结合 @InitBinder 解决这个问题，通过参数预处理来指定使用的前缀为 u.\n    除了在 Controller 里单独定义预处理方法外，我们还可以通过 @ControllerAdvice 结合 @InitBinder 来定义全局的参数预处理方法，方便各个 Controller 使用。具体做法参考我之前的文章：\nSpringBoot - @ControllerAdvice的使用详解3（请求参数预处理 @InitBinder）\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.*;\n \n@RestController\npublic class HelloController {\n    @PostMapping(\"/hello\")\n    public String hello(@ModelAttribute(\"u\") User user) {\n        return \"name：\" + user.getName() + \"\\nage：\" + user.getAge();\n    }\n \n    @InitBinder(\"u\")\n    private void initBinder(WebDataBinder binder) {\n        binder.setFieldDefaultPrefix(\"u.\");\n    }\n}\n````\n（3）重启程序再次发送请求，可以看到参数已经成功接收了：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906223021image.png)\n\n>### 二、接收字符串文本数据\n（1）如果传递过来的是 Text 文本，我们可以通过 HttpServletRequest 获取输入流从而读取文本内容。\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RestController;\n \nimport javax.servlet.ServletInputStream;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n \n@RestController\npublic class HelloController {\n    @PostMapping(\"/hello\")\n    public String hello(HttpServletRequest request) {\n        ServletInputStream is = null;\n        try {\n            is = request.getInputStream();\n            StringBuilder sb = new StringBuilder();\n            byte[] buf = new byte[1024];\n            int len = 0;\n            while ((len = is.read(buf)) != -1) {\n                sb.append(new String(buf, 0, len));\n            }\n            System.out.println(sb.toString());\n            return \"获取到的文本内容为：\" + sb.toString();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (is != null) {\n                    is.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return null;\n    }\n}\n```\n（2）下面是一个简单的测试样例：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906223052image.png)\n\n>### 三、接收 JSON 数据\n1，使用 Map 来接收数据\n（1）如果把 json 作为参数传递，我们可以使用 @requestbody 接收参数，将数据转换 Map：\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\n \nimport java.util.Map;\n \n@RestController\npublic class HelloController {\n    @PostMapping(\"/hello\")\n    public String hello(@RequestBody Map params) {\n        return \"name：\" + params.get(\"name\") + \"\\n age：\" + params.get(\"age\");\n    }\n}\n```\n（2）下面是一个简单的测试样例：\n\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906223124image.png)\n\n2，使用 Bean 对象来接收数据\n（1）如果把 json 作为参数传递，我们可以使用 @requestbody 接收参数，将数据直接转换成对象：\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\n \n@RestController\npublic class HelloController {\n    @PostMapping(\"/hello\")\n    public String hello(@RequestBody User user){\n        return user.getName() + \" \" + user.getAge();\n    }\n}\n```\n（2）User 类定义如下：\n```java\npackage com.example.demo;\n \npublic class User {\n    private String name;\n    private Integer age;\n \n    public String getName() {\n        return name;\n    }\n \n    public void setName(String name) {\n        this.name = name;\n    }\n \n    public Integer getAge() {\n        return age;\n    }\n \n    public void setAge(Integer age) {\n        this.age = age;\n    }\n}\n```\n（3）下面是一个简单的测试样例：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906223202image.png)\n\n（4）如果传递的 JOSN 数据是一个数组也是可以的，Controller 做如下修改：\n```java\npackage com.example.demo;\n \nimport org.springframework.web.bind.annotation.PostMapping;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\n \nimport java.util.List;\n \n@RestController\npublic class HelloController {\n    @PostMapping(\"/hello\")\n    public String hello(@RequestBody List<User> users){\n        String result = \"\";\n        for(User user:users){\n            result += user.getName() + \" \" + user.getAge() + \"\\n\";\n        }\n        return result;\n    }\n}\n```\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/06/20210906223231image.png)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/spring.png', 0, 0, 30, 1, '2021-1-12 17:03:32', '2021-11-18 20:29:45', 'https://www.hangge.com/blog/cache/detail_2485.html', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (156, 10000, 'Axios中默认的content-type', 'Axios中默认的content-type为application/json，后端接口如何设计？', 'Axios中默认的`content-type`为`application/json`，后端接口如何设计？\n>#### GET请求\n\n对于GET请求来说，因为没有`HttpEntity`，所以`@RequestBody`并不适用,参数跟随在`url`的尾部，不会用到`RequestBody`请求体。\n即使在GET请求中在请求体中写入数据也不会被接收，GET请求只接收请求`url`的`QueryString`中的数据\n\n>#### Post请求\n\n对于Post请求来说，通过HttpEntity传递的参数，如果存在json类型的数据，要用`@RequestBody`接收，其它数据可以使用`@RequestParam`接收。\n\n#### axios在发送post请求时会根据参数的类型决定content-type的值\n1. 默认情况\n\n```js\naxios({\n	method: \'post\',\n	url: \'/user/login2\',\n	data:{\n        	username: \'admin\',\n        	password: \'admin\'\n     	},\n})\n// 这时content-type的值为: application/json;charset=UTF-8\n// 并且这种形式在main.js文件中使用: axios.defaults.headers.post[\'Content-Type\'] = \'application/x-www-form-urlencoded\';无效\n```\n2.qs转化\n\n```js\naxios({\n	method: \'post\',\n	url: \'/user/login2\',\n	data:qs.stringify({\n        	username: \'admin\',\n        	password: \'admin\'\n     	}),\n})\n// 这时content-type的值为：application/x-www-form-urlencoded\n// 并且这种形式在main.js文件中使用: axios.defaults.headers.post[\'Content-Type\'] = \'application/x-www-form-urlencoded\';有效\n```\n\n#### 如果在post下使用params方式传递参数，参数会跟随在`url`的尾部。\n```js\naxios({\n	method: \'post\',\n	url: \'/user/login2\',\n	params:{\n        	username: \'admin\',\n        	password: \'admin\'\n     	},\n})\n// 这时url为：http://localhost:8080/api/user/login2?username=admin&password=admin\n```\n参考：\nhttps://blog.csdn.net/weixin_38004638/article/details/99655322', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/spring.png', 0, 0, 39, 1, '2021-1-12 17:17:56', '2021-9-8 12:45:50', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (157, 10000, '@PathVariable与@RequestParam与@RequestBody', '@PathVariable与@RequestParam与@RequestBody的用法与区别', 'Springboot在响应请求时，通常会用`@PathVariable`、`@RequestParam`、`@RequestBody`这三个注解来接收参数。三者之间有什么区别呢? 它们的用法是什么？还有其它获取数据的方式吗？本文让我们来详细探讨三者之间的差异和具体用法。\n>### 1.@PathVariable\n\n顾名思义，它的意思是**路径变量**。但是这里要注意是路径变量，而不是`queryString`中的变量，这种方式无关请求方式，Get和Post都能使用，只要是路径中的变量就能获取：\n```java\n@RequestMapping(\"/testRequest/{pageSize}\")\npublic int test(@PathVariable(name = \"pageSize\") int pageSize) {\n    //注意@PathVariable(value = \"pageSize\")与@PathVariable(name= \"pageSize\")效果一样\n    //name和value都能获取参数\n    return pageSize;\n}\n```\n\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/08/20210908213942image.png)\n>### 注意\n接下来我们来学习`@RequestParam`与`@RequestBody`，在我们学习这两个注解之前，我希望你能了解Http请求中`Content-Type`的含义以及常用的四种类型之间的区别。网上的教程太多了，这里不再赘述，如果你不了解它的含义，那么你可以参考一下这篇文章：[Content-Type四种常见取值](https://www.cnblogs.com/fighter007/p/10917026.html)\n\n现在，我们假设你已经对`Content-Type`的含义有所了解，接下来让我们来学习`@RequestParam`与`@RequestBody`\n\n>### 2.@RequestParam\n\n`@RequestParam`也叫请求参数，接收的参数是来自HTTP请求体或请求url的QueryString中，它可以用于Get方法，也可以用于Post方法，但是我们要注意的是，在`Content-Type`为`application/json `，他就不适用了，这个时候，我们只能用`@RequestBody`。\n#### 2.1 Get方法时\n```java\n    @GetMapping(\"/testRequest\")\n    public String test2(@RequestParam(value = \"name\") String user) {\n//    public String test2(@RequestParam String name) {\n        /*这边特意写成 @RequestParam(value = \"name\") String user 是为了告诉大家我们在配置了value = \"name\"\n          之后就可以把变量名声明为其它的名称如“user”,如果你不是用value = \"name\",那你只能把变量声明成请求中的同名参数\n          在这个例子中就是name\n        */\n        return user;\n    }\n```\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/08/20210908220517image.png)\n\n**注意：虽然`Get`是可以携带请求体的，但是不推荐这样使用**，并且如果Body中有和params重复的字段，Body会将其覆盖。\n原因参考这两篇文章\n[关于在GET请求中使用body](https://blog.csdn.net/HermitSun/article/details/89889743)\n[谁说 HTTP GET 就不能通过 Body 来发送数据呢？](https://yanbin.blog/why-http-get-cannot-sent-data-with-reuqest-body/#more-8193)\n\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/08/20210908221948image.png)\n#### 2.2 Post方法时\n在Post请求中，我们只能用`@RequestParam`来接收在`Content-Type`不为`application/json`的请求，换句话说，如果`Content-Type`为`application/json`，我们只能用`@RequestBody`而不能用`@RequestParam`。\n```java\n    @RequestMapping(\"/testRequest2\")\n    public String test3(@RequestParam Map<String, Object> map) {\n        String name = map.get(\"name\").toString();\n        return name;\n    }\n```\n1.`Content-Type`为`multipart/form-data `\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/08/20210908222130image.png)\n2.`Content-Type`为`application/x-www-form-urlencoded`\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/08/20210908222147image.png)\n3.`Content-Type`为`application/json`,报错了，说明我们不能用`@RequestParam`来接收`Content-Type`为`application/json`的请求。\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/08/20210908222256image.png)\n>### 3.@RequestBody\n\n`@RequestBody`用来接收`Content-Type`为`application/json`的请求。\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/08/20210908222641image.png)\n\n**注意：`@RequestBody`也能和`@RequestParam`结合使用，**`@RequestBody`用于获取JSON字符串部分而`@RequestParam`用于获取queryString部分。\n```java\n    @RequestMapping(\"/testRequest5\")\n    public String test5(@RequestBody Map<String, Object> map, @RequestParam Map<String, Object> map2) {\n        String name = map.get(\"name\").toString();\n        String age = map2.get(\"age\").toString();\n        return \"name:\" + name + \", age:\" + age;\n    }\n```\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/08/20210908234633image.png)\n>### 4.其它方式 HttpServletRequest request\n\nHttpServletRequest的相关信息请查看[HttpServletRequest详解](https://blog.csdn.net/wwq0813/article/details/90256058)\n\n```java\n    @RequestMapping(\"/testRequest4\")\n    public String articleIndex(HttpServletRequest request) {\n        String name = request.getParameter(\"name\");\n        return name;\n    }\n```\n#### 4.1 Get方式\nbody中的数据将params中的数据覆盖，所以为`admin3`\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/08/20210908231128image.png) \n#### 4.1 Post方式\n1. `Content-Type`为`multipart/form-data`\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/08/20210908231421image.png)\n2. `Content-Type`为`application/x-www-form-urlencoded `\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/08/20210908231516image.png)\n3. `Content-Type`为`application/json`,没有报错，但是数据无法被接收。后端输出null\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/08/20210908231710image.png)\n\n总结：\n`@PathVariable`：用于获取路径中的参数，Get和Post都可以使用。\n`@RequestParam`：用于获取HTTP请求体或请求url的QueryString中参数，Get和Post都可以使用，但是要注意在`Content-Type`为`application/json`的请求中不能使用。\n`@RequestBody`：用于`Content-Type`为`application/json`的请求。\n`HttpServletRequest `:用法和`@RequestParam`类似，HttpServletRequest对象代表客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP请求头中的所有信息都封装在这个对象中，通过这个对象提供的方法，可以获得客户端请求的所有信息。', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/spring.png', 0, 0, 90, 1, '2021-1-16 11:12:36', '2021-9-23 23:37:21', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (158, 10000, '给Maven配置阿里镜像和添加代理', '给Maven配置阿里镜像和添加代理', '>### 1. Maven配置阿里云镜像\n\n以IDEA自带的Maven为例\n1. 打开IDEA的安装目录，找到plugins->maven->lib->maven3->conf->settings.xml\n2. 添加\n```\n  <mirrors>\n      <mirror>\n      	<id>alimaven</id>\n      	<name>aliyun maven</name>\n      	<url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n      	<mirrorOf>central</mirrorOf>       \n      </mirror>\n  </mirrors>\n```\n\n>### 2. Maven配置代理，步骤同上\n\n以IDEA自带的Maven为例\n1. 打开IDEA的安装目录，找到plugins->maven->lib->maven3->conf->settings.xml\n2. 添加, 注意IP和端口改成代理的IP地址和端口。\n```\n  <proxies>\n    <proxy>\n      	<id>optional</id>    \n      	<active>true</active>\n      	<protocol>http</protocol>\n      	<host>192.168.69.157</host>\n      	<port>808</port>\n    </proxy>\n  </proxies>\n```', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 16, 1, '2021-1-16 11:13:55', '2021-9-9 16:41:37', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (159, 10000, '阿里云OSS前端直传（使用STS临时访问凭证访问OSS)使用', '在客户端通过JavaScript代码完成签名，无需过多配置，即可实现直传，非常方便。但是客户端通过JavaScript把AccesssKey&emsp;ID和AccessKey&emsp;Secret写在代码里面有泄露的风险，强烈建议使用服务端签名后直传或者STS临时授权访问OSS。', '[在客户端通过JavaScript代码完成签名，无需过多配置，即可实现直传，非常方便。但是客户端通过JavaScript把AccesssKey ID和AccessKey Secret写在代码里面有泄露的风险，强烈建议使用服务端签名后直传或者STS临时授权访问OSS。](https://help.aliyun.com/document_detail/31925.html)\n\n所以我们使用使用STS临时访问凭证访问OSS来访问OSS，基本原理是前端从后端接口请求STS临时访问凭证，然后再从前端直接上传图片，无需把图片传递到后端，节省了服务器的带宽。\n### 1.后端部分SpringBoot\n查看官方的[这篇文章](这篇文章)，完成步骤1-4\n\n\n\n完成步骤1-4后，你应该获得了以下信息：\n\n```js\n//    用户登录名称 RamOss@11111111111111111111.onaliyun.com\n//    AccessKey ID xxxxxxxxxxxxx\n//    AccessKey Secret xxxxxxxxxxxxxx\n//    acs:ram::xxxxxxxxxx:role/ramosstest\n```\n\n\n\n步骤5:\n\n添加pom.xml依赖\n\n```xml\n        <dependency>\n            <groupId>com.aliyun</groupId>\n            <artifactId>aliyun-java-sdk-core</artifactId>\n            <version>4.0.8</version>\n        </dependency>\n        <dependency>\n            <groupId>com.aliyun</groupId>\n            <artifactId>aliyun-java-sdk-sts</artifactId>\n            <version>3.0.0</version>\n        </dependency>\n```\n\n\n\n在Spring boot中新建接口\n\n```java\nimport com.aliyuncs.DefaultAcsClient;\nimport com.aliyuncs.exceptions.ClientException;\nimport com.aliyuncs.http.MethodType;\nimport com.aliyuncs.profile.DefaultProfile;\nimport com.aliyuncs.profile.IClientProfile;\nimport com.aliyuncs.sts.model.v20150401.AssumeRoleRequest;\nimport com.aliyuncs.sts.model.v20150401.AssumeRoleResponse;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/sts\")\npublic class StsController {\n\n//    用户登录名称 RamOss@1522211879603568.onaliyun.com\n//    AccessKey ID LTAI5tQ6oxmqs9vPvgYkkzsh\n//    AccessKey Secret hUSWofhYLsF7b1hPTQCgAeOtJqFmUR\n//    acs:ram::1522211879603568:role/ramosstest\n\n    @RequestMapping(\"/getSts\")\n    public AssumeRoleResponse.Credentials sts() {\n        // STS接入地址，例如sts.cn-hangzhou.aliyuncs.com。\n        String endpoint = \"sts.cn-beijing.aliyuncs.com\";\n        // 填写步骤1生成的访问密钥AccessKey ID和AccessKey Secret。\n        String AccessKeyId = \"XXXXXXXXXXXX\";\n        String accessKeySecret = \"XXXXXXXXXXXXX\";\n        // 填写步骤3获取的角色ARN。\n        String roleArn = \"acs:ram::XXXXXXXXXXXX:role/ramosstest\";\n        // 自定义角色会话名称，用来区分不同的令牌，例如可填写为SessionTest。\n        String roleSessionName = \"SessionTest\";\n        // 以下Policy用于限制仅允许使用临时访问凭证向目标存储空间examplebucket上传文件。\n        // 临时访问凭证最后获得的权限是步骤4设置的角色权限和该Policy设置权限的交集，即仅允许将文件上传至目标存储空间examplebucket下的exampledir目录。\n        String policy = \"{\\n\" +\n                \"    \\\"Version\\\": \\\"1\\\", \\n\" +\n                \"    \\\"Statement\\\": [\\n\" +\n                \"        {\\n\" +\n                \"            \\\"Action\\\": [\\n\" +\n                \"                \\\"oss:PutObject\\\"\\n\" +\n                \"            ], \\n\" +\n                \"            \\\"Resource\\\": [\\n\" +\n                \"                \\\"acs:oss:*:*:examplebucket/*\\\" \\n\" +\n                \"            ], \\n\" +\n                \"            \\\"Effect\\\": \\\"Allow\\\"\\n\" +\n                \"        }\\n\" +\n                \"    ]\\n\" +\n                \"}\";\n        try {\n            // regionId表示RAM的地域ID。以华东1（杭州）地域为例，regionID填写为cn-hangzhou。也可以保留默认值，默认值为空字符串（\"\"）。\n            String regionId = \"\";\n            // 添加endpoint。\n            DefaultProfile.addEndpoint(\"\", \"\", \"Sts\", endpoint);\n            // 构造default profile。\n            IClientProfile profile = DefaultProfile.getProfile(regionId, AccessKeyId, accessKeySecret);\n            // 构造client。\n            DefaultAcsClient client = new DefaultAcsClient(profile);\n            final AssumeRoleRequest request = new AssumeRoleRequest();\n            request.setMethod(MethodType.POST);\n            request.setRoleArn(roleArn);\n            request.setRoleSessionName(roleSessionName);\n            request.setPolicy(policy); // 如果policy为空，则用户将获得该角色下所有权限。\n            request.setDurationSeconds(3600L); // 设置临时访问凭证的有效时间为3600秒。\n            final AssumeRoleResponse response = client.getAcsResponse(request);\n\n            System.out.println(\"Expiration: \" + response.getCredentials().getExpiration());\n            System.out.println(\"Access Key Id: \" + response.getCredentials().getAccessKeyId());\n            System.out.println(\"Access Key Secret: \" + response.getCredentials().getAccessKeySecret());\n            System.out.println(\"Security Token: \" + response.getCredentials().getSecurityToken());\n            System.out.println(\"RequestId: \" + response.getRequestId());\n            return response.getCredentials();\n        } catch (ClientException e) {\n            System.out.println(\"Failed：\");\n            System.out.println(\"Error code: \" + e.getErrCode());\n            System.out.println(\"Error message: \" + e.getErrMsg());\n            System.out.println(\"RequestId: \" + e.getRequestId());\n        }\n        return null;\n    }\n}\n```\n这里用postman测试一下，返回了STS临时访问凭证数据，代表我们顺利的完成了第一步。\n\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/25/20210925175416image.png)\n\n### 2.前端部分JavaScript\n新建文件如：oss.js\n\n```js\nimport OSS from \"ali-oss\";\nimport axios from \'axios\'\n\nasync function uploadFile(name, file) {\n  let result = (await axios.get(\'/sts/getSts\')).data; //这里是后端的接口\n  var client = new OSS({\n    region: \'oss-cn-beijing\',\n    accessKeyId: result.accessKeyId,\n    accessKeySecret: result.accessKeySecret,\n    bucket: \'youyu-source\',\n    stsToken: result.securityToken\n  });\n\n  //获取文件信息\n  let res = await client.multipartUpload(name, file)\n  if (res) {\n    var str = res.res.requestUrls[0]\n    return str.split(\"?\")[0]\n  } else {\n    console.log(res)\n  }\n}\n\nfunction createPath(rootDir, fileName) {\n  let first = new Date().Format(\'yyyyMM\');\n  let second = new Date().Format(\'dd\');\n  let third = new Date().Format(\'yyyyMMddhhmmss\');\n  let path = `/${rootDir}/${first}/${second}/${third}${fileName}`;\n  return path;\n}\n\nexport {uploadFile, createPath};\n```\n\n\n\n然后我们可以在需要上传图片的地方这样用（我是结合elementui+mavon-editor的）\n\n```\nasync imgAdd(pos, $file) {\n        let m = this.$message({\n          message: \'图片上传中，请稍后\',\n          duration: 0,\n          iconClass: \'el-icon-loading\'\n        });\n        \n        this.img_file[pos] = $file;\n        //核心代码就这两句\n        let path = createPath(\'blogImages\',$file.name)\n        let resultUrl = await uploadFile(path, $file)\n        // 文件上传后的url样例：\n        // https://your-bucket-name.oss-cn-beijing.aliyuncs.com/blogImages/202109/25/20210925175416image.png\n\n        m.close()\n        if (resultUrl !== \'\') {\n          this.$message({\n            message: \'图片上传成功!\',\n            type: \'success\'\n          });\n          this.$refs.md.$img2Url(pos, resultUrl)      //阿里云oss存储版本\n        } else {\n          this.$message.error(\'图片上传失败\');\n        }\n      },\n```\n\n### 3.遇到的问题\n报错：Error: Please set the etag of expose-headers in OSS\n解决方法：https://blog.csdn.net/qq_41656943/article/details/107003163\n设置地址在OSS控制台 > (点进你的Bucket中) > 左侧权限管理 > 最下方跨域设置\n\n\n### 参考链接\n\nhttps://www.cnblogs.com/ggband/p/10218851.html\nhttp://www.zyiz.net/tech/detail-100282.html', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/spring.png', 0, 0, 22, 1, '2021-1-16 18:22:34', '2021-9-25 19:54:23', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (160, 10000, '给网站的博客添加目录', '给网站的博客添加目录', '给网站增加一个目录功能，在文章内容较多的时候非常有用。\n先看效果：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/25/20210925202259image.png)\n\n具体实现使用了这个插件：[katalog](https://github.com/KELEN/katelog)\n\n### 1.安装\n```js\nnpm i katelog -S\n```\n\n### 2.使用：\n```js\n<template>\n  <div class=\"catalogue-container\">\n    <el-popover\n      placement=\"left-start\"\n      title=\"目录\"\n      width=\"280\"\n      trigger=\"hover\">\n<!--      <div class=\"catalogue-title\">目录</div>-->\n      <div class=\"catalogue-list\" id=\"catalogueList\"></div>\n      <i slot=\"reference\" class=\"cate-icon el-icon-s-unfold\"></i>\n    </el-popover>\n  </div>\n</template>\n\n<script>\n  import katelog from \"katelog\";\n\n  export default {\n    name: \"Catalogue\",\n    methods: {\n      createCatalogue(content) {\n        this.$nextTick(() => {\n          let cate = new katelog({\n            contentEl: content,\n            catelogEl: \'catalogueList\',\n            linkClass: \'catalogue-link\',\n            linkActiveClass: \'catalogue-link-active\',\n            supplyTop: 60,\n            selector: [\'h1\', \'h2\', \'h3\', \'h4\', \'h5\', \'h6\'],\n            // active: function (el) {\n            //   console.log(el);\n            // }\n          });\n          // cate.rebuild();\n        })\n      }\n    }\n  }\n</script>\n\n<style lang=\"scss\" scoped>\n\n  .catalogue-container {\n    position: fixed;\n    top: 100px;\n    right: 20px;\n    z-index: 10;\n    height: 44px;\n    width: 44px;\n    border-radius: 44px;\n    font-size: 24px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    color: #42b983;\n    box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1)\n  }\n\n  .cate-icon{\n    cursor: pointer;\n  }\n\n  /*.catalogue-title {*/\n  /*  font-size: 20px;*/\n  /*}*/\n\n\n</style>\n\n<style lang=\"scss\">\n  .catalogue-list {\n    /*color: cadetblue;*/\n    max-height: 400px;\n    max-width: 300px;\n    overflow: scroll;\n    text-overflow: ellipsis;\n    white-space: nowrap;\n\n    .catalogue-link {\n      overflow: hidden;\n      text-overflow: ellipsis;\n      white-space: nowrap;\n    }\n\n    .catalogue-link-active {\n      border-left: solid 3px #42b983;\n      font-weight: bold;\n      color: #42b983;\n    }\n\n    li {\n      cursor: pointer;\n      div {\n        margin: 5px 0;\n        padding-left: 6px;\n      }\n    }\n\n    ul {\n      list-style: none;\n      ul {\n        margin-left: 20px;\n      }\n    }\n  }\n</style>\n\n```', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/202102/03/20210203103627banner2.jpg', 0, 0, 31, 1, '2021-2-2 22:10:31', '2021-9-25 20:26:12', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (162, 10000, '请求接口是参数的位置不同，参数的标识有什么区别？', '不同请求方式下参数所携带的方式区别', '我们在发送接口请求的时候通常有Get和Post两种方式，那么他们在携带参数时是怎么表现的呢？\n### 1.在Url后携带参数进行请求\n在Url后携带参数进行请求的携带方式为（此类型适用于Post和Get方式）：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202110/25/20211025140326image.png)\n### 2.在Post请求中使用Content-Type: application/x-www-form-urlencoded;charset=UTF-8请求\n在Post请求中使用Content-Type: application/x-www-form-urlencoded;charset=UTF-8请求时参数的携带方式为：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202110/25/20211025140552image.png)\n### 3.在Post请求中使用content-type: application/json;charset=UTF-8请求\n3.在Post请求中使用content-type: application/json;charset=UTF-8请求，参数的携带方式为：\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202110/25/20211025141402image.png)\n### 4.在Post请求中使用content-type: multipart/form-data;请求，参数的携带方式为：\n![csdnimg](https://img-blog.csdnimg.cn/20190620103028730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1ZV95YW5hbg==,size_16,color_FFFFFF,t_70)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 17, 1, '2021-2-7 09:23:09', '2021-11-17 13:53:10', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (163, 10000, '小小的植物开了这么多花', '没想到一颗小小的植物开了这么多花', '![image.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202102/07/20210207093138image.jpg)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202102/07/20210207093138image.jpg', 0, 0, 21, 1, '2021-2-7 09:32:20', '2022-3-8 10:02:20', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (164, 10000, '后端接口使用对象作为请求参数时，前端如何传递参数', '后端接口使用对象作为请求参数时，前端如何传递参数', '如有下面四个接口\n```js\n@RestController\n@RequestMapping(\"/user\")\npublic class UserController {\n    @RequestMapping(\"/test\")\n    public Test getUser(@RequestParam Test test) {\n        return test;\n    }\n\n    @RequestMapping(\"/test2\")\n    public Test getUser2(@RequestBody Test test) {\n        return test;\n    }\n\n    @RequestMapping(\"/test3\")\n    public Test getUser3(Test test) {\n        return test;\n    }\n\n    @RequestMapping(\"/test4\")\n    public Test getUser4(@ModelAttribute Test test) {\n        return test;\n    }\n}\n```\n\n1.请求第一个接口\n```js\n貌似请求不到\n```\n2.请求第二个接口\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202110/30/20211030233333image.png)\n3.请求第三个接口\n3.1 get方法\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202110/30/20211030234900image.png)\n3.2 post方法\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202110/30/20211030233405image.png)\n4.请求第四个接口\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202110/30/20211030234801image.png)\n\n使用`JSON`格式传递参数时，除了第二个接口有数据，第一个接口报错，其它均为空数据。\n1. JSON请求第一个接口\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202110/30/20211030235210image.png)\n2. JSON请求第三个接口\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202110/30/20211030235415image.png)\n3. JSON请求第四个接口\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202110/30/20211030235437image.png)\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 19, 1, '2021-2-7 14:39:54', '2021-11-23 16:27:00', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (165, 10000, '随机红包GIF图片', '随机红包GIF图片', '随机红包GIF图片![15784675753656049.gif](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202102/11/2021021109572315784675753656049.gif)\n![15784675756140333.gif](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202102/11/2021021109572915784675756140333.gif)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 5, 1, '2021-2-11 09:57:48', '2021-2-11 09:57:48', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (166, 10000, '对象的扩展运算符和Object.assign()', '对象的扩展运算符和Object.assign()', '对象的扩展运算符等同于使用Object.assign()方法。\n```js\nlet aClone = { ...a };\n// 等同于\nlet aClone = Object.assign({}, a);\n```\n\n```js\nlet ab = { ...a, ...b };\n// 等同于\nlet ab = Object.assign({}, a, b);\n```', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/mysql.jpg', 0, 0, 5, 1, '2021-2-17 11:29:28', '2021-11-3 11:18:44', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (167, 10000, 'js使用一个不存在的变量或属性会发生什么？', 'js使用一个不存在的变量或属性会发生什么？', 'js使用一个不存在的变量或属性会发生什么？\n```js\nlet obj = {\n    a: 1,\n    b: 2,\n}\n\nif (obj.c) {\n    console.log(\"cccc\")\n}\n\nif (!obj.c) {\n    console.log(\"dddd\")  // dddd\n}\n\nconsole.log(c);  // ReferenceError: c is not defined\nconsole.log(obj.c);  // undefined\n```', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 8, 1, '2021-2-17 12:09:24', '2021-11-15 09:11:43', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (168, 10000, 'Vue中filter的执行次数', 'Vue中filter的执行次数', '先上代码\n```js\n<template>\n  <Layout class=\"main\">\n    <Form :label-width=\"GLOBAL_CONFIG.FORM_LABEL_WIDTH\">\n      <kh-Card :label=\"$t(\'essentialInformation\')\">\n        <Row>\n          <Col span=\"8\">\n            <FormItem label=\"产品类型\" prop=\"productType\" class=\"detail-bottom\">\n              <span :title=\"formValidate.deviceTypeId\">{{formValidate.deviceTypeId | productType(deviceList)}}</span>\n            </FormItem>\n          </Col>\n        </Row>\n      </kh-Card>\n    </Form>\n  </Layout>\n</template>\n\n<script>\n  import {mapActions} from \'vuex\';\n\n  export default {\n    name: \"ProcessDetail\",\n    data() {\n      return {\n        deviceList: [],\n        formValidate: {}\n      };\n    },\n    computed: {\n      flowId() {\n        return this.$route.query.flowId;\n      },\n      deviceTypeId() {\n        return this.formValidate.deviceTypeId;\n      },\n      // 产品类型实现方式1\n      productTypeName() {\n        let name;\n        this.deviceList.forEach(item => {\n          if (item.code == this.deviceTypeId) {\n            name = item.desc;\n          }\n        });\n        return name;\n      }\n    },\n    methods: {\n      ...mapActions([\"getProcessById\", \"getDaDeviceType\"]),\n      initData() {\n        this.getProcessById({flowId: this.flowId}).then((res) => {\n          this.formValidate = res.data[0];\n        });\n        this.getDaDeviceType().then((res) => {\n          this.deviceList = res.data;\n        });\n      },\n      goto(path) {\n        this.$router.push({\n          path: path,\n          query: {flowId: this.flowId}\n        });\n      },\n    },\n    created() {\n      this.initData();\n    },\n    filters: {\n      flowClass(value) {\n        let types = [\"开机调试\", \"巡检维护\", \"故障维修\"];\n        return types[value];\n      },\n      // 产品类型实现方式2\n      productType(value, deviceList) {\n        console.log(\"value=\", value);  //执行了4次\n        let name;\n        deviceList.filter(item => {\n          if (item.code == value) {\n            name = item.desc;\n          }\n        });\n        return name;\n      }\n    }\n  };\n</script>\n\n<style scoped lang=\"scss\">\n  .main {\n    position: relative;\n    width: 100%;\n    background: none;\n  }\n</style>\n```\n这里`console.log(\"value=\", value)`，执行了4次\n这四次分别为\nvalue为空，执行一次，\nvalue不为空，执行一次\ndeviceList为[]（无数据）,执行一次\ndeviceList不为[]（有数据）,执行一次\n\n参考链接：\nhttps://blog.csdn.net/weixin_45389633/article/details/111702047', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 5, 1, '2021-2-17 12:10:31', '2021-11-19 16:46:47', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (169, 10000, 'Vue中使用render函数添加ref属性后在mouted中获取不到', 'Vue中使用render函数添加ref属性后在mouted中获取不到', 'Vue中使用render函数添加ref属性后在mouted中获取不到，使用nextTick也不行\n原因：mounted只保证组件在Vue上挂载，不保证在doucument中渲染完毕，所以之所以获取不到是因为组件还没渲染出来。\n```js\nref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例：\n\n<!-- `vm.$refs.p` will be the DOM node -->\n<p ref=\"p\">hello</p>\n\n<!-- `vm.$refs.child` will be the child component instance -->\n<child-component ref=\"child\"></child-component>\n当 v-for 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。\n\n关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。\n```\n\n解决方法：\n暂时没有完美的解决方法\n1. 使用setTimeout(不稳定)\n\n\n参考链接：\nhttps://blog.csdn.net/qq_39524670/article/details/101474183\nhttps://blog.csdn.net/weixin_42335036/article/details/114100168\nhttps://blog.csdn.net/qq_34595425/article/details/117706387\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 5, 1, '2021-2-19 20:26:18', '2021-11-22 14:35:53', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (170, 10000, 'Springboot发邮件', 'Springboot发邮件', 'https://blog.csdn.net/sinat_26342009/article/details/89425836\nhttps://blog.csdn.net/qq_41502099/article/details/106277490\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 13, 1, '2021-2-19 20:28:10', '2021-12-7 23:01:29', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (171, 10000, 'Js之eventLoop', 'Js之eventLoop', '12rrrrr', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/202112/09/20211209214743bg2014100802.png', 0, 0, 13, 1, '2021-2-19 23:42:30', '2021-12-9 21:47:54', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (172, 10000, '前端之XSS攻击及防范', '前端之XSS攻击及防范', '\n\nhttps://tech.meituan.com/2018/09/27/fe-security.html', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 5, 1, '2021-2-19 23:46:22', '2021-12-24 10:21:27', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (173, 10000, '正则合集(持续更新......)', '正则合集', '```js\n// 只允许输入数值类型，小数点后最多2位的正数\nexport const numberPointTwo = (rule, value, callback) => {\n  if (value === \"\" || value === undefined || value === null) {\n    callback();\n    return;\n  }\n  // let rule_Reg = /^(\\-)?\\d+(\\.\\d{1,2})?$/;\n  // let rule_Reg = /^(\\-)?([1-9]\\d{0,7})(\\.\\d{1,2})?$/;\n  let rule_Reg = /^(\\-)?(([1-9]\\d{0,6}|0)|0)(\\.\\d{1,2})?$/;\n  if (!rule_Reg.test(value)) {\n    return callback(new Error(\"只允许输入整数位长度不超过7位，小数点后最多2位的数\"));\n  } else {\n    callback();\n  }\n};\n```\n', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 10, 1, '2021-2-19 23:49:10', '2021-12-24 10:23:05', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (174, 10000, '前端之CSRF攻击及其防范', '前端之CSRF攻击及其防范', '\n\n\nhttps://tech.meituan.com/2018/10/11/fe-security-csrf.html', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 4, 1, '2021-2-19 23:50:49', '2021-12-24 10:22:25', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (175, 10000, 'vue中v-model和.sync修饰符区别', 'vue中v-model和.sync修饰符区别', 'v-model和.sync是在功能上比较相似的两个东西。但本质上他们实现的原理是一样的，只是运用场景不同，在写法上也不一致。\n### 1. `v-model`\n本质上v-model，是通过默认的名为`value` 的 prop 和名为 `input` 的自定义事件。如下代码所示：\n```js\n<!--v-model写法-->\n<my-component type=\"text\" v-model=\"value\">\n<!--展开语法糖后的写法-->\n<my-component type=\"text\"\n  :value=\"value\"\n  @input=\"value = $event.target.value\"\n>\n<!--\n默认针对原生组件input事件，但是如果子组件定义了针对事件。\nmodel: {\n        prop: \"value\",\n        event: \"update\"\n},\n则编译为\n-->\n<my-component type=\"text\"\n  :value=\"value\"\n  @update=\"(val) => value = val\"\n>\n```\n\n### 2. `.sync`修饰符 \n```js\n<!--语法糖.sync-->\n<my-component :value.sync=\"value\" />\n<!--编译后的写法-->\n<my-component \n  :value=\"value\" \n  @update:value=\"(val) => value = val\"\n>\n```\n\n\n### 3. 案例\nFather.vue\n```js\n<template>\n  <div class=\"father\">\n    Father\n    <!--\n    v-model的使用方式不变\n    sync方式要加上.sync修饰符\n    -->\n    <Children v-model=\"testData\" :syncData.sync=\"syncData\"/>\n    上行代码编译为\n    <!--\n    <Children\n            :checked=\"testData\"\n            @modify=\"(val) => testData = val\"\n\n            :syncData=\"syncData\"\n            @update:syncData=\"(val) => syncData = val\"\n    />\n    -->\n  </div>\n</template>\n\n<script>\n    import Children from \"./Children\";\n\n    export default {\n        name: \"Father\",\n        components: {\n            Children\n        },\n        data() {\n            return {\n                testData: \"This is a String\",\n                syncData: \"This is sync Data\"\n            }\n        }\n    }\n</script>\n\n<style lang=\"scss\" scoped>\n  .father {\n    height: 300px;\n    width: 300px;\n    background-color: cadetblue;\n  }\n</style>\n```\nChildren.vue\n```js\n<template>\n  <div class=\"children\">\n    children<br/>\n    <button @click=\"modify\">按钮1</button>\n    <br/>\n    checked: {{checked}}<br/>\n    <button @click=\"modifySyncData\">按钮SyncData</button><br/>\n    SyncData: {{syncData}}\n  </div>\n</template>\n\n<script>\n    export default {\n        name: \"Test\",\n        model: {\n            prop: \'checked\',\n            event: \'modify\',\n            // 你可以随意指定event的名称，\"modify\"、\"modify1\"、\"modify2\"....都行，\n            // 只要在\"按钮1\"的触发事件中emit出同名函数即可\n            // 但.sync的emit函数名就有限制了，即必须以update开头，冒号后加上prop的名称（update:propName）\n            // 如\"update:syncData\",\"update:title\"....\n        },\n        props: {\n            // 仍然需要在组件的 props 选项里声明 checked 这个 prop\n            checked: {\n                type: String,\n                default: \'\'\n            },\n            syncData: {\n                type: String\n            }\n        },\n        methods: {\n            modify() {\n                this.$emit(\"modify\", \"123456\")\n            },\n            modifySyncData(){\n                // 这边的emit必须为update:syncData，如果不同名，像\'update:syncData1\',\'modify:syncData\'，就无法使用\n                this.$emit(\"update:syncData\", \"123456SyncData\")\n            }\n        }\n    }\n</script>\n\n<style scoped>\n  .children {\n    height: 200px;\n    width: 200px;\n    background-color: skyblue;\n  }\n</style>\n```\n### 4. 总结\n`v-model`和`.sync`的实现本质上是一致的，二者都是语法糖。**只不过v-model 默认会利用名为 `value` 的prop和名为 `input` 的事件**，需要修改属性名称和emit事件名称时，通过`model`来修改（修改名称还需要在prop中定义），**而`.sync`没有默认值**，他的prop名称必须自定义，但emit事件名需为`update:属性名`。二者都是为了实现`\"双向绑定\"`(**实际上不是真正意义上的双向绑定，而是子组件通过emit给父组件事件，父组件接受emit来实现修改prop，从而更新组件的值。表面上，事件由子组件触发并更新prop，但实际上中间还通过了一层父组件**)，真正的双向绑定会带来维护上的问题，因为子组件可以变更父组件，且在父组件和子组件两侧都没有明显的变更来源。相比较之下，** .sync ** 更加灵活，它可以给多个 `prop` 使用，而 `v-model` 在一个组件中只能有一个（Vue3中`v-model`已经可以给多个`prop`使用了），在Vue3中，已经取消了`.sync`修饰符，将二者统一。\n\n## 3.x 语法\n\n在 3.x 中，自定义组件上的 `v-model` 相当于传递了 `modelValue` prop 并接收抛出的 `update:modelValue` 事件：\n\n```html\n<ChildComponent v-model=\"pageTitle\" />\n\n<!-- 是以下的简写: -->\n\n<ChildComponent\n  :modelValue=\"pageTitle\"\n  @update:modelValue=\"pageTitle = $event\"\n/>\n```\n\n### `v-model` 参数\n\n若需要更改 `model` 的名称，现在我们可以为 `v-model` 传递一个*参数*，以作为组件内 `model` 选项的替代：\n\n```html\n<ChildComponent v-model:title=\"pageTitle\" />\n\n<!-- 是以下的简写: -->\n\n<ChildComponent :title=\"pageTitle\" @update:title=\"pageTitle = $event\" />\n```\n\n![v-bind anatomy](https://v3.cn.vuejs.org/images/v-bind-instead-of-sync.png)\n\n这也可以作为 `.sync` 修饰符的替代，而且允许我们在自定义组件上使用多个 `v-model`。\n\n```html\n<ChildComponent v-model:title=\"pageTitle\" v-model:content=\"pageContent\" />\n\n<!-- 是以下的简写： -->\n\n<ChildComponent\n  :title=\"pageTitle\"\n  @update:title=\"pageTitle = $event\"\n  :content=\"pageContent\"\n  @update:content=\"pageContent = $event\"\n/>\n```\n\n### `v-model` 修饰符\n\n除了像 `.trim` 这样的 2.x 硬编码的 `v-model` 修饰符外，现在 3.x 还支持自定义修饰符：\n\n```html\n<ChildComponent v-model.capitalize=\"pageTitle\" />\n```\n\n我们可以在 [Custom Events](../component-custom-events.html#处理-v-model-修饰符) 部分中了解有关自定义 `v-model` 修饰符的更多信息。\n\nhttps://www.jianshu.com/p/f0673a9eba3f\nhttps://zhuanlan.zhihu.com/p/338392152\nhttps://v3.cn.vuejs.org/guide/migration/v-model.html#_3-x-%E8%AF%AD%E6%B3%95', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/mysql.jpg', 0, 0, 41, 1, '2021-2-20 10:07:00', '2022-3-8 15:16:26', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (176, 10000, 'nginx学习', 'nginx学习', 'nginx之正向代理与反向代理\nhttps://zhuanlan.zhihu.com/p/25707362\n\n配置\nhttps://www.cnblogs.com/nicechen/p/15354169.html\n\nNginx 教程：如何在 Ubuntu 20.04 下安装并配置 Nginx\nhttps://zxuqian.cn/install-nginx-on-ubuntu-20-04', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 12, 1, '2021-2-20 10:44:05', '2022-2-24 10:18:09', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (177, 10000, 'React + Antd实现动态切换主题功能', 'React&emsp;+&emsp;Antd实现动态切换主题功能', 'https://www.jianshu.com/p/0d99744f5d67\n\nhttps://zhuanlan.zhihu.com/p/466941080', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 5, 1, '2021-2-20 10:46:31', '2022-2-22 17:23:17', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (178, 10000, '踩坑：如何在Umi中配置使用Sass?', '踩坑：如何在Umi中配置使用Sass?', 'https://www.yuque.com/cherishtheyouth/kw0nhk/oudd6p', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 6, 1, '2021-2-20 10:48:05', '2022-2-27 17:10:30', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (179, 10000, 'React之高阶组件', '了解React高阶组件的定义，以及高阶组件实现的两种方式（shuling属性代理和反向继承）', '## 1. 前言 \nReact的高阶组件，通俗来讲，就是在传入一个组件，并在组件外包裹一层父组件，在外层的容器中增强其功能，返回强化后的组件，高阶组件是为了替代React的mixins而诞生的，如果你了解过Vue的mixin，你可以将高阶组件的功能理解为Vue的mixin。\n\n## 2. 属性代理和反向继承\n|使 用 方 式|描述|特点|\n|-|-|-|\n|属性代理|高阶组件通过props给输入组件传递参数，输入组件直接使用 this.props.属性名 即可。|返回一个全新的组件，不可以获取输入组件的state、生命周期、方法。|\n|反向继承|高阶组件继承输入组件，可以得到输入组件的相关信息。|返回输入组件的子组件，可以获取输入组件的state、生命周期、方法。|\n\n## 3.\nhttps://segmentfault.com/a/1190000010371752\nhttps://blog.csdn.net/qq_36907766/article/details/84658786', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 21, 1, '2021-2-23 16:42:29', '2022-2-28 17:47:38', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (180, 10000, '在forEach中使用async/await的注意事项', '在forEach中使用async/await时可能得到意想不到的错误结果，因为forEach的内部是由异步实现的，不仅是forEach,filter、map等方法同样会导致错误的结果。', '## 一. 案例(摘自：[阮一峰ES6教程](上面代码可能不会正常工作，原因是这时三个db.post()操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。))\n```js\nfunction dbFuc(db) { //这里不需要 async\n  let docs = [{}, {}, {}];\n\n  // 可能得到错误结果\n  docs.forEach(async function (doc) {\n    await db.post(doc);\n  });\n}\n```\n上面代码可能不会正常工作，原因是这时三个`db.post()`操作将是**并发执行**，也就是**同时执行**，而不是**继发执行**。正确的写法是采用`for`循环。\n## 二. 错误的写法\n```js\nfunction foo(value) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(value);\n    }, value)\n  })\n}\n\nlet arr = [4444, 2222, 3333];\n\n// 采用Promise/then的方式，各个异步操作之间没有任何关联，\n// 在约2222ms后输出：2222\n// 在约3333ms后输出：3333\n// 在约4444ms后输出：4444\nfunction ope() {\n  console.log(\"then\");\n  arr.forEach(async item => {\n    foo(item).then(console.log)\n  })\n}\n\n// 我们期待正确的结果\n// 1. 在约4444ms后输出：4444\n// 2. 然后，等待2222ms后输出：2222\n// 3. 然后，等待3333ms后输出：3333\n// 但是实际的结果却和ope()一样，原因上面已经解释了，他们是同时执行。\n\nfunction opeForEach() {\n  console.log(\"forEach\");\n  arr.forEach(async item => {\n    let res = await foo(item);\n    console.log(res);\n  })\n}\n\n\n// 不仅仅是forEach, map、filter也有类似的情况，他们的结果和forEach一样\nfunction opeMap() {\n  console.log(\"map\");\n  arr.map(async item => {\n    let res = await foo(item);\n    console.log(res);\n  })\n}\n\nfunction opeFilter() {\n  console.log(\"filter\");\n  arr.filter(async item => {\n    let res = await foo(item);\n    console.log(res);\n  })\n}\n```\n## 三. 正确的写法\n### 3.1 使用for of\n```js\n// 使用for of来输出正确的结果\n// 1. 在约4444ms后输出：4444\n// 2. 然后，等待2222ms后输出：2222\n// 3. 然后，等待3333ms后输出：3333\nasync function opeForOf() {\n  console.log(\"for of\");\n  for (let item of arr) {\n    let res = await foo(item);\n    console.log(res);\n  }\n}\n```\n### 3.2 使用reduce\n```js\n// 使用reduce来输出正确的结果\nasync function opeReduce() {\n  console.log(\"reduce\");\n  arr.reduce(async (_,item) => {\n    await _;\n    let res = await foo(item);\n    console.log(res);\n  }, undefined)\n}\n```\n上面例子中，`reduce()`方法的第一个参数是`async`函数，导致该函数的第一个参数是前一步操作返回的 `Promise` 对象，所以必须使用`await`等待它操作结束。另外，`reduce()`方法返回的是`arr`数组最后一个成员的`async`函数的执行结果，也是一个 `Promise` 对象，导致在它前面也必须加上`await`。\n\n上面的`reduce()`的参数函数里面没有`return`语句，原因是这个函数的主要目的是`db.post()`操作，不是返回值。而且`async`函数不管有没有`return`语句，总是返回一个 `Promise` 对象，所以这里的`return`是不必要的。\n\n## 四. 扩展\n关于“同时执行”这一说法，我是有些疑问的。\n```js\nlet arrSame = [30, 30, 30];\n\nfunction opeSameTime() {\n  console.log(\"ope same time\");\n  arrSame.forEach(async (item, index) => {\n    let res = await foo(item);\n    console.log(index);\n  })\n}\n\nopeSameTime();\n```\n在上面这个案例中，执行结果总是0，1，2。\n所以`forEach`中的回调其实是存在先后关系的，根据`eventLoop`的规则，第一个被遍历到的回调优先被推入任务队列中，因此，推入的顺序和遍历的顺序相同，主进程空闲时，依次取出任务队列中的回调任务进行执行，所以输出总是0，1，2.', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 19, 1, '2021-2-23 16:44:15', '2022-3-1 18:36:01', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (181, 10000, 'Vue之异步组件', '本文解释Vue的异步组件是什么，为什么要使用异步组件，以及异步组件实现的3中方式。', 'Vue的特点之一就是**组件化**，Vue使用组件将一个页面分割成一个一个模块独立起来，组件化可以很好的进行代码复用，而且便于开发和维护。今天要说的**异步组件**是Vue的高级功能之一，但归根结底，异步组件并不是什么新东西，也许在你的开发中，你已经用到了异步组件，只是你并不知道它就是异步组件。\n## 一. 为什么要异步组件\n在了解什么是异步组件之前，我们要明白为什么要异步组件，前面说到**Vue使用组件对完整的页面进行代码层面的分割**，将一个完整的页面分割成多个组件，即多份代码。现在有这么个情况，有一个组件，它为了实现一些花里胡哨的功能写了很多代码，引入了很多三方库，但是它的显示与否并不影响我页面的使用，或者可以说是我想让它在满足某个条件时显示(如点击某个按钮等)，仅仅只是一个扩展的组件而已。如果不用异步组件，这个组件会阻塞其他组件的渲染，页面所有的东西都得等它下载完成，再进行渲染。那么，有没有一种机制，就是一个组件不用让其他组件等待它，其他页面加载自己的，加载完成后就显示，但是这个组件可以等满足时下载渲染，不阻塞其他的组件。\n\n## 二. 什么是异步组件？\n**异步组件**就是一个组件，一个**模块的代码**，他在用户需要时才从服务器下载，并且它的加载不会阻塞其他组件的渲染，等它下载完再进行渲染即可，这种按需下载并且不会阻塞其他组件渲染的组件就叫**异步组件**，就和异步函数一样。\n### 2.1 现在，以vue3为例，我们来实现一个非异步组件。\nCommonComponent.vue\n```js\n<template>\n  <div class=\"cadetblue3\">\n    这是一个简单的组件，大小比较小，下载的快\n    <AsyncComponent/>\n  </div>\n</template>\n\n<script>\n    console.log(\"CommonComponent组件被加载了\");\n    // 使用同步的方式加载组件\n    import AsyncComponent from \"./AsyncComponent.vue\";\n\n    export default {\n        name: \"CommonComponent\",\n        components: {\n            AsyncComponent,\n        }\n    }\n</script>\n```\n\nAsyncComponent.vue\n```js\n<template>\n  <div class=\"skyblue2\">\n    这是一个复杂组件，它的大小可能有几M，下载的慢\n  </div>\n</template>\n\n<script>\n    console.log(\"AsyncComponent组件被加载了\");\n    export default {\n        name: \"AsyncComponent\"\n    }\n</script>\n```\n我们使用`Slow 3G`模拟加载慢的情况，这时我们会发现。\n-  控制台的两句话是同时打印的。\n- CommonComponent会等待AsyncComponent加载完毕后一起渲染。\n\n这就反映出，如果不使用异步组件，会阻塞其他组件的渲染。\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202203/10/20220310234222image.png)\n\n### 2.2 以vue3为例，我们来实现一个异步组件。\nvue3的异步组件使用`defineAsyncComponent`定义\nCommonComponent.vue\n```js\n<template>\n  <div class=\"cadetblue3\">\n    这是一个简单的组件，大小比较小，下载的快\n    <async-modal/>\n  </div>\n</template>\n\n<script>\n    console.log(\"CommonComponent组件被加载了\");\n    import {defineAsyncComponent} from \'vue\';\n\n    // 不带选项的异步组件\n    const asyncModal = defineAsyncComponent(() => import(\'./AsyncComponent.vue\'))\n\n    export default {\n        name: \"CommonComponent\",\n        components: {\n            asyncModal,\n        }\n    }\n</script>\n```\n这时:\n- CommonComponent的渲染不会被AsyncComponent阻塞，他在加载完自生的同步组件后就立即渲染\n- AsyncComponent组件还未加载出来，不会显示任何东西。\n\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202203/10/20220310235449image.png)\n\n当然，异步组件并不总是用在等待所有同步组件下载完成后再下载（上面的情况就是等所有同步组件下载完再下载异步组件），它还可以与`v-if`结合使用，当条件满足的时候，才会下载下来。\n```js\n<template>\n  <div class=\"cadetblue3\">\n    这是一个简单的组件，大小比较小，下载的快\n    <button @click=\"show=true\">点击加载AsyncComponent</button>\n    <AsyncComponent v-if=\"show\"/>\n  </div>\n</template>\n\n<script>\n    console.log(\"CommonComponent组件被加载了\");\n\n    const AsyncComponent = defineAsyncComponent(() => import(\'./AsyncComponent.vue\'))\n\n    export default {\n        name: \"CommonComponent\",\n        components: {\n            AsyncComponent\n        },\n        data() {\n            return {\n                show: false\n            }\n        }\n    }\n</script>\n```\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202203/13/20220313221629image.png)\n点击按钮后，下载组件并渲染\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202203/13/20220313222149image.png)\n\n### 2.3 更高级的用法\n在异步组件加载的过程中，你还可以先用其他组件代替，或者在它加载失败时显示另一个提示组件。\n\n\nCommonComponent.vue\n```js\n<template>\n  <div class=\"cadetblue3\">\n    这是一个简单的组件，大小比较小，下载的快\n    <async-modal/>\n  </div>\n</template>\n\n<script>\n    console.log(\"CommonComponent组件被加载了\");\n    import {defineAsyncComponent} from \'vue\';\n\n    // 不带选项的异步组件\n    const asyncModal = defineAsyncComponent(() => import(\'./AsyncComponent.vue\'))\n\n    export default {\n        name: \"CommonComponent\",\n        components: {\n            asyncModal,\n        }\n    }\n</script>\n```\n**未下载完成时**\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202203/11/20220311000216image.png)\n**下载失败时**\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202203/11/20220311000320image.png)\n> 另外：值得注意的是，已经下载下来的组件不会再次进行下载，Vue会将结果缓存起来供未来重渲染。\n\n## 三. 异步组件的实现方式\n### 3.1 Vue2中实现异步组件\n方式1： webpack 2 和 ES2015 语法动态导入\n```js\nconst AsyncComponent = () => import(\'./AsyncComponent\');\n```\n方式2: 异步组件和 webpack 的 code-splitting 功能一起配合使用\n```js\nconst AsyncComponent = (resolve) => {require([\'./AsyncComponent\'], resolve)}\n```\n方式3：工厂函数\n```\nVue.component(\'async-example\', function (resolve, reject) {\n  setTimeout(function () {\n    // 向 `resolve` 回调传递组件定义\n    resolve({\n      template: \'<div>I am async!</div>\'\n    })\n  }, 1000)\n})\n```\n\n### 3.2 Vue3中实现异步组件\nvue3中只能使用`defineAsyncComponent`\n```js\nconst asyncModal = defineAsyncComponent(() => import(\'./Modal.vue\'))\n```\n\n## 四. 异步组件实现的基本原理\n\n// todo...\n\n## 五. 异步组件和Vue Router懒加载。\n在中[Vue3的官方文档](https://v3.cn.vuejs.org/guide/migration/async-components.html#_3-x-%E8%AF%AD%E6%B3%95)中提到：\n>  **注意**\nVue Router 支持一个类似的机制来异步加载路由组件，也就是俗称的*懒加载*。尽管类似，但是这个功能和 Vue 所支持的异步组件是不同的。当用 Vue Router 配置路由组件时，你**不**应该使用 `defineAsyncComponent`。你可以在 Vue Router 文档的[懒加载路由](https://next.router.vuejs.org/guide/advanced/lazy-loading.html)章节阅读更多相关内容。\n\nVue Router文档中\n>注意\n**不要**在路由中使用[异步组件](https://v3.vuejs.org/guide/component-dynamic-async.html#async-components)。异步组件仍然可以在路由组件中使用，但路由组件本身就是动态导入的。\n\n一般情况下，系统可不仅仅是一个页面，比如我们有首页、博客页、用户页、关于页等等其它很多页面，但是网站的设计并不能同时浏览这么多页面，我们打开网站时，一般显示的是首页，此时，我只需要下载首页的代码，像博客页、用户页、关于页不做显示，这些**模块的代码(一般是js或css文件)** 就没必要下载了，浪费资源，也浪费浏览器的性能，小的网站还好，大型网站那是多少页面，网络不好时加载速度得多慢啊。我们想要的是**按需加载**，等我点到某个页面，你再下载这个页面的代码，进行渲染即可。\n\n例如：我们在访问首页时，加载的文件为(这里以js,css文件为例，一般都是chunk开头的文件)\n这里加载了四个文件。\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202203/09/20220309230054image.png)\n然后我们点击“博客”\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202203/09/20220309230204image.png)\n这些新加载的文件就是“博客”页面的代码，然后，我们再次点击“首页”\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202203/09/20220309230316image.png)\n可以发现，并没有新的文件被下载下来。\n\n文件命名：https://www.cnblogs.com/zhensg123/p/7671129.html\n实现原理：https://www.jianshu.com/p/40a364b5e964\n三种方式：https://www.jianshu.com/p/da7a2c8f910d\n使用方式：\nhttps://www.cnblogs.com/fsg6/p/14470002.html\nhttps://juejin.cn/post/6844903568214851592', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 74, 1, '2021-2-23 16:49:45', '2022-3-14 10:14:01', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (182, 10000, '为什么用 Reflect.get，而不是直接 target[key] 返回呢?', '为什么用&emsp;Reflect.get，而不是直接&emsp;target[key]&emsp;返回呢?<br>它们有什么区别呢?', '\n\n参考链接：\n\n[Reflect.get()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get)\n\n[Vue3 源码解析系列 - 响应式原理（reactive 篇）](https://zhuanlan.zhihu.com/p/87899787)\n\n[ES6 Proxy里面为什么要用Reflect？](https://www.zhihu.com/question/460133198)\n\n[在es6 Proxy中，推荐使用Reflect.get而不是target[key]的原因](https://blog.csdn.net/qq_34629352/article/details/114210386)\n\n[Proxying a getter](https://javascript.info/proxy?tdsourcetag=s_pctim_aiomsg#proxying-a-getter)', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 13, 1, '2021-2-23 16:51:02', '2022-4-18 15:42:56', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (184, 10000, 'Docker数据卷之具名挂载和匿名挂载', 'Docker数据卷之具名挂载和匿名挂载的区别', 'http://t.zoukankan.com/ZYH-coder0927-p-14001957.html', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 10, 1, '2021-2-28 17:42:45', '2022-7-2 10:39:55', 'http://t.zoukankan.com/ZYH-coder0927-p-14001957.html', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (185, 10002, '学习笔记', '学习笔记', '学习笔记', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 19, 1, '2021-3-15 11:05:04', '2021-3-15 11:05:04', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (186, 10000, 'vue指令拖拽之transform与left/top', 'vue指令拖拽之transform与left/top', '```js\n<template>\n  <div class=\"service-manage-container\">\n    <div v-drag-tranform=\"false\" class=\"transform base\">transform</div>\n    <div v-drag-left-top=\"false\" class=\"left-right base\">left/top</div>\n  </div>\n</template>\n\n<script>\n  import {getElementTop, getElementLeft, addClass, removeClass} from \"@/libs/util\";\n\n  export default {\n    name: \"ServiceManage\",\n    directives: {\n      dragTranform: {\n        inserted(el, {value}) {\n          let startX = 0, // 起点X坐标\n            startY = 0,  // 起点Y坐标\n            valueX = 0,  // css translate X坐标\n            valueY = 0;  // css translate Y坐标\n          let actualX = getElementLeft(el);\n          let actualY = getElementTop(el);\n\n          let offsetWidth = document.body.offsetWidth;\n          let offsetHeight = document.body.offsetHeight;\n          el.style.transform = `translate(${startX}px, ${startY}px)`;\n          el.onmousedown = (e) => {\n            let oldX = e.clientX;\n            let oldY = e.clientY;\n\n            document.onmousemove = (e) => {\n              let newX = e.clientX;\n              let newY = e.clientY;\n\n              valueX = startX + (newX - oldX);\n              valueY = startY + (newY - oldY);\n\n              if (value === false) { //不允许超出边界\n                (valueX < -actualX) && (valueX = -actualX);\n                (valueY < -actualY) && (valueY = -actualY);\n                (valueX + el.offsetWidth > offsetWidth - actualX) && (valueX = offsetWidth - el.offsetWidth - actualX);\n                (valueY + el.offsetHeight > offsetHeight - actualY) && (valueY = offsetHeight - el.offsetHeight - actualY);\n              }\n\n              el.style.transform = `translate(${valueX}px, ${valueY}px)`;\n            };\n\n            document.onmouseup = () => {\n              startX = valueX;\n              startY = valueY;\n              document.onmousemove = null;\n              document.onmouseup = null;\n            };\n          };\n        }\n      },\n      dragLeftTop: {\n        inserted(el, binding) {\n          let offsetWidth = document.body.offsetWidth;\n          let offsetHeight = document.body.offsetHeight;\n\n          el.onmousedown = (e) => {\n            let valueX = el.style.left.replace(\"px\", \"\") * 1 || 0;\n            let valueY = el.style.top.replace(\"px\", \"\") * 1 || 0;\n\n            let oldX = e.clientX;\n            let oldY = e.clientY;\n\n            document.onmousemove = (e) => {\n              let moveX = e.clientX - oldX;\n              let moveY = e.clientY - oldY;\n              let tX = valueX + moveX;\n              let tY = valueY + moveY;\n              if (binding.value === false) {\n                (tX < 0) && (tX = 0);\n                (tY < 0) && (tY = 0);\n                (tX > offsetWidth - el.offsetWidth) && (tX = offsetWidth - el.offsetWidth);\n                (tY > offsetHeight - el.offsetHeight) && (tY = offsetHeight - el.offsetHeight);\n              }\n              el.style.left = tX + \'px\';\n              el.style.top = tY + \'px\';\n            };\n\n            document.onmouseup = () => {\n              document.onmousemove = null;\n              document.onmouseup = null;\n            };\n          };\n        }\n      }\n    },\n    data() {\n      return {};\n    }\n  };\n</script>\n\n<style lang=\"scss\" scoped>\n  .service-manage-container {\n    .base {\n      height: 200px;\n      width: 200px;\n      cursor: grab;\n      user-select: none;\n    }\n\n    .transform {\n      background-color: #87ceeb;\n    }\n\n    .left-right {\n      background-color: #ffff96;\n      position: relative;\n    }\n  }\n</style>\n```', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 8, 1, '2021-3-21 11:20:58', '2022-7-7 15:54:20', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (187, 10000, 'emoji', 'emoji<br>', '###### 6666666666666\n### 33333333333333\n## 2222222222222\n#### 4444444444444\n# 11111111111111\n##### 5555555555555\n### 3333333333333\n###### 6666666666666\n### 3333333333333\n## 2222222222222\n# 1111111111111\n', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 40, 1, '2021-3-23 19:12:52', '2022-7-8 17:48:52', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (188, 10000, '新服务器测试', '新服务器测试', '新服务器测试', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 2, 1, '2021-3-24 22:35:04', '2021-3-24 22:35:04', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (189, 10000, '123', '123', '123', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 0, 1, '2021-3-26 18:54:16', '2021-3-26 18:54:16', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (190, 10000, '发布测试', '发布测试', '发布测试', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 1, 1, '2021-3-26 18:58:24', '2021-3-26 18:58:24', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (191, 10000, '草稿', '草稿', '草稿', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 0, 1, '2021-3-26 18:58:54', '2021-3-26 18:58:54', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (192, 10000, '今天的图书馆真是绝了', '没水没网就算了，今天还没电', '今天的图书馆，没水，没网(一直都没WIFI) ，完了早上还有电，过一会还没电了……\n再见，今天不适合待在图书馆，周六就休息一下午吧。![image.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/27/20210327120356image.jpg)\n柳絮太难受了\n![4C750EFB0F6D49089ED75CDF6EC66662.jpeg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202103/27/202103271749124C750EFB-0F6D-4908-9ED7-5CDF6EC66662.jpeg)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 26, 1, '2021-3-27 12:04:24', '2021-3-27 17:49:23', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (193, 10000, '类别分类测试', '类别分类测试', '类别分类测试', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 3, 1, '2021-3-28 15:50:51', '2021-3-28 15:50:51', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (194, 10000, '微任务、宏任务与Event-Loop', '微任务、宏任务与Event-Loop', '\n[微任务、宏任务与Event-Loop](https://juejin.cn/post/6844903657264136200)\n\n[译文：JS事件循环机制（event loop）之宏任务、微任务](https://segmentfault.com/a/1190000014940904)\n\n[宏任务和微任务到底是什么？](https://www.jianshu.com/p/bfc3e319a96b)\n\n[JavaScript是如何工作的：引擎，运行时和调用堆栈的概述！](https://segmentfault.com/a/1190000017352941)\n\n很详细的文章：[setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop](https://www.cnblogs.com/dennisj/p/12550996.html)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 18, 1, '2021-3-28 15:51:32', '2022-4-8 10:03:54', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (195, 10000, '一些静态文件的CDN链接', '一些静态文件的CDN链接', '```\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/element-ui@2.13.2/lib/theme-chalk/index.css\">\n```\n\n```\n<script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.min.js\" rel=\"stylesheet\" type=\"text/javascript\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/vuex@3.0.1/dist/vuex.min.js\" rel=\"stylesheet\" type=\"text/javascript\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/axios@0.19.0/dist/axios.min.js\" rel=\"stylesheet\" type=\"text/javascript\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/vue-router@3.4.5/dist/vue-router.min.js\" rel=\"stylesheet\" type=\"text/javascript\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/element-ui@2.13.2/lib/index.js\" rel=\"stylesheet\" type=\"text/javascript\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/mavon-editor@2.9.1/dist/mavon-editor.min.js\" rel=\"stylesheet\" type=\"text/javascript\"></script>\n```\n\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 9, 1, '2021-4-2 21:18:05', '2021-4-2 21:18:05', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (196, 10000, '我人傻了，又从南门绕了一大圈', '我忘记西门已经开了，又从南门绕了一大圈', '我人傻了，西门可以通行了，我从南门绕了一大圈……', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 15, 1, '2021-4-3 09:34:41', '2021-11-1 19:21:36', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (197, 10000, '阿里云CDN502错误', '阿里云CDN502错误', '阿里云CDN502错误\n原因：没有刷新预热', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 7, 1, '2021-4-3 18:23:38', '2021-4-3 18:23:38', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (198, 10000, '把JavaScript文件放在文档的头部还是尾部', '把JavaScript文件放在文档的头部还是尾部', '把JavaScript文件放在文档的头部还是尾部\nhttps://segmentfault.com/a/1190000009083504', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 5, 1, '2021-4-7 16:00:51', '2021-4-7 16:00:51', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (199, 10000, 'css六种实现元素水平居中方法', 'css六种实现元素水平居中方法', 'https://www.cnblogs.com/chengxs/p/11231906.html', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 8, 1, '2021-4-8 10:55:31', '2021-4-8 10:55:31', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (200, 10000, '使用left/top和transform做动画有什么区别', '使用left/top和transform做动画有什么区别', '最首要的区别是元素位置：使用 top left 定位是直接改变元素真实位置的，简单来说你 top: 5px 那就真的是离父容器上端 5px 或者偏离顶部定位 5px（这里我们不讨论 position 各种定位的破事）但是你用 transform: translateY(-5px) 只是改变了视觉位置，元素本身位置还是在 0px，只是视觉上向上偏移了 5px。这一点对于 css 布局是非常重要的，因为大多数情况下你不希望一个元素在动画的时候（比如飞离 fade off）会导致父元素大小改变然后导致 siblings 元素位置变动从而导致集体 shaking，所以很多时候我们用 transform。其次的区别是这两种定位本身的语法：做效果的时候 transform 相对来说是比较方便的，因为 transform 的视角是元素本身，所以比较直观。比如你希望一个元素向左飞 50px 那就是 transform: translateX(-50px)，但是如果用 left 而你的父子元素都是 position: absolute，那可能你用 left 就要写成从 left: 100px 到 left: 30px，这就很不直观。最后的区别是效率：由于 transform 不改动 css 布局，因为渲染行为大多数情况下在元素本身，所以效率比 top left 要高。另外在早期的一些版本，用 transform: translateZ(0px) 强制开启硬件加速好像只能应用在 transform 上，不知道现在这个东西改了没。\n\n作者：知乎用户\n链接：https://www.zhihu.com/question/334077465/answer/759985633\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 6, 1, '2021-4-13 15:46:25', '2021-4-13 15:46:25', 'https://www.zhihu.com/question/334077465/answer/759985633', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (201, 10000, 'webpack缓存配置', 'webpack缓存配置', '缓存:\n**babel缓存**\n   cacheDirectory: true\n   --> 让第二次打包构建速度更快\n**文件资源缓存**\n**hash**:每次wepack构建时会生成一个唯一的hash值。问题:因为js和css同时使用一个hash值。\n如果重新打包，会导致所有缓存失效。(可能我却只改动一个文件)\n\n**chunkhash**:根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样问题:js和css的hash值还是一样的,因为css是在js中被引入的，所以同属于一个chunk\n\n**contenthash**:根据文件的内容生成hash值。不同文件hash值一定不一样\n--> 让代码上线运行缓存更好使用', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 15, 1, '2021-4-13 16:34:06', '2021-4-13 16:37:36', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (202, 10000, 'Promise.resolve()和Promise.reject()', 'Promise.resolve()和Promise.reject()的具体用法', '## Promise.resolve()\n\n有时需要将现有对象转为 Promise 对象，`Promise.resolve()`方法就起到这个作用。\n\n```javascript\nconst jsPromise = Promise.resolve($.ajax(\'/whatever.json\'));\n```\n\n上面代码将 jQuery 生成的`deferred`对象，转为一个新的 Promise 对象。\n\n`Promise.resolve()`等价于下面的写法。\n\n```javascript\nPromise.resolve(\'foo\')\n// 等价于\nnew Promise(resolve => resolve(\'foo\'))\n```\n\n`Promise.resolve()`方法的参数分成四种情况。\n\n**（1）参数是一个 Promise 实例**\n\n如果参数是 Promise 实例，那么`Promise.resolve`将不做任何修改、原封不动地返回这个实例。\n\n**（2）参数是一个`thenable`对象**\n\n`thenable`对象指的是具有`then`方法的对象，比如下面这个对象。\n\n```javascript\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n```\n\n`Promise.resolve()`方法会将这个对象转为 Promise 对象，然后就立即执行`thenable`对象的`then()`方法。\n\n```javascript\nlet thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\n\nlet p1 = Promise.resolve(thenable);\np1.then(function (value) {\n  console.log(value);  // 42\n});\n```\n\n上面代码中，`thenable`对象的`then()`方法执行后，对象`p1`的状态就变为`resolved`，从而立即执行最后那个`then()`方法指定的回调函数，输出42。\n\n**（3）参数不是具有`then()`方法的对象，或根本就不是对象**\n\n如果参数是一个原始值，或者是一个不具有`then()`方法的对象，则`Promise.resolve()`方法返回一个新的 Promise 对象，状态为`resolved`。\n\n```javascript\nconst p = Promise.resolve(\'Hello\');\n\np.then(function (s) {\n  console.log(s)\n});\n// Hello\n```\n\n上面代码生成一个新的 Promise 对象的实例`p`。由于字符串`Hello`不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是`resolved`，所以回调函数会立即执行。`Promise.resolve()`方法的参数，会同时传给回调函数。\n\n**（4）不带有任何参数**\n\n`Promise.resolve()`方法允许调用时不带参数，直接返回一个`resolved`状态的 Promise 对象。\n\n所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用`Promise.resolve()`方法。\n\n```javascript\nconst p = Promise.resolve();\n\np.then(function () {\n  // ...\n});\n```\n\n上面代码的变量`p`就是一个 Promise 对象。\n\n需要注意的是，立即`resolve()`的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。\n\n```javascript\nsetTimeout(function () {\n  console.log(\'three\');\n}, 0);\n\nPromise.resolve().then(function () {\n  console.log(\'two\');\n});\n\nconsole.log(\'one\');\n\n// one\n// two\n// three\n```\n\n上面代码中，`setTimeout(fn, 0)`在下一轮“事件循环”开始时执行，`Promise.resolve()`在本轮“事件循环”结束时执行，`console.log(\'one\')`则是立即执行，因此最先输出。\n\n## Promise.reject()\n\n`Promise.reject(reason)`方法也会返回一个新的 Promise 实例，该实例的状态为`rejected`。\n\n```javascript\nconst p = Promise.reject(\'出错了\');\n// 等同于\nconst p = new Promise((resolve, reject) => reject(\'出错了\'))\n\np.then(null, function (s) {\n  console.log(s)\n});\n// 出错了\n```\n\n上面代码生成一个 Promise 对象的实例`p`，状态为`rejected`，回调函数会立即执行。\n\n`Promise.reject()`方法的参数，会原封不动地作为`reject`的理由，变成后续方法的参数。\n\n```javascript\nPromise.reject(\'出错了\')\n.catch(e => {\n  console.log(e === \'出错了\')\n})\n// true\n```\n\n上面代码中，`Promise.reject()`方法的参数是一个字符串，后面`catch()`方法的参数`e`就是这个字符串。\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 162, 1, '2021-4-26 15:42:50', '2021-11-18 14:21:26', 'https://es6.ruanyifeng.com/#docs/promise#Promise-resolve', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (203, 10000, 'Vuex响应式原理（Vue2,Vue3）', 'Vuex响应式原理（Vue2,Vue3）<br>Vue2:&emsp;Object.defineProperty<br>Vue3:&emsp;Proxy', '[面试官: 能不能手写 Vue 响应式？（Vue2 响应式原理【完整版】）](https://juejin.cn/post/7079807948830015502)\n\n[面试官：能不能手写 Vue3 响应式（Vue3 原理解析之响应系统的实现）](https://juejin.cn/post/7084915514434306078)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 42, 1, '2021-4-29 20:43:20', '2022-4-11 17:51:40', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (204, 10000, '基于Vue3的验证码组件', 'Vue3仿苹果官网验证码组件', '需引入[Animate.css](https://animate.style/)\n效果图\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202204/29/20220429114443image.png)\ncheckCode.vue\n```js\n<template>\n    <div class=\"check-container animate__animated\" :class=\"[\'check-\'+type]\" ref=\"container\">\n        <div class=\"field-wrap\" v-for=\"(item, index) in size\" :class=\"{\'incorrect\': !data.correct}\">\n            <input v-model=\"data.values[index]\"\n                   :ref=\"codeInput\"\n                   max=\"9\"\n                   min=\"0\"\n                   maxlength=\"1\"\n                   autocorrect=\"off\"\n                   autocomplete=\"off\"\n                   autocapitalize=\"off\"\n                   spellcheck=\"false\"\n                   type=\"tel\" class=\"char-field\"\n                   @focus=\"handleSelected\"\n                   @keydown.stop=\"handleDown(index,$event)\"\n                   @input=\"handleInput\"\n                   @paste=\"pasteEvent(index, $event)\"/>\n        </div>\n    </div>\n</template>\n\n<script>\n  import checkCode from \"./js/checkCode\";\n\n  export default {\n    name: \"CheckCode\",\n    props: {\n      size: {\n        type: Number,\n        default: 4,\n      },\n      shake: {\n        type: Boolean,\n        default: true\n      },\n      passcode: {\n        type: String,\n        required: true\n      },\n      type: {\n        type: String,\n        validator(value) {\n          // 这个值必须与下列字符串中的其中一个相匹配\n          return [\'border\', \'line\', \'circle\'].includes(value)\n        },\n        default: \'border\'\n      }\n    },\n    setup({size, shake, passcode}, {emit}) {\n      const {\n        data,\n        container,\n        codeInput,\n        handleDown,\n        handleClick,\n        handleInput,\n        handleSelected,\n        pasteEvent,\n        handleError\n      } = checkCode({size, shake, passcode}, emit);\n\n      return {\n        data,\n        container,\n        codeInput,\n        handleDown,\n        handleClick,\n        handleInput,\n        handleSelected,\n        pasteEvent,\n        handleError\n      }\n    },\n  }\n</script>\n\n<style lang=\"scss\" scoped>\n    .check-container {\n        display: flex;\n        justify-content: center;\n\n        .field-wrap {\n            height: 49px;\n            width: 49px;\n        }\n\n        .char-field {\n            width: 45px;\n            height: 45px;\n            font-size: 24px;\n            padding: 0;\n            text-align: center;\n            color: #494949;\n            line-height: 1.29412;\n            font-weight: 400;\n            letter-spacing: -.021em;\n            font-family: SF Pro Text, SF Pro Icons, Helvetica Neue, Helvetica, Arial, sans-serif;\n            display: inline-block;\n            box-sizing: border-box;\n            vertical-align: top;\n            margin-bottom: 14px;\n            background: #fff;\n            background-clip: padding-box;\n            transition: .3s;\n\n            &:focus {\n                border: 1px solid #97cee5;\n                outline: 0;\n                box-shadow: 0 0 0 3px rgb(131 192 253 / 50%);\n            }\n        }\n    }\n\n    .check-border {\n        .char-field {\n            border: 1px solid #d6d6d6;\n            border-radius: 4px;\n        }\n    }\n\n    .check-circle {\n        .char-field {\n            border: 1px solid #d6d6d6;\n            border-radius: 50%;\n        }\n    }\n\n    .check-line {\n        .char-field {\n            border: none !important;\n            border-bottom: 2px solid #eee !important;\n            outline: none !important;\n            box-shadow: none !important;\n\n            &:before {\n                border: 1px solid #d6d6d6;\n            }\n\n            &:focus {\n                border-bottom: 2px solid #97cee5 !important;\n                outline: 0;\n                box-shadow: 0 0 0 3px rgb(131 192 253 / 50%);\n            }\n        }\n\n        .incorrect.field-wrap {\n            input {\n                border-bottom: 2px solid #e59797 !important;\n            }\n        }\n    }\n\n    .incorrect {\n        input {\n            border: 1px solid #e59797 !important;\n        }\n    }\n</style>\n```\n\ncheckCode.js\n```js\nimport {onBeforeUpdate, onMounted, reactive, ref, watch} from \"vue\";\nimport {addClass, removeClass} from \"../../../../assets/js/util\";\n\n\nexport default function ({size, shake, passcode}, emit) {\n  let container = ref(null);\n  let inputList = [];\n  const codeInput = el => {\n    if (el) {\n      inputList.push(el)\n    }\n  }\n  let keyCode = new Set([\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"Backspace\", \"ArrowLeft\", \"ArrowRight\", \"v\", \"Control\"]);\n  let data = reactive({\n    values: [],\n    correct: true\n  })\n\n  const handleDown = (index, event) => {\n    if (!keyCode.has(event.key)) {\n      event.preventDefault();\n      return;\n    }\n    let prevInput, nextInput;\n    prevInput = inputList[index - 1];\n    nextInput = inputList[index + 1];\n    switch (event.key) {\n      case \"Backspace\":\n        !event.target.value && prevInput && prevInput.focus();\n        break;\n      case \"ArrowLeft\":\n        prevInput && prevInput.focus();\n        break;\n      case \"ArrowRight\":\n        nextInput && nextInput.focus();\n        break;\n      case \"Control\":\n      case \"v\":\n        event.preventDefault();\n        break\n      default:\n        setTimeout(() => {\n          if (inputList[index].value) {\n            nextInput && nextInput.focus();\n            nextInput && nextInput.select();\n          }\n          if (index === size - 1) {\n            inputList[index].blur();\n          }\n        }, 0)\n    }\n  };\n\n  const handleClick = (index, event) => {\n\n  };\n\n  const handleInput = () => {\n    data.correct = true;\n  };\n\n  const pasteEvent = (index, event) => {\n    const pasteData = getClipboardData(event, size);\n    data.values.splice(index, pasteData.length, ...pasteData);\n    setTimeout(() => {\n      let focusIndex = index + pasteData.length >= size\n          ? size - 1\n          : index + pasteData.length;\n\n      inputList[focusIndex].focus();\n      inputList[focusIndex].select();\n    })\n  }\n\n  const getClipboardData = (event, max) => {\n    const pasteData = event.clipboardData && event.clipboardData.getData\n        ? event.clipboardData.getData(\'Text\')\n        : \'undefined\';\n\n    if (pasteData === \'undefined\') {\n      return [];\n    }\n\n    return pasteData.replace(/\\s/g, \'\').substr(0, max).split(\'\').map(v => Number(v));\n  }\n\n  const handleCheck = () => {\n    let code = data.values.join(\'\');\n    emit(\'onSubmit\', code)\n  };\n\n  const handleError = () => {\n    setTimeout(() => {\n      data.correct = false;\n    })\n    if (shake) {\n      removeClass(container.value, \"animate__headShake\");\n      setTimeout(() => {\n        addClass(container.value, \"animate__headShake\");\n      })\n    }\n  }\n\n  const handleSelected = (event) => {\n    event.target.select();\n  }\n\n  onBeforeUpdate(() => {\n    inputList = []\n  })\n\n  onMounted(() => {\n\n  })\n\n  watch(data.values, (newVal) => {\n    let valid = false;\n    if (newVal.length === inputList.length) {\n      valid = !newVal.some((item) => item.toString() === \'\');\n    }\n    if (valid) {\n      handleCheck();\n    }\n  });\n\n  return {\n    data,\n    handleDown,\n    handleClick,\n    handleInput,\n    handleSelected,\n    container,\n    codeInput,\n    pasteEvent,\n    handleError\n  }\n}\n```\nutils.js\n```js\n// 给元素添加class名称 obj:要添加类名的元素 cn:添加的样式名称\nexport const addClass = (obj, cn) => {\n  if (!hasClass(obj, cn)) {\n    obj.classList.add(cn);\n  }\n};\n\n// 判断元素是否有某个类名 obj:要判断类名的元素 cn:判断的样式名称\nexport const hasClass = (obj, cn) => {\n  return obj.classList.contains(cn);\n}\n\nexport const removeClass = (obj, cn) => {\n  obj.classList.remove(cn)\n};\n```', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 5, 1, '2021-5-2 20:50:30', '2022-4-29 11:43:03', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (205, 10000, ':smile::smile::smile:', ':smile::smile::smile:', '?????&#x1F600;', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 28, 1, '2021-5-2 20:56:28', '2021-11-17 22:01:48', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (206, 10000, 'Vue的watch在离开后也监听', 'Vue的watch在离开后也监听', 'Vue的watch在离开后也监听？？？\n怎么解决？', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 18, 1, '2021-5-9 21:55:57', '2021-5-9 23:13:16', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (207, 10031, 'da', 'da', '![7e3e6709c93d70cf23ea0237f2dcd100baa12bf3.gif](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221437187e3e6709c93d70cf23ea0237f2dcd100baa12bf3.gif)![1.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221458461.jpg)![11.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052214585111.jpg)![2626.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518472626.jpg)![1.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518471.jpg)![2.jpg](3)![3.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518483.jpg)![4.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518484.jpg)![5.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518485.jpg)![6.jpg](7)![7.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518487.jpg)![8.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518488.jpg)![9.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518489.jpg)![11.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184811.jpg)![11a.jpg](13)![13a.jpg](15)![14.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184814.jpg)![15.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184815.jpg)![16.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184816.jpg)![17.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184817.jpg)![18.jpg](20)![19.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184819.jpg)![20.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184820.jpg)![21.jpg](23)![22.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184822.jpg)![22a.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184922a.jpg)![23.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184923.jpg)![24.jpg](27)![25.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184925.jpg)![26.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184926.jpg)![33.jpg](30)![55.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184955.jpg)![66.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184966.jpg)![77.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215184977.jpg)![88.jpg](35)![99.jpg](36)![1010.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518501010.jpg)![1111.jpg](38)![1212.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518501212.jpg)![1313.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518501313.jpg)![1414.jpg](41)![1515.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518501515.jpg)![1616.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518501616.jpg)![1717.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518501717.jpg)![1818.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518501818.jpg)![1919.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518511919.jpg)![2020.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518512020.jpg)![2121.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518512121.jpg)![2222.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518512222.jpg)![2323.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518512323.jpg)![2424.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221518512424.jpg)![2525.jpg](52)![10.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215185210.jpg)![12.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215185212.jpg)![44.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215185744.jpg)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 19, 1, '2021-5-22 14:37:37', '2021-5-22 15:19:18', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (208, 10031, 'a', 'a', '![2.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221522462.jpg)![3.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221522463.jpg)![4.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215280513a.jpg)![5.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221522465.jpg)![2.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221523402.jpg)![4.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221524084.jpg)![6.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221525206.jpg)![7.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221525207.jpg)![8.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215280513a.jpg)![8.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221526198.jpg)![9.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215272311.jpg)![9.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/202105221526489.jpg)![10.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215272310.jpg)![11.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215272311.jpg)![11a.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215280511a.jpg)![13a.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215280513a.jpg)![12.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215280512.jpg)![16.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215291616.jpg)![14.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215294914.jpg)![15.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215295415.jpg)![17.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215295917.jpg)![18.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215300418.jpg)![19.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215300819.jpg)![20.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215301120.jpg)![21.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215301521.jpg)![22.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215301822.jpg)![22a.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215302122a.jpg)![23.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215302623.jpg)![24.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215303124.jpg)![25.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215303525.jpg)![26.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052215304326.jpg)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 22, 1, '2021-5-22 15:23:12', '2021-5-22 15:48:10', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (209, 10031, 'wqqw', 'qwqwe', '![27.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052221071127.jpg)![28.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052221071528.jpg)![29.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052221072029.jpg)![30.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052221072430.jpg)![31.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052221072831.jpg)![32.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052221073132.jpg)![33a.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052221073733a.jpg)![34.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052221074034.jpg)![35.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052221074335.jpg)![36.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/22/2021052221074636.jpg)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 6, 1, '2021-5-22 21:08:03', '2021-5-22 21:08:03', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (210, 10031, 's', 's', '![c1.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/25/20210525011651c1.jpg)![c2.1.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/25/20210525011656c2.1.jpg)![c2.3.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/25/20210525011700c2.3.jpg)![c2.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/25/20210525011704c2.jpg)![c3.1.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/25/20210525011708c3.1.jpg)![c3.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/25/20210525011716c3.jpg)![c4.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/25/20210525011719c4.jpg)![c5.1.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/25/20210525011723c5.1.jpg)![c5.2.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/25/20210525011726c5.2.jpg)![c5.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202105/25/20210525011731c5.jpg)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 6, 1, '2021-5-25 01:17:46', '2021-5-25 01:17:46', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (211, 10000, '&#8986;&#8986;', '&#8986;&#8986;', '&#8986;&#8986;&#8986;', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/spring.png', 0, 0, 42, 1, '2021-5-25 12:31:08', '2021-11-12 23:00:13', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (212, 10000, '如何在Vue项目中使用ECharts？', '如何在Vue项目中使用ECharts？', '1.安装EChart\n```js\nnpm install echarts -S\n```\n2.在`.vue`中添加\nechart.js 4.9及以下请使用\n```js\nimport echarts from \'echarts\';\n```\n\nechart.js 5.0及以上请使用\n```js\nimport * as echarts from \'echarts\';\n```\n\n完整Chart.Vue文件\n```js\n<template>\n  <div class=\"vol-data\">\n    <div class=\"charts\">\n      <div class=\"charts-title\">\n      </div>\n      <div id=\"myChart\" :style=\"{width:\'100%\',height:\'300px\'}\">\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\n  import * as echarts from \'echarts\';\n\n  export default {\n    name: \'Chart\',\n    data() {\n      return {}\n    },\n    mounted() {\n      /*ECharts图表*/\n      var myChart = echarts.init(document.getElementById(\'myChart\'));\n      myChart.setOption({\n        xAxis: {\n          type: \'category\',\n          data: [\'0\', \'6H\', \'9H\', \'12H\', \'15H\', \'18H\', \'24H\']\n        },\n        yAxis: {\n          type: \'value\'\n        },\n        series: [{\n          data: [1, 3, 4, 7, 4, 6, 9],\n          type: \'line\'\n        }]\n      })\n\n    },\n    methods: {}\n  }\n</script>\n\n<style scoped>\n</style>\n```\n#### 补充：CDN引入EChart\n1.在html文件中添加\n```js\n<script src=\"https://cdn.jsdelivr.net/npm/echarts@5.1.2/dist/echarts.js\"></script>\n```\n2.在vue.config.js文件中添加\n```js\nexternals: {\n    vue: \'Vue\',\n    \'vue-router\': \'VueRouter\',\n    \"element-ui\": \"ELEMENT\",\n    \'highlight.js\': \'hljs\',\n    \'mavon-editor\': \'MavonEditor\',\n    \'axios\': \'axios\',\n    \'marked\': \'marked\',\n    \'echarts\': \'echarts\', //添加external，不打包echart\n  },\n```\n效果展示\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202107/06/20210706221148image.png)\n\n\n\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 32, 1, '2021-7-6 22:12:07', '2021-7-6 22:12:07', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (213, 10000, 'npm在公司内网使用代理不能下载包', '在公司使用代理访问外网时，发现使用npm安装不了任何东西', '在公司使用代理才能访问外网，发现使用npm安装不了任何东西。\n### 解决方法\n\n执行下面的代码：\n```js\nnpm config delete proxy\nnpm config delete https-proxy\n```\n再执行\n```js\nnpm config set proxy=http://192.168.69.111:808     //一定要注意这个IP地址为你公司内部可用的代理IP\nnpm config set https-proxy http://192.168.69.111:808\n```\n再执行npm就可以下载东西了', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/nodejs.jpg', 0, 0, 39, 1, '2021-8-5 14:26:14', '2021-8-5 14:26:14', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (214, 10000, 'vue中bus.$on事件被多次绑定，造成多次触发的解决方案', 'vue中bus.$on事件被多次绑定，造成多次触发的解决方案。', '\n问题描述：\n今天在写搜索框的时候遇到一个奇怪的问题，Bus.$on的方法被调用多次，造成我只用 Bus.$emit 发送了一次请求，却会收到多次的响应，而且响应的次数为含有 Bus.$on 组件被create的次数。百度后发现原因：\n> 只要页面没有被强制刷新，存在组件切换，Bus.$on方法会在组件中多次绑定，从而造成事件多次触发。\n\n解决办法一：在每次调用方法前先解绑事件( Bus.$off )，然后在重新绑定( Bus.$on )\n\n```js\nBus.$off(\'searchRequest\')\nBus.$on(\'searchRequest\', (searchText) => {\n  this.searchSubmit(searchText)\n});\n```\n\n解决办法二：注册的总线事件（Bus）要在组件销毁时(beforeDestroy/destroyed)卸载，否则会多次挂载，造成触发一次但多个响应的情况\n```js\nbeforeDestroy () {\n  Bus.$off(\"searchRequest\");\n}\n```\n参考：\nhttps://www.cnblogs.com/dianzan/p/12759551.html\n\n\n\n\n\n\n', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 26, 1, '2021-8-8 12:15:28', '2021-8-12 08:39:15', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (215, 10000, '不得不说的跨域', '不得不说的跨域', '不得不说的跨域\n很多人对前后端分离部署感到困惑，其实主要是困惑跨域问题怎么解决。因为前后端分离项目在开发的时候，前端通过 nodejs 来运行，需要一个单独的端口，后端通过 Tomcat 或者 Jetty 来运行，也需要端口，两个不同的端口，就造成了跨域。\n\n但是松哥之前多次和大家聊过这个问题，这种跨域并不是我们传统开发中真正的跨域，这个所谓的跨域只在开发环境中存在，生产环境下就不存在这个跨域问题了。所以我们不能按照以往的通过 JSONP 或者 CORS 之类的手段来解决这个跨域问题。\n\n前后端分离开发中，前端为了能够模拟出测试数据，并且模拟出请求，一般需要借助于 nodejs 来运行，这是开发时候的状态，开发时候的配置大家可以参考这篇文章：\n\n前后端分离历险记\n等开发完成后，我们会对前端项目编译打包，编译打包完成之后，就只剩下一堆 js、css 以及 html 文件了，我们把这些编译打包后的文件拷贝到后端项目中，这样再去运行就不存在跨域问题了（例如将编译打包后的静态文件拷贝到 Spring Boot 项目的 src/main/resources/static 目录下）。这种方式我就不再多说了，相信大家都会，今天咱们主要来看看如何结合 Nginx 来部署。\n\nhttps://www.cnblogs.com/lenve/p/11576581.html\n\n![logo512.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/21/20210921173124logo512.png)\n\n![壁纸1.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/22/20210922220401%E5%A3%81%E7%BA%B81.jpg)![壁纸2.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/22/20210922222737%E5%A3%81%E7%BA%B82.jpg)\n\n![壁纸3.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/22/20210922225842%E5%A3%81%E7%BA%B83.png)![壁纸5.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/22/20210922230548%E5%A3%81%E7%BA%B85.png)![壁纸4.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/22/20210922232200%E5%A3%81%E7%BA%B84.png)\n![壁纸1.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202109/26/20210926220354%E5%A3%81%E7%BA%B81.png)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 139, 1, '2021-9-2 19:23:15', '2021-9-26 22:04:14', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (216, 10000, 'vuejs测试', 'vuejs测试', '\n> 该页面假设你已经阅读过了[组件基础](components.html)。如果你还对组件不太了解，推荐你先阅读它。\n\n## Prop 的大小写 (camelCase vs kebab-case)\n\nHTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名：\n\n``` js\nVue.component(\'blog-post\', {\n  // 在 JavaScript 中是 camelCase 的\n  props: [\'postTitle\'],\n  template: \'<h3>{{ postTitle }}</h3>\'\n})\n```\n\n``` html\n<!-- 在 HTML 中是 kebab-case 的 -->\n<blog-post post-title=\"hello!\"></blog-post>\n```\n\n重申一次，如果你使用字符串模板，那么这个限制就不存在了。\n\n## Prop 类型\n\n到这里，我们只看到了以字符串数组形式列出的 prop：\n\n```js\nprops: [\'title\', \'likes\', \'isPublished\', \'commentIds\', \'author\']\n```\n\n但是，通常你希望每个 prop 都有指定的值类型。这时，你可以以对象形式列出 prop，这些 property 的名称和值分别是 prop 各自的名称和类型：\n\n```js\nprops: {\n  title: String,\n  likes: Number,\n  isPublished: Boolean,\n  commentIds: Array,\n  author: Object,\n  callback: Function,\n  contactsPromise: Promise // or any other constructor\n}\n```\n\n这不仅为你的组件提供了文档，还会在它们遇到错误的类型时从浏览器的 JavaScript 控制台提示用户。你会在这个页面接下来的部分看到[类型检查和其它 prop 验证](#Prop-验证)。\n\n## 传递静态或动态 Prop\n\n像这样，你已经知道了可以像这样给 prop 传入一个静态的值：\n\n```html\n<blog-post title=\"My journey with Vue\"></blog-post>\n```\n\n你也知道 prop 可以通过 `v-bind` 动态赋值，例如：\n\n```html\n<!-- 动态赋予一个变量的值 -->\n<blog-post v-bind:title=\"post.title\"></blog-post>\n\n<!-- 动态赋予一个复杂表达式的值 -->\n<blog-post\n  v-bind:title=\"post.title + \' by \' + post.author.name\"\n></blog-post>\n```\n\n在上述两个示例中，我们传入的值都是字符串类型的，但实际上*任何*类型的值都可以传给一个 prop。\n\n### 传入一个数字\n\n```html\n<!-- 即便 `42` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post v-bind:likes=\"42\"></blog-post>\n\n<!-- 用一个变量进行动态赋值。-->\n<blog-post v-bind:likes=\"post.likes\"></blog-post>\n```\n\n### 传入一个布尔值\n\n```html\n<!-- 包含该 prop 没有值的情况在内，都意味着 `true`。-->\n<blog-post is-published></blog-post>\n\n<!-- 即便 `false` 是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post v-bind:is-published=\"false\"></blog-post>\n\n<!-- 用一个变量进行动态赋值。-->\n<blog-post v-bind:is-published=\"post.isPublished\"></blog-post>\n```\n\n### 传入一个数组\n\n```html\n<!-- 即便数组是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post v-bind:comment-ids=\"[234, 266, 273]\"></blog-post>\n\n<!-- 用一个变量进行动态赋值。-->\n<blog-post v-bind:comment-ids=\"post.commentIds\"></blog-post>\n```\n\n### 传入一个对象\n\n```html\n<!-- 即便对象是静态的，我们仍然需要 `v-bind` 来告诉 Vue -->\n<!-- 这是一个 JavaScript 表达式而不是一个字符串。-->\n<blog-post\n  v-bind:author=\"{\n    name: \'Veronica\',\n    company: \'Veridian Dynamics\'\n  }\"\n></blog-post>\n\n<!-- 用一个变量进行动态赋值。-->\n<blog-post v-bind:author=\"post.author\"></blog-post>\n```\n\n### 传入一个对象的所有 property\n\n如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 `v-bind` (取代 `v-bind:prop-name`)。例如，对于一个给定的对象 `post`：\n\n``` js\npost: {\n  id: 1,\n  title: \'My Journey with Vue\'\n}\n```\n\n下面的模板：\n\n``` html\n<blog-post v-bind=\"post\"></blog-post>\n```\n\n等价于：\n\n``` html\n<blog-post\n  v-bind:id=\"post.id\"\n  v-bind:title=\"post.title\"\n></blog-post>\n```\n\n## 单向数据流\n\n所有的 prop 都使得其父子 prop 之间形成了一个**单向下行绑定**：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。\n\n额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你**不**应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。\n\n这里有两种常见的试图变更一个 prop 的情形：\n\n1. **这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用。**在这种情况下，最好定义一个本地的 data property 并将这个 prop 用作其初始值：\n\n  ``` js\n  props: [\'initialCounter\'],\n  data: function () {\n    return {\n      counter: this.initialCounter\n    }\n  }\n  ```\n\n2. **这个 prop 以一种原始的值传入且需要进行转换。**在这种情况下，最好使用这个 prop 的值来定义一个计算属性：\n\n  ``` js\n  props: [\'size\'],\n  computed: {\n    normalizedSize: function () {\n      return this.size.trim().toLowerCase()\n    }\n  }\n  ```\n\n<p class=\"tip\">注意在 JavaScript 中对象和数组是通过引用传入的，所以对于一个数组或对象类型的 prop 来说，在子组件中改变变更这个对象或数组本身**将会**影响到父组件的状态。</p>\n\n## Prop 验证\n\n我们可以为组件的 prop 指定验证要求，例如你知道的这些类型。如果有一个需求没有被满足，则 Vue 会在浏览器控制台中警告你。这在开发一个会被别人用到的组件时尤其有帮助。\n\n为了定制 prop 的验证方式，你可以为 `props` 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：\n\n``` js\nVue.component(\'my-component\', {\n  props: {\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\n    propA: Number,\n    // 多个可能的类型\n    propB: [String, Number],\n    // 必填的字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 带有默认值的数字\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // 带有默认值的对象\n    propE: {\n      type: Object,\n      // 对象或数组默认值必须从一个工厂函数获取\n      default: function () {\n        return { message: \'hello\' }\n      }\n    },\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        // 这个值必须匹配下列字符串中的一个\n        return [\'success\', \'warning\', \'danger\'].indexOf(value) !== -1\n      }\n    }\n  }\n})\n```\n\n当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。\n\n<p class=\"tip\">注意那些 prop 会在一个组件实例创建**之前**进行验证，所以实例的 property (如 `data`、`computed` 等) 在 `default` 或 `validator` 函数中是不可用的。</p>\n\n### 类型检查\n\n`type` 可以是下列原生构造函数中的一个：\n\n- `String`\n- `Number`\n- `Boolean`\n- `Array`\n- `Object`\n- `Date`\n- `Function`\n- `Symbol`\n\n额外的，`type` 还可以是一个自定义的构造函数，并且通过 `instanceof` 来进行检查确认。例如，给定下列现成的构造函数：\n\n```js\nfunction Person (firstName, lastName) {\n  this.firstName = firstName\n  this.lastName = lastName\n}\n```\n\n你可以使用：\n\n```js\nVue.component(\'blog-post\', {\n  props: {\n    author: Person\n  }\n})\n```\n\n来验证 `author` prop 的值是否是通过 `new Person` 创建的。\n\n## 非 Prop 的 Attribute\n\n一个非 prop 的 attribute 是指传向一个组件，但是该组件并没有相应 prop 定义的 attribute。\n\n因为显式定义的 prop 适用于向一个子组件传入信息，然而组件库的作者并不总能预见组件会被用于怎样的场景。这也是为什么组件可以接受任意的 attribute，而这些 attribute 会被添加到这个组件的根元素上。\n\n例如，想象一下你通过一个 Bootstrap 插件使用了一个第三方的 `<bootstrap-date-input>` 组件，这个插件需要在其 `<input>` 上用到一个 `data-date-picker` attribute。我们可以将这个 attribute 添加到你的组件实例上：\n\n``` html\n<bootstrap-date-input data-date-picker=\"activated\"></bootstrap-date-input>\n```\n\n然后这个 `data-date-picker=\"activated\"` attribute 就会自动添加到 `<bootstrap-date-input>` 的根元素上。\n\n### 替换/合并已有的 Attribute\n\n想象一下 `<bootstrap-date-input>` 的模板是这样的：\n\n``` html\n<input type=\"date\" class=\"form-control\">\n```\n\n为了给我们的日期选择器插件定制一个主题，我们可能需要像这样添加一个特别的类名：\n\n``` html\n<bootstrap-date-input\n  data-date-picker=\"activated\"\n  class=\"date-picker-theme-dark\"\n></bootstrap-date-input>\n```\n\n在这种情况下，我们定义了两个不同的 `class` 的值：\n\n- `form-control`，这是在组件的模板内设置好的\n- `date-picker-theme-dark`，这是从组件的父级传入的\n\n对于绝大多数 attribute 来说，从外部提供给组件的值会替换掉组件内部设置好的值。所以如果传入 `type=\"text\"` 就会替换掉 `type=\"date\"` 并把它破坏！庆幸的是，`class` 和 `style` attribute 会稍微智能一些，即两边的值会被合并起来，从而得到最终的值：`form-control date-picker-theme-dark`。\n\n### 禁用 Attribute 继承\n\n如果你**不**希望组件的根元素继承 attribute，你可以在组件的选项中设置 `inheritAttrs: false`。例如：\n\n```js\nVue.component(\'my-component\', {\n  inheritAttrs: false,\n  // ...\n})\n```\n\n这尤其适合配合实例的 `$attrs` property 使用，该 property 包含了传递给一个组件的 attribute 名和 attribute 值，例如：\n\n```js\n{\n  required: true,\n  placeholder: \'Enter your username\'\n}\n```\n\n有了 `inheritAttrs: false` 和 `$attrs`，你就可以手动决定这些 attribute 会被赋予哪个元素。在撰写[基础组件](../style-guide/#基础组件名-强烈推荐)的时候是常会用到的：\n\n```js\nVue.component(\'base-input\', {\n  inheritAttrs: false,\n  props: [\'label\', \'value\'],\n  template: `\n    <label>\n      {{ label }}\n      <input\n        v-bind=\"$attrs\"\n        v-bind:value=\"value\"\n        v-on:input=\"$emit(\'input\', $event.target.value)\"\n      >\n    </label>\n  `\n})\n```\n\n<p class=\"tip\">注意 `inheritAttrs: false` 选项**不会**影响 `style` 和 `class` 的绑定。</p>\n\n这个模式允许你在使用基础组件的时候更像是使用原始的 HTML 元素，而不会担心哪个元素是真正的根元素：\n\n```html\n<base-input\n  label=\"Username:\"\n  v-model=\"username\"\n  required\n  placeholder=\"Enter your username\"\n></base-input>\n```\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 258, 1, '2021-9-23 23:46:23', '2021-9-25 10:29:02', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (217, 10000, 'Vue中native的用法', 'Vue中native的用法', '### Vue中native的用法\n#### native\nnative在Vue.js官方的大致意思是监听自定义标签根标签的事件，将原生事件绑定到组件上，比如a标签可以直接绑定原生事件，但是如果你通过自定义封装了button标签，起成了名字myself-abutton，这时候绑定事件就需要加上native了，下面写一个简单的例子方便理解：\n\n例子\n四个按钮，分别是普通标签不加native和加native，自定义标签不加native和加native\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"utf-8\">\n  <meta name=\"viewport\" content=\"width=device-width\">\n  <title>JS Bin</title>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.3/vue.js\"></script> \n</head>\n<body>\n<div id=\"app\">\n  <button @click=\"add(this)\">普通的html标签，不包含native的按钮</button><br/>\n  <button @click.native=\"add(this)\">普通的html标签，包含native的按钮</button><br/>\n  <myself-button @click=\"add(this)\"/></myself-button><br/>\n  <myself-button @click.native=\"add(this.id)\"/></myself-button>\n  <div>\n</body>\n  <script>\n    Vue.component(\'myself-button\', {\n        template: `<button>我是自定义的标签</button>`\n    });\n    var vm=new Vue({\n      el:\"#app\",\n      data:{\n      },\n      methods:{\n        add:function(obj){\n          console.log(obj+\'我触发了\');\n        },\n      }\n    });\n  </script>\n</html>\n```\n大家猜测一下哪个按钮会触发事件，下面我依次点击了四个按钮，console中的结果如图\n\n![https://img-blog.csdnimg.cn/20191023154034943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDI4MDM1,size_16,color_FFFFFF,t_70](https://img-blog.csdnimg.cn/20191023154034943.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDI4MDM1,size_16,color_FFFFFF,t_70)\n现在native的作用就很显而易见了', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 30, 1, '2021-10-18 14:53:27', '2021-11-14 11:38:57', 'https://blog.csdn.net/qq_41428035/article/details/102702850', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (218, 10000, 'js之render函数的用法', 'js之render函数的用法', '```js\n{\n            title: \"上传附件\",\n            key: \"appendix\",\n            render: (h, {row}) => {\n              let appendix = row.appendix;\n              let btnContent = \"未上传\";\n              if (true) {\n                return h(\'Upload\', {\n                  props: {action: \"//jsonplaceholder.typicode.com/posts/\"}, on: {\n                    click: e => {\n                      if (e) {\n                        e.stopPropagation();\n                      } else {\n                        window.event.returnValue = false;\n                      }\n                      console.log(\'hello\');\n                    }\n                  },\n                }, [\n                  h(\'a\', {\n                    style: {\n                      marginRight: \'5px\',\n                    },\n                  }, btnContent),\n                  h(\'Icon\', {\n                    props: {\n                      type: \"md-arrow-round-up\",\n                    },\n                    style: {\n                      marginRight: \'5px\',\n                      fontSize: \"16px\",\n                      color: \"#2d8cf0\",\n                    },\n                  }),\n                ]);\n              }\n            }\n          },\n```', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 22, 1, '2021-10-20 17:14:06', '2021-10-25 14:07:38', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (219, 10000, 'JS多个无关联的异步操作，怎么做到某个异步操作一完成就可以使用', '在JS中，我们常常会碰到这种情况：两个或多个不相关（即一个异步操作不会使用到其它异步操作的结果）的异步操作，这个时候我们想实现，只要某个异步操作一完成，它的结果直接就可以使用，而不需要等待其它异步操作完成？<br>比如一个页面中有两个文本框，文本框中的内容对应两个接口，怎么实现只要某个接口一加载完就可以直接显示内容呢？', '### 案例分析\n在JS中，我们常常会碰到这种情况：两个或多个不相关（即一个异步操作不会使用到其它异步操作的结果）的异步操作，这个时候我们想实现，只要某个异步操作一完成，它的结果直接就可以使用，而不需要等待其它异步操作完成？\n比如一个页面中有两个文本框，文本框中的内容对应两个接口，怎么实现只要某个接口一加载完就可以直接显示内容呢？\n\n### 代码\n如有下面两个异步操作，f1的执行时间是6秒，f2的执行时间是3秒。\n```js\nfunction f1() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(\'f1已完成\');\n            resolve(\'success1\');\n        }, 6000)\n    })\n}\n\nfunction f2() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(\'f2已完成\');\n            resolve(\'success2\');\n        }, 3000)\n    })\n}\n```\n### 1.一般我们怎么实现(不满足要求)？\n#### 1. async/await实现方式\n```js\nasync function bar() {\n    let res1 = f1();\n    let res2 = f2();\n    let res3 = await res1;\n    console.log(res3);\n    let res4 = await res2;\n    console.log(res4);\n}\n//输出情形\n//第3s时\nf2已完成\n//第6秒时\nf1已完成\nsuccess1\nsuccess2\n```\n#### 2. Promise.all实现方式\n```js\nasync function bar3() {\n    let [res1, res2] = await Promise.all([f1(), f2()])\n    console.log(res1, res2)\n}\n//输出情形\n//第3s时\nf2已完成\n//第6秒时\nf1已完成\nsuccess1 success2\n```\n可以看到async/await和Promise.all这两种异步同时进行的方式并不能满足我们“一结束就显示”的要求。\n### 2.满足要求怎么实现？\n#### 1. 传统的`.then`实现\n```js\nasync function bar2() {\n    f1().then(res1 => {\n        console.log(res1)\n    })\n    f2().then(res2 => {\n        console.log(res2)\n    })\n}\n//输出情形\n//第3s时\nf2已完成\nsuccess2\n//第6秒时\nf1已完成\nsuccess1\n```\n#### 2.拆分成两个方法\n```\nasync function sep1(){\n    let res1 = await f1();\n    console.log(res1);\n}\nasync function sep2(){\n    let res2 = await f2();\n    console.log(res2);\n}\nsep1()\nsep2()\n//输出情形\n//第3s时\nf2已完成\nsuccess2\n//第6秒时\nf1已完成\nsuccess1\n```', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 13, 1, '2021-10-28 17:30:05', '2021-10-28 17:32:10', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (220, 10000, 'v-model 控制组件显示隐藏', 'v-model&emsp;控制组件显示隐藏', '### 1、v-model原理\n监听了 input事件\n\n### 2、实现\n```js\n//组件引用\n<user-detail v-model=\"showUserDetail\"></user-detail>\ndata() {\n    return {\n        showUserDetail: false\n     }\n}\n\nshowDeail(){ //打开子组件\n     this.showUserDetail = true;\n}\n\n//userDetail组件实现\n<div v-if=\"show\">我是userDetail</div>\n\nprops: {\n    value: {  //父组件使用v-model 默认vue会给子组件传一个名称为value的props\n        type: Boolean,\n        default: false\n    }\n}\n\ndata() {\n    return {\n        show: false\n     }\n}\n\nwatch: { //监听value变化，同步show的值（因为 子组件不能修改父组件传过来的props，所以需要重新定一个字段来同步变化）\n    value(n, o) {\n        this.show = n;\n    }\n}\n\nclose() {\n   this.$emit(\'input\', false); // 需要关闭组件时，触发input事件 设置父组件showUserDetail 为false\n }\n```\n\n参考：\nhttps://www.jianshu.com/p/471f35cbaeb3\nhttps://www.cnblogs.com/24decade/p/12725421.html\nhttps://blog.csdn.net/qq_39024950/article/details/114288843', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 10, 1, '2021-10-30 13:43:59', '2021-10-30 13:43:59', 'https://www.jianshu.com/p/471f35cbaeb3', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (221, 10000, '遇到一段疑惑的代码，async/await和Promise/then', '遇到一段疑惑性的代码，async/await和Promise/then', '今天在公司看到一段奇怪的代码，大概意思我把它简化出来，写成如下代码\n```js\nfunction f1() {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            console.log(\'f1已完成\');\n            resolve(\'success1\');\n        }, 6000)\n    })\n}\n\nasync function foo() {\n    let res = await f1().then(res => {\n        console.log(\"res1:\", res);\n        return \'hello\'\n    });\n    console.log(\"res2:\", res);\n}\n\nfoo();\n\n// output\n// f1已完成\n// res1: success1\n// res2: undefined\n```\n问题是：既然都用`await`了，为什么要用`then`,换句话说，如果要用`then`,那就不要用`async/awiat`了。\n不过这里也有个思考，`res2`输出的是`undefined`，这是因为await等待的是`Promise`的结果，而不是`Promise`本身，如果想让`res2`有值，我们可以在`then`中返回一些数据。\n```js\nasync function foo() {\n    let res = await f1().then(res => {\n        console.log(\"res1:\", res);\n        return \'hello\';\n    });\n    console.log(\"res2:\", res);\n}\n\nfoo()\n\n// output\n// f1已完成\n// res1: success1\n// res2: hello\n```\n但是这都不是最主要的，最主要的是我们该怎么写？\n写法1：Promise和then\n```js\nfunction foo() {\n    f1().then(res => {\n        console.log(\"res1:\", res);\n    });\n}\n\n// output\n// f1已完成\n// res1: success1\n```\n写法2：async和await\n```js\nasync function foo() {\n    let res = await f1();\n    console.log(\"res1:\", res);\n}\n\nfoo()\n\n// output\n// f1已完成\n// res1: success1\n```\n结论：关于异步处理，规范的写法，要么就用Promise/then要么就用async/await,在后者中使用前者，看起来很奇怪，而且这种情况下前者也没有任何作用。\n', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 92, 1, '2021-11-1 10:31:34', '2022-2-17 09:14:00', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (222, 10000, 'emoji测试', 'emoji测试', 'emoji测试\n&#x1F603;&#x1F60A;\n![壁纸2.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202111/14/20211114204155%E5%A3%81%E7%BA%B82.jpg)\n\n?\n??\n?', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 67, 1, '2021-11-14 20:27:32', '2021-11-16 11:19:12', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (223, 10000, 'JS工具函数', 'JS工具函数', '#### 1. 判断参数是否是其中之一\n```js\n// 判断参数是否是其中之一\nexport function oneOf (value, validList) {\n    for (let i = 0; i < validList.length; i++) {\n        if (value === validList[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n```', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/webLogo.jpg', 0, 0, 30, 1, '2021-11-15 10:42:56', '2021-11-15 10:42:56', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (224, 10000, 'Vue出现{ob: Observer}的原因分析', 'Vue出现{ob:&emsp;Observer}的原因分析，{ob:&emsp;Observer}中明明有值，却取不到', '场景： 在往一个对象中添加属性后再打印出来，打印出来的数据明明有这个值却取不到。\n原因分析： 在Vue中，数据是响应式的，所有在往对象中添加属性的时候不能直接通过属性名进行添加，具体细则请查看官网关于[检测变化的注意事项](https://cn.vuejs.org/v2/guide/reactivity.html#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9)。\n案例源码\n```js\n// let cacheList = localStorage.cacheList && JSON.parse(localStorage.cacheList);\nlet cacheList = {};\n\nfunction getCache() {\n  if (!localStorage.cacheList) {\n    localStorage.setItem(\"cacheList\", \"{}\");\n  }\n  cacheList = JSON.parse(localStorage.cacheList);\n}\n\ngetCache();\n\nconst moduleA = {\n  state: {\n    // cacheList: {},\n  },\n  mutations: {\n    saveList(state, {stateName, stateValue}) {\n      console.log(stateName);\n      console.log(stateValue);\n      // 保存到Vuex\n      // state.cacheList = {...state.cacheList, stateName: stateValue};\n      state[stateName] = stateValue;\n\n      // 保存到localStorage\n      cacheList[stateName] = stateValue;\n      localStorage.setItem(\"cacheList\", JSON.stringify(cacheList));\n    },\n    initState(state) {\n      state = cacheList;\n      console.log(state);\n    },\n  },\n  actions: {},\n  getters: {}\n};\n\nexport default moduleA;\n```\nmultiChoice.vue\n```js\n<template>\n  <div class=\"multiple-choice\">\n    <Poptip placement=\"left-start\">\n      <Icon class=\"config\" type=\"ios-settings-outline\"/>\n      <div class=\"api\" slot=\"content\">\n        <CheckboxGroup v-model=\"checkedList\" @on-change=\"onChange\">\n          <Checkbox v-for=\"item in columnsDynamic\"\n                    :label=\"item.title\"\n                    :key=\"item.key\"\n                    :disabled=\"item.disabled\">{{item.title}}\n          </Checkbox>\n        </CheckboxGroup>\n      </div>\n    </Poptip>\n  </div>\n</template>\n\n<script>\n  import {mapGetters} from \'vuex\';\n\n  export default {\n    name: \"multipleChoice\",\n    props: [\'columnsDynamic\'],\n    data() {\n      return {\n        checkedList: [],\n      };\n    },\n    computed: {\n      ...mapGetters([\'getList\']),\n      mcState() {\n        return this.$store.state.multipleChoice;\n      },\n      stateName() {\n        return this.$route.name + \"List\";\n      },\n      stateValue() {\n        return this.checkedList;\n      },\n    },\n    methods: {\n      initData() {\n        // debugger;\n        this.$store.commit(\"initState\");\n        console.log(this.mcState);\n        console.log(this.stateName);\n        console.log(this.mcState[this.stateName]);\n        if (this.mcState[this.stateName]) {\n          // 如果localStorage有缓存\n          this.checkedList = this.mcState[this.stateName];\n        } else {\n          // 如果localStorage没有缓存\n          // 需要修改成不传checked也为true吗？\n          // this.checkedList = this.columnsDynamic.filter(v => v.checked || undefined).map(v => v.title);\n          this.checkedList = this.columnsDynamic.filter(v => v.checked).map(v => v.title);\n          let payload = {stateName: this.stateName, stateValue: this.stateValue};\n          this.$store.commit(\"saveList\", payload);\n        }\n\n        // 修改表头列表\n        this.columnsDynamic.map(v => {\n          v.checked = this.checkedList.includes(v.title);\n        });\n        this.$emit(\"columnsChange\", this.columnsDynamic);\n      },\n      onChange(value) {\n        this.columnsDynamic.map(v => {\n          v.checked = !!value.includes(v.title);\n        });\n        this.$emit(\"columnsChange\", this.columnsDynamic);\n        this.checkedList = value;\n        this.storageOpe();\n      },\n      storageOpe() {\n        let payload = {stateName: this.stateName, stateValue: this.stateValue};\n        this.$store.commit(\"saveList\", payload);\n      },\n    },\n    created() {\n      this.initData();\n    },\n  };\n</script>\n\n<style lang=\"scss\" scoped>\n  .multiple-choice {\n    display: flex;\n    justify-content: center;\n    /*border: 1px solid #144e80;*/\n    cursor: pointer;\n\n    .config {\n      /*width: 32px;*/\n      /*height: 32px;*/\n      margin-right: 10px;\n      line-height: 36px;\n      text-align: center;\n      color: #fff;\n      font-size: 18px;\n    }\n\n    .ivu-checkbox-group {\n      display: flex;\n      flex-direction: column;\n\n      .ivu-checkbox-group-item {\n        color: #fff;\n        margin: 2px 0;\n      }\n    }\n  }\n</style>\n```\n原因就是改变了`state = cacheList;`改变了state的指向，vue监听不到了，虽然有数据，但是取不到。\n改进后：\nmultipleChoice.vue\n```js\n<template>\n  <div class=\"multiple-choice\">\n    <Poptip placement=\"left-start\">\n      <Icon class=\"config\" type=\"ios-settings-outline\"/>\n      <div class=\"api\" slot=\"content\">\n        <CheckboxGroup v-model=\"checkedList\" @on-change=\"onChange\">\n          <Checkbox v-for=\"item in columnsDynamic\"\n                    :label=\"item.title\"\n                    :key=\"item.key\"\n                    :disabled=\"item.disabled\">{{item.title}}\n          </Checkbox>\n        </CheckboxGroup>\n      </div>\n    </Poptip>\n  </div>\n</template>\n\n<script>\n  export default {\n    name: \"multipleChoice\",\n    props: [\'columnsDynamic\'],\n    data() {\n      return {\n        checkedList: [],\n      };\n    },\n    computed: {\n      mcState() {\n        return this.$store.state.multipleChoice;\n      },\n      stateName() {\n        return this.$route.name + \"List\";\n      },\n      stateValue() {\n        return this.checkedList;\n      },\n    },\n    methods: {\n      initData() {\n        // debugger;\n        this.$store.commit(\"initState\");\n        if (this.mcState.cacheList[this.stateName]) {\n          // 如果localStorage有缓存\n          this.checkedList = this.mcState.cacheList[this.stateName];\n        } else {\n          // 如果localStorage没有缓存\n          // 需要修改成不传checked也为true吗？\n          // this.checkedList = this.columnsDynamic.filter(v => v.checked || undefined).map(v => v.title);\n          this.checkedList = this.columnsDynamic.filter(v => v.checked).map(v => v.title);\n          let payload = {stateName: this.stateName, stateValue: this.stateValue};\n          this.$store.commit(\"saveList\", payload);\n        }\n\n        // 修改表头列表\n        this.columnsDynamic.map(v => {\n          v.checked = this.checkedList.includes(v.title);\n        });\n        this.$emit(\"columnsChange\", this.columnsDynamic);\n      },\n      onChange(value) {\n        this.columnsDynamic.map(v => {\n          v.checked = !!value.includes(v.title);\n        });\n        this.$emit(\"columnsChange\", this.columnsDynamic);\n        this.checkedList = value;\n        this.storageOpe();\n      },\n      storageOpe() {\n        let payload = {stateName: this.stateName, stateValue: this.stateValue};\n        this.$store.commit(\"saveList\", payload);\n      },\n    },\n    created() {\n      this.initData();\n    },\n  };\n</script>\n\n<style lang=\"scss\" scoped>\n  .cacheList {\n    position: fixed;\n    width: 100%;\n    top: 100px;\n    color: white;\n  }\n\n  .multiple-choice {\n    display: flex;\n    justify-content: center;\n    /*border: 1px solid #144e80;*/\n    cursor: pointer;\n\n    .config {\n      /*width: 32px;*/\n      /*height: 32px;*/\n      margin-right: 10px;\n      line-height: 36px;\n      text-align: center;\n      color: #fff;\n      font-size: 18px;\n    }\n\n    .ivu-checkbox-group {\n      display: flex;\n      flex-direction: column;\n\n      .ivu-checkbox-group-item {\n        color: #fff;\n        margin: 2px 0;\n      }\n    }\n  }\n</style>\n```\nmultipleChoice.js\n```js\nlet cacheList = {};\n\nfunction getCache() {\n  if (!localStorage.cacheList) {\n    localStorage.setItem(\"cacheList\", \"{}\");\n  }\n  try {\n    cacheList = JSON.parse(localStorage.cacheList);\n  } catch (e) {\n    console.error(e);\n  }\n}\n\ngetCache();\n\nconst moduleA = {\n  state: () => ({\n    cacheList: {},\n  }),\n  mutations: {\n    saveList(state, {stateName, stateValue}) {\n      // 保存到Vuex\n      state.cacheList = {...state.cacheList, [stateName]: stateValue};\n      // state.cacheList[stateName] = stateValue;\n\n      // 保存到localStorage\n      cacheList[stateName] = stateValue;\n      localStorage.setItem(\"cacheList\", JSON.stringify(cacheList));\n    },\n    initState(state) {\n      state.cacheList = cacheList;\n    },\n  },\n  actions: {},\n  getters: {}\n};\n\nexport default moduleA;\n```', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 34, 1, '2021-11-17 11:21:15', '2022-2-9 10:00:18', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (225, 10000, 'Chrome浏览器编辑模式', 'Chrome浏览器开启编辑模式', '> 本文于 *2022-02-16* 更新\n\n1.在Chrome按`ctrl+shift+B`唤出/隐藏书签栏。\n2.在书签栏右键->添加网页，并在网址中输入以下代码\n\n```js\njavascript:(function () {\n      if (document.body.contentEditable != \'true\') {\n        document.body.contentEditable = true; document.designMode = \'on\'; void 0\n      } else {\n        document.body.contentEditable = false; document.designMode = \'off\'; void 0\n      }\n})()\n```\n3.点击新建的书签，试试浏览器是否开启/关闭编辑模式', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 108, 1, '2021-11-25 23:22:54', '2022-2-16 17:00:36', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (226, 10000, 'Promise/then和async/await一定能互相转换吗？', 'Promise/then和async/await一定能互相转换吗？', 'Promise/then和async/await一定能互相转换吗？', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 22, 1, '2021-12-6 10:39:08', '2021-12-6 10:39:08', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (227, 10005, '我是刘飞', 'wwwwwwwwwww', '刘飞刘飞\n刘小飞刘小飞\nsb输入法\n这个发表模块不人性\n建议修改', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/202112/21/20211221135750test.jpg', 0, 0, 45, 1, '2021-12-21 13:59:44', '2021-12-21 13:59:44', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (228, 10000, '1', '1', '```js\naxios(`${this.url.downloadCurveHis}?sohDeviceCfgId=${this.id}&startTime=${this.startTime}&endTime=${this.endTime}`,\n                    {\n                        // sohDeviceCfgId: this.id,\n                        // startTime: this.startTime,\n                        // endTime: this.endTime\n                    },\n                    {\n                        responseType: \'blob\'\n                    }\n```', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 4, 1, '2022-1-6 09:44:57', '2022-1-6 09:44:57', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (229, 10000, 'echart颜色', 'echart颜色', '```js\n[\"#2ec7c9\",\"#b6a2de\",\"#5ab1ef\",\"#ffb980\",\"#d87a80\",\"#8d98b3\",\"#e5cf0d\",\"#97b552\",\"#95706d\",\"#dc69aa\",\"#07a2a4\",\"#9a7fd1\",\"#588dd5\",\"#f5994e\",\"#c05050\",\"#59678c\",\"#c9ab00\",\"#7eb00a\",\"#6f5553\",\"#c14089\"]\n```', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 7, 1, '2022-1-10 08:55:24', '2022-1-10 08:55:24', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (230, 10000, 'eval((function(){console.log(\"hello\")})())', 'eval((function(){console.log(\"hello\")})())', 'eval((function(){console.log(\"hello\")})())', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 13, 1, '2022-1-28 11:46:27', '2022-2-8 08:56:17', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (231, 10005, '飞飞小陈小超是啥b', '我恁爹', '我是林超群的爷爷\n你们是怎么教林超群的\n林超群回家骂我大帅哥\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/202202/15/20220215114408test.jpg', 0, 0, 24, 1, '2022-2-15 11:46:02', '2022-2-15 11:46:02', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (234, 10000, '发布测试', '发布测试', '发布测试', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 5, 1, '2022-2-15 12:35:19', '2022-2-15 12:36:31', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (235, 10000, '1', '1', '1', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 0, 1, '2022-2-15 19:13:09', '2022-2-15 19:13:09', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (236, 10000, '123', '123', '123', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 0, 1, '2022-2-15 19:14:46', '2022-2-15 19:14:46', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (237, 10000, '1', '1', '1', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 1, 1, '2022-2-15 19:17:58', '2022-2-15 19:17:58', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (238, 10000, '123123', '123123', '### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001\n### 00000000000000000000000000000000000001', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 15, 1, '2022-2-15 19:18:38', '2022-3-5 17:16:00', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (239, 10000, '1', '1', '1', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 1, 1, '2022-2-15 19:32:57', '2022-2-15 19:32:57', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (240, 10000, '脚本', '11', '脚本内容\n```js\n// ==UserScript==\n// @name         New Userscript\n// @namespace    http://tampermonkey.net/\n// @version      0.1\n// @description  try to take over the world!\n// @author       You\n// @match        *://*.shandong.gov.cn/*\n// @icon         https://www.google.com/s2/favicons?sz=64&domain=tampermonkey.net\n// @grant        none\n// ==/UserScript==\n\n(function() {\n    \'use strict\';\n\n    console.log(\'开始运行\');\n\n    let page = document.getElementById(\'fy_list\').querySelector(\'div\').querySelectorAll(\'a\');\n    console.log(page[2]);\n    // setTimeout(()=>{\n    //     console.log(page[2])\n    //    page[2].click();\n    // }, 1000)\n\n    let button = document.createElement(\"button\");\n    button.innerHTML = \'下一页\';\n    button.style.cssText = \'position: absolute;top: 10px; right: 10px;\';\n    let body = document.querySelector(\'body\');\n    body.appendChild(button);\n    button.onclick = ()=>{\n        page[2].click();\n    }\n\n    let data = []\n\n    let trlist = document.querySelector(\'.datalist\').querySelector(\'tbody\').querySelectorAll(\'tr\');\n    trlist.forEach(tr=>{\n        let st = \'\';\n        let obj = {};\n        let tdList = tr.querySelectorAll(\'td\');\n        obj.no = tdList[0].innerHTML.trim();\n        obj.code = tdList[1].innerHTML.trim();\n        obj.name = tdList[2].innerHTML.trim();\n        obj.type = tdList[3].innerHTML.trim();\n        obj.specification = tdList[4].innerHTML.trim();\n        obj.wrap = tdList[5].innerHTML.trim();\n        obj.price = tdList[6].innerHTML.trim();\n        obj.priceFormat = tdList[7].innerHTML.trim();\n        obj.vendor = tdList[8].innerHTML.trim();\n        obj.insurance = tdList[9].innerHTML.trim();\n        console.log(obj);\n        data.push(obj);\n\n\n        // tr.querySelectorAll(\'td\').forEach((td, index, data)=>{\n        //     if(index === data.length - 1){\n        //         return;\n        //     }\n        //     st += td.innerHTML.trim() + \' \';\n        // })\n        // console.log(st);\n    })\n\n\n\n    fetch(\'http://localhost:8090/user/medicine\',{\n        method: \'POST\',\n        headers: {\n            \'Content-Type\': \'application/json\'\n        },\n        body: JSON.stringify(data),\n        mode:\'cors\'\n    }).then(res=>{\n        console.log(res);\n    })\n\n\n\n    // Your code here...\n})();\n```\n\nMedicine.java\n```java\nimport lombok.Data;\n\n@Data\npublic class Medicine {\n    private String no;\n    private String code;\n    private String name;\n    private String type;\n    private String specification;\n    private String wrap;\n    private String price;\n    private String priceFormat;\n    private String vendor;\n    private String insurance;\n}\n```\n\n接口\n```java\n@RequestMapping(\"/medicine\")\n    public String medicine(@RequestBody List<Medicine> medicine) {\n        System.out.println(medicine);\n        for (int i = 0; i < medicine.size(); i++){\n            System.out.println(medicine.get(i));\n        }\n        return \"666666\";\n    }\n```\n\nFilterDemo.java\n```java\npackage com.kehua.dcim.filter;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class FilterDemo implements Filter {\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        System.out.println(\"过滤器开始初始化\");\n    }\n\n    @Override\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n//        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;\n        System.out.println(\"过滤器开始工作。。\");\n//        filterChain.doFilter(servletRequest,servletResponse);\n\n        HttpServletResponse response = (HttpServletResponse) res;\n        HttpServletRequest reqs = (HttpServletRequest) req;\n        String curOrigin = reqs.getHeader(\"Origin\");\n        response.setHeader(\"Access-Control-Allow-Origin\", curOrigin == null ? \"true\" : curOrigin);\n        response.setHeader(\"Access-Control-Allow-Credentials\", \"true\");\n        response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, PATCH, DELETE, PUT\");\n        response.setHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n        chain.doFilter(req, res);\n    }\n\n    @Override\n    public void destroy() {\n        System.out.println(\"过滤器开始销毁\");\n    }\n}\n```\n\nFilterConfig.java\n```java\npackage com.kehua.dcim.config;\n\n//import com.kehua.dcim.filter.FilterDemo;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.web.servlet.config.annotation.CorsRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n\n\n@Configuration\npublic class FilterConfig extends WebMvcConfigurerAdapter {\n//    @Bean\n//    @Order(2)\n    //spring boot会按照order值的大小，从小到大的顺序来依次过滤\n//    public FilterRegistrationBean configFilter(){\n//        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();\n//        filterRegistrationBean.setFilter(new FilterDemo());\n//        filterRegistrationBean.addUrlPatterns(\"/*\");\n//        filterRegistrationBean.setName(\"sessionFilter\");\n//        //filterRegistrationBean.setOrder(2);\n//        return filterRegistrationBean;\n//    }\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(\"/**\").allowedOriginPatterns(\"*\")\n                .allowedMethods(\"GET\", \"HEAD\", \"POST\",\"PUT\", \"DELETE\", \"OPTIONS\")\n                .allowCredentials(true).maxAge(3600);\n    }\n\n}\n```', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 54, 1, '2022-2-15 20:44:08', '2022-4-24 11:11:24', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (241, 10005, '杀马特团长', '杀马特团长&emsp;魏小超<br>虎哥&emsp;小毛<br>小亮&emsp;小飞', '啊团长你就是歌姬吧！', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/202202/17/20220217111227test.jpg', 0, 0, 11, 1, '2022-2-17 11:14:11', '2022-2-17 11:14:11', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (242, 10005, '太恐怖了，整个朋友圈都在疯传这个！', '太恐怖了，整个朋友圈都在疯传这个！', '2017年12月8号在河南省郑州市河南工业大学莲花街校区。\n大一新生**魏小超**（化名）因不满辅导员对其的惩罚，一气之下竟变成了一个格莫拉怪兽。\n![psc.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202202/17/20220217114116psc.jpg)\n就在校园存亡之际，一名勇敢的学生站了出来，他就是我们的光之巨人————**统统奥特曼**，统统奥特曼发射了梅塔利姆光线，战胜了怪兽，解救了学校的安危，据现场人报道并没有造成人员伤亡，下面是当时的学校学生拍下的几张珍贵照片。\n![psc 1.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202202/17/20220217114157psc%20(1).jpg)![psc 2.jpg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202202/17/20220217114157psc%20(2).jpg)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/202202/17/20220217115016123.jpg', 0, 0, 80, 1, '2022-2-17 11:48:17', '2022-2-17 12:27:34', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (244, 10000, 'Vue中props与refs结合使用时导致的数据更新延迟问题', 'Vue中props与refs结合使用时导致的数据更新延迟问题,导致使用$refs.xxx调用子组件中的函数时，参数还是更新前的数据。', '###  问题描述\n今天想实现如下图所示的一个需求，父组件中有一个`areaId`数据，并以prop形式传递给子组件，父组件包含一个按钮类的组件，点击后`areaId+1`，并请求所有组件的数据。问题是在点击按钮后，子组件在请求中的areaId,并不是父组件中最新的`areaId`。\n<div style=\"width: 80%\">\n\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202202/20/20220220101720image.png)\n\n</div>\n\n\n### 代码如下\nParent.vue\n```js\n<template>\n  <div>\n    <button @click=\"handleCount\">count+1</button>\n    <Child1 ref=\"child1\" :count=\"count\"/>\n    <Child2 ref=\"child2\" :count=\"count\"/>\n  </div>\n</template>\n\n<script>\n  import Child1 from \"./child/Child1\";\n  import Child2 from \"./child/Child2\";\n\n  export default {\n    name: \"Parent\",\n    components: {\n      Child1,\n      Child2\n    },\n    data() {\n      return {\n        count: 0\n      }\n    },\n    methods: {\n      handleCount() {\n        this.count += 1;\n        this.$refs.child1.printCount();\n        this.$refs.child2.printCount();\n      }\n    }\n  }\n</script>\n```\nChild1.vue\n```js\n<template>\n  <div>\n    Child1的count:{{count}}\n  </div>\n</template>\n\n<script>\n  export default {\n    name: \"Child1\",\n    props: [\'count\'],\n    methods: {\n      printCount() {\n        console.log(\"Child1的count:\" + this.count);\n      }\n    }\n  }\n</script>\n```\nChild2.vue\n```js\n<template>\n  <div>\n    Child2的count:{{count}}\n  </div>\n</template>\n\n<script>\n  export default {\n    name: \"Child2\",\n    props: [\'count\'],\n    methods: {\n      printCount() {\n        console.log(\"Child2的count:\" + this.count);\n      }\n    }\n  }\n</script>\n```\n点击Parent中的按钮后，控制台的输出如下\n![image.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202202/20/20220220102339image.png)\n可以看到，DOM上是最新的数据没有疑问，但是，输出的却是之前的数据。\n\n### 原因分析\n1. ref是作为结果的。这一点在官网中有提及。[访问子组件实例或子元素](https://cn.vuejs.org/v2/guide/components-edge-cases.html#%E8%AE%BF%E9%97%AE%E5%AD%90%E7%BB%84%E4%BB%B6%E5%AE%9E%E4%BE%8B%E6%88%96%E5%AD%90%E5%85%83%E7%B4%A0)\n> $refs 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 $refs。\n\n所以ref在渲染完成后生效,这也就意味着ref并不是响应式的。\n\n2. props是类似模块的方式传递数据的,根据Vue的MVVM的特点，在更新了`Model`层后，并不意味这`View`层的同步更新，所以此时以`ref`形式调用的话，此时子组件中通过`ref`访问的`areaId`还是`Model`更新之前的数据，才出现了上面所描述的情况。\n\n### 解决方法\n1.使用`&nextTick`，来保证在DOM层更新之后再发起请求。\n```js\n<template>\n  <div>\n    <button @click=\"handleCount\">count+1</button>\n    <Child1 ref=\"child1\" :count=\"count\"/>\n    <Child2 ref=\"child2\" :count=\"count\"/>\n  </div>\n</template>\n\n<script>\n  import Child1 from \"./child/Child1\";\n  import Child2 from \"./child/Child2\";\n\n  export default {\n    name: \"Album\",\n    components: {\n      Child1,\n      Child2\n    },\n    data() {\n      return {\n        count: 0\n      }\n    },\n    methods: {\n      handleCount() {\n        this.count += 1;\n        this.$nextTick(()=>{\n          this.$refs.child1.printCount();\n          this.$refs.child2.printCount();\n        })\n      }\n    }\n  }\n</script>\n```\n\n\n2.不使用props形式，使用参数传递形式。\n\n```js\n<template>\n  <div>\n    <button @click=\"handleCount\">count+1</button>\n    <Child1 ref=\"child1\" :count=\"count\"/>\n    <Child2 ref=\"child2\" :count=\"count\"/>\n  </div>\n</template>\n\n<script>\n  import Child1 from \"./child/Child1\";\n  import Child2 from \"./child/Child2\";\n\n  export default {\n    name: \"Album\",\n    components: {\n      Child1,\n      Child2\n    },\n    data() {\n      return {\n        count: 0\n      }\n    },\n    methods: {\n      handleCount() {\n        this.count += 1;\n        this.$nextTick(()=>{\n          this.$refs.child1.printCount(this.count);\n          this.$refs.child2.printCount(this.count);\n        })\n      }\n    }\n  }\n</script>\n```\n\n\n\n\n\n\n\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/vuelogo.png', 0, 0, 260, 1, '2022-2-20 10:40:34', '2022-3-3 13:38:57', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (245, 10000, 'JS中attribute和property的区别', 'JS中attribute和property的区别', 'JS中attribute和property的区别', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 39, 1, '2022-3-2 16:40:14', '2022-7-7 08:54:33', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (246, 10000, '1', '1', '![71FB6E37812342DEB25E0412E6823E2E.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202203/22/2022032216263971FB6E37-8123-42DE-B25E-0412E6823E2E.png)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 4, 1, '2022-3-22 16:27:08', '2022-3-22 16:27:08', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (247, 10000, '1', '1', '![E64CF5BFEA9B49B5A6DB39CE5458FF4F.png](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202203/24/20220324151916E64CF5BF-EA9B-49B5-A6DB-39CE5458FF4F.png)![57C2593F1A38452AB5526038B5A94CB7.jpeg](https://youyu-source.oss-cn-beijing.aliyuncs.com/blogImages/202203/24/2022032415191757C2593F-1A38-452A-B552-6038B5A94CB7.jpeg)', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 2, 1, '2022-3-24 15:19:55', '2022-3-24 15:19:55', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (248, 10000, '1', '1', '# 响应式计算和侦听\n\n> 本节使用[单文件组件](single-file-component.html)语法作为代码示例\n\n## 计算值\n\n有时我们需要依赖于其他状态的状态——在 Vue 中，这是用组件[计算属性](computed.html#计算属性和侦听器)处理的，以直接创建计算值，我们可以使用 `computed` 函数：它接受 getter 函数并为 getter 返回的值返回一个不可变的响应式 [ref](reactivity-fundamentals.html#创建独立的响应式值作为-refs) 对象。\n\n```js\nconst count = ref(1)\nconst plusOne = computed(() => count.value + 1)\n\nconsole.log(plusOne.value) // 2\n\nplusOne.value++ // error\n```\n\n或者，它可以使用一个带有 `get` 和 `set` 函数的对象来创建一个可写的 ref 对象。\n\n```js\nconst count = ref(1)\nconst plusOne = computed({\n  get: () => count.value + 1,\n  set: val => {\n    count.value = val - 1\n  }\n})\n\nplusOne.value = 1\nconsole.log(count.value) // 0\n```\n\n### 调试 Computed <Badge text=\"3.2+\" />\n\n`computed` 可接受一个带有 `onTrack` 和 `onTrigger` 选项的对象作为第二个参数：\n\n- `onTrack` 会在某个响应式 property 或 ref 作为依赖被追踪时调用。\n- `onTrigger` 会在侦听回调被某个依赖的修改触发时调用。 \n\n所有回调都会收到一个 debugger 事件，其中包含了一些依赖相关的信息。推荐在这些回调内放置一个 `debugger` 语句以调试依赖。\n\n```js\nconst plusOne = computed(() => count.value + 1, {\n  onTrack(e) {\n    // 当 count.value 作为依赖被追踪时触发\n    debugger\n  },\n  onTrigger(e) {\n    // 当 count.value 被修改时触发\n    debugger\n  }\n})\n// 访问 plusOne，应该触发 onTrack\nconsole.log(plusOne.value)\n// 修改 count.value，应该触发 onTrigger\ncount.value++\n```\n\n`onTrack` 和 `onTrigger` 仅在开发模式下生效。\n\n## `watchEffect`\n\n为了根据响应式状态*自动应用*和*重新应用*副作用，我们可以使用 `watchEffect` 函数。它立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数。\n\n```js\nconst count = ref(0)\n\nwatchEffect(() => console.log(count.value))\n// -> logs 0\n\nsetTimeout(() => {\n  count.value++\n  // -> logs 1\n}, 100)\n```\n\n### 停止侦听\n\n当 `watchEffect` 在组件的 [setup()](composition-api-setup.html) 函数或[生命周期钩子](composition-api-lifecycle-hooks.html)被调用时，侦听器会被链接到该组件的生命周期，并在组件卸载时自动停止。\n\n在一些情况下，也可以显式调用返回值以停止侦听：\n\n```js\nconst stop = watchEffect(() => {\n  /* ... */\n})\n\n// later\nstop()\n```\n\n### 清除副作用\n\n有时副作用函数会执行一些异步的副作用，这些响应需要在其失效时清除 (即完成之前状态已改变了) 。所以侦听副作用传入的函数可以接收一个 `onInvalidate` 函数作入参，用来注册清理失效时的回调。当以下情况发生时，这个失效回调会被触发：\n\n- 副作用即将重新执行时\n- 侦听器被停止 (如果在 `setup()` 或生命周期钩子函数中使用了 `watchEffect`，则在组件卸载时)\n\n```js\nwatchEffect(onInvalidate => {\n  const token = performAsyncOperation(id.value)\n  onInvalidate(() => {\n    // id has changed or watcher is stopped.\n    // invalidate previously pending async operation\n    token.cancel()\n  })\n})\n```\n\n我们之所以是通过传入一个函数去注册失效回调，而不是从回调返回它，是因为返回值对于异步错误处理很重要。\n\n在执行数据请求时，副作用函数往往是一个异步函数：\n\n```js\nconst data = ref(null)\nwatchEffect(async onInvalidate => {\n  onInvalidate(() => {\n    /* ... */\n  }) // 我们在Promise解析之前注册清除函数\n  data.value = await fetchData(props.id)\n})\n```\n\n我们知道异步函数都会隐式地返回一个 Promise，但是清理函数必须要在 Promise 被 resolve 之前被注册。另外，Vue 依赖这个返回的 Promise 来自动处理 Promise 链上的潜在错误。\n\n### 副作用刷新时机\n\nVue 的响应性系统会缓存副作用函数，并异步地刷新它们，这样可以避免同一个“tick” 中多个状态改变导致的不必要的重复调用。在核心的具体实现中，组件的 `update` 函数也是一个被侦听的副作用。当一个用户定义的副作用函数进入队列时，默认情况下，会在所有的组件 `update` **前**执行：\n\n```vue\n<template>\n  <div>{{ count }}</div>\n</template>\n\n<script>\nexport default {\n  setup() {\n    const count = ref(0)\n\n    watchEffect(() => {\n      console.log(count.value)\n    })\n\n    return {\n      count\n    }\n  }\n}\n</script>\n```\n\n在这个例子中：\n\n- `count` 会在初始运行时同步打印出来\n- 更改 `count` 时，将在组件**更新前**执行副作用。\n\n如果需要在组件更新(例如：当与[模板引用](./composition-api-template-refs.md#侦听模板引用)一起)**后**重新运行侦听器副作用，我们可以传递带有 `flush` 选项的附加 `options` 对象 (默认为 `\'pre\'`)：\n\n```js\n\n// 在组件更新后触发，这样你就可以访问更新的 DOM。\n// 注意：这也将推迟副作用的初始运行，直到组件的首次渲染完成。\nwatchEffect(\n  () => {\n    /* ... */\n  },\n  {\n    flush: \'post\'\n  }\n)\n```\n\n`flush` 选项还接受 `sync`，这将强制效果始终同步触发。然而，这是低效的，应该很少需要。\n\n从 Vue 3.2.0 开始，`watchPostEffect` 和 `watchSyncEffect` 别名也可以用来让代码意图更加明显。\n\n### 侦听器调试\n\n`onTrack` 和 `onTrigger` 选项可用于调试侦听器的行为。\n\n- `onTrack` 将在响应式 property 或 ref 作为依赖项被追踪时被调用。\n- `onTrigger` 将在依赖项变更导致副作用被触发时被调用。\n\n这两个回调都将接收到一个包含有关所依赖项信息的调试器事件。建议在以下回调中编写 `debugger` 语句来检查依赖关系：\n\n```js\nwatchEffect(\n  () => {\n    /* 副作用 */\n  },\n  {\n    onTrigger(e) {\n      debugger\n    }\n  }\n)\n```\n\n`onTrack` 和 `onTrigger` 只能在开发模式下工作。\n\n## `watch`\n\n`watch` API 完全等同于组件[侦听器](computed.html#侦听器) property。`watch` 需要侦听特定的数据源，并在回调函数中执行副作用。默认情况下，它也是惰性的，即只有当被侦听的源发生变化时才执行回调。\n\n- 与 [watchEffect](#watcheffect) 比较，`watch` 允许我们：\n\n  - 懒执行副作用；\n  - 更具体地说明什么状态应该触发侦听器重新运行；\n  - 访问侦听状态变化前后的值。\n\n### 侦听单个数据源\n\n侦听器数据源可以是返回值的 getter 函数，也可以直接是 `ref`：\n\n```js\n// 侦听一个 getter\nconst state = reactive({ count: 0 })\nwatch(\n  () => state.count,\n  (count, prevCount) => {\n    /* ... */\n  }\n)\n\n// 直接侦听ref\nconst count = ref(0)\nwatch(count, (count, prevCount) => {\n  /* ... */\n})\n```\n\n### 侦听多个数据源\n\n侦听器还可以使用数组同时侦听多个源：\n\n```js\nconst firstName = ref(\'\')\nconst lastName = ref(\'\')\n\nwatch([firstName, lastName], (newValues, prevValues) => {\n  console.log(newValues, prevValues)\n})\n\nfirstName.value = \'John\' // logs: [\"John\", \"\"] [\"\", \"\"]\nlastName.value = \'Smith\' // logs: [\"John\", \"Smith\"] [\"John\", \"\"]\n```\n\n尽管如此，如果你在同一个函数里同时改变这些被侦听的来源，侦听器仍只会执行一次：\n\n```js{9-13}\nsetup() {\n  const firstName = ref(\'\')\n  const lastName = ref(\'\')\n\n  watch([firstName, lastName], (newValues, prevValues) => {\n    console.log(newValues, prevValues)\n  })\n\n  const changeValues = () => {\n    firstName.value = \'John\'\n    lastName.value = \'Smith\'\n    // 打印 [\"John\", \"Smith\"] [\"\", \"\"]\n  }\n\n  return { changeValues }\n}\n```\n\n注意多个同步更改只会触发一次侦听器。\n\n通过更改设置 `flush: \'sync\'`，我们可以为每个更改都强制触发侦听器，尽管这通常是不推荐的。或者，可以用 [nextTick](/api/global-api.html#nexttick) 等待侦听器在下一步改变之前运行。例如：\n\n```js\nconst changeValues = async () => {\n  firstName.value = \'John\' // 打印 [\"John\", \"\"] [\"\", \"\"]\n  await nextTick()\n  lastName.value = \'Smith\' // 打印 [\"John\", \"Smith\"] [\"John\", \"\"]\n}\n```\n\n### 侦听响应式对象\n\n使用侦听器来比较一个数组或对象的值，这些值是响应式的，要求它有一个由值构成的副本。\n\n```js\nconst numbers = reactive([1, 2, 3, 4])\n\nwatch(\n  () => [...numbers],\n  (numbers, prevNumbers) => {\n    console.log(numbers, prevNumbers)\n  }\n)\n\nnumbers.push(5) // logs: [1,2,3,4,5] [1,2,3,4]\n```\n\n尝试检查深度嵌套对象或数组中的 property 变化时，仍然需要 `deep` 选项设置为 true。\n\n```js\nconst state = reactive({ \n  id: 1,\n  attributes: { \n    name: \'\',\n  }\n})\n\nwatch(\n  () => state,\n  (state, prevState) => {\n    console.log(\'not deep\', state.attributes.name, prevState.attributes.name)\n  }\n)\n\nwatch(\n  () => state,\n  (state, prevState) => {\n    console.log(\'deep\', state.attributes.name, prevState.attributes.name)\n  },\n  { deep: true }\n)\n\nstate.attributes.name = \'Alex\' // 日志: \"deep\" \"Alex\" \"Alex\"\n```\n\n然而，侦听一个响应式对象或数组将始终返回该对象的当前值和上一个状态值的引用。为了完全侦听深度嵌套的对象和数组，可能需要对值进行深拷贝。这可以通过诸如 [lodash.cloneDeep](https://lodash.com/docs/4.17.15#cloneDeep) 这样的实用工具来实现。\n\n```js\nimport _ from \'lodash\'\n\nconst state = reactive({\n  id: 1,\n  attributes: {\n    name: \'\',\n  }\n})\n\nwatch(\n  () => _.cloneDeep(state),\n  (state, prevState) => {\n    console.log(state.attributes.name, prevState.attributes.name)\n  }\n)\n\nstate.attributes.name = \'Alex\' // 日志: \"Alex\" \"\"\n```\n\n### 与 `watchEffect` 共享的行为\n\n`watch` 与 [`watchEffect`](#watcheffect)共享[停止侦听](#停止侦听)，[清除副作用](#清除副作用) (相应地 `onInvalidate` 会作为回调的第三个参数传入)、[副作用刷新时机](#副作用刷新时机)和[侦听器调试](#侦听器调试)行为。\n', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 10, 1, '2022-3-29 15:05:20', '2022-3-29 15:05:20', '', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (249, 10000, '了解HTML5中的MutationObserver', 'MutationObserver翻译过来就是变动观察器，字面上就可以理解这是用来观察Node（节点）变化的。MutationObserver是在DOM4规范中定义的，它的前身是MutationEvent事件，该事件最初在DOM2事件规范中介绍，到来了DOM3事件规范中正式定义，但是由于该事件存在兼容性以及性能上的问题被弃用。', 'MutationObserver翻译过来就是变动观察器，字面上就可以理解这是用来观察Node（节点）变化的。MutationObserver是在DOM4规范中定义的，它的前身是MutationEvent事件，该事件最初在DOM2事件规范中介绍，到来了DOM3事件规范中正式定义，但是由于该事件存在兼容性以及性能上的问题被弃用。\n\n### MutationEvent\n虽然MutationEvent已经被弃用，但是我们还是需要了解它，可能你会为了浏览器兼容性的问题而遇到它（万恶的浏览器兼容性）。\n\nMutationEvent总共有7种事件：**DOMNodeInserted**、**DOMNodeRemoved**、**DOMSubtreeModified**、**DOMAttrModified**、\n**DOMCharacterDataModified**、**DOMNodeInsertedIntoDocument**和**DOMNodeRemovedFromDocument**。\n\nMutationEvent的兼容性：\n\nMutationEvent在IE浏览器中最低支持到IE9\n在webkit内核的浏览器中，不支持**DOMAttrModified**事件\nIE，Edge以及Firefox浏览器下不支持**DOMNodeInsertedIntoDocument**和**DOMNodeRemovedFromDocument**事件\n\nMutationEvent中的所有事件都被设计成无法取消，如果可以取消MutationEvent事件则会导致现有的DOM接口无法对文档进行改变，比如appendChild，remove等添加和删除节点的DOM操作。\nMutationEvent中最令人诟病的就是性能以及安全性的问题，比如下面这个例子：\n```js\ndocument.addEventListener(\'DOMNodeInserted\', function() {\n    var newEl = document.createElement(\'div\');\n    document.body.appendChild(newEl);\n});\n```\ndocument下的所有DOM添加操作都会触发DOMNodeInserted方法，这时就会出现循环调用DOMNodeInserted方法，导致浏览器崩溃。还有就是MutationEvent是事件机制，因此会有一般事件都存在的捕获和冒泡阶段，此时如果在捕获和冒泡阶段又对DOM进行了操作会拖慢浏览器的运行。\n\n另一点就是MutationEvent事件机制是同步的，也就是说每次DOM修改就会触发，修改几次就触发几次,严重降低浏览器的运行，严重时甚至导致线程崩溃\n```js\n<div id=\'block\'></div>\n```\n```js\nvar i=0;\nblock.addEventListener(\'DOMNodeInserted\', function(e) {\n     i++                                  \n});\nblock.appendChild(docuemnt.createTextNode(\'1\'));\nconsole.log(i)                  //1\nblock.appendChild(docuemnt.createTextNode(\'2\'));\nconsole.log(i)                  //2\nblock.appendChild(docuemnt.createTextNode(\'3\'));\nconsole.log(i)                  //3\n```\n再看个例子：\n```js\n<div id=\'block\'>\n  <span id=\'span\'>Text</span>\n</div>\n```\n```js\nblock.addEventListener(\'DOMNodeInserted\', function(e) {\n     console.log(\'1\');                                  //1\n});\nspan.appendChild(docuemnt.createTextNode(\'other Text\'));\n```\n\nspan元素中添加节点会触发block中的DOMNodeInserted事件，可是你只想观察block的变化，不想观察block中子节点的变化，这时你不得不在DOMNodeInserted事件中进行过滤，把对span的操作忽略掉，这无疑增加了操作的复杂性。\n\n### MutationObserver\nMutationObserver的出现就是为了解决MutationEvent带来的问题。\n先看一下MutationObserver的浏览器兼容性：\n\n![MutationObserver浏览器兼容性](https://image-static.segmentfault.com/311/678/3116780507-5a55bdcc5bd1c_fix732)\n\n我们可以看到MutationObserver在IE中最低要就是IE11，如果你的网站不需要支持IE或者只支持到IE11，那么你可以放心的使用MutationObserver，否则你可能需要用到上面提到的MutationEvent事件，当然如果你的网站还要支持IE8及以下版本，那么你只能和Mutation说拜拜了。\n\nMutationObserver是一个构造器，接受一个callback参数，用来处理节点变化的回调函数，返回两个参数，mutations：节点变化记录列表（sequence<MutationRecord>），observer：构造MutationObserver对象。\n```js\nvar observe = new MutationObserver(function(mutations,observer){\n})\n```\nMutationObserver对象有三个方法，分别如下：\n\n1. **observe**：设置观察目标，接受两个参数，target：观察目标，options：通过对象成员来设置观察选项\n2. **disconnect**：阻止观察者观察任何改变\n3. **takeRecords**：清空记录队列并返回里面的内容\n\n关于observe方法中options参数有已下几个选项：\n\n1. **childList**：设置true，表示观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化\n2. **attributes**：设置true，表示观察目标属性的改变\n3. **characterData**：设置true，表示观察目标数据的改变\n4. **subtree**：设置为true，目标以及目标的后代改变都会观察\n5. **attributeOldValue**：如果属性为true或者省略，则相当于设置为true，表示需要记录改变前的目标属性值，设置了attributeOldValue可以省略attributes设置\n6. **characterDataOldValue**：如果characterData为true或省略，则相当于设置为true,表示需要记录改变之前的目标数据，设置了characterDataOldValue可以省略characterData设置\n7. **attributeFilter**：如果不是所有的属性改变都需要被观察，并且attributes设置为true或者被忽略，那么设置一个需要观察的属性本地名称（不需要命名空间）的列表\n下表描述了MutationObserver选项与MutationEvent名称之间的对应关系：\n\n| MutationEvent	|MutationObserver options|\n|-|-|\n| DOMNodeInserted | { childList: true, subtree: true } |\n| DOMNodeRemoved | { childList: true, subtree: true } |\n| DOMSubtreeModified | { childList: true, subtree: true } |\n| DOMAttrModified | { attributes: true, subtree: true } |\n| DOMCharacterDataModified | { characterData: true, subtree: true } |\n\n从上表我们也可以看出相比与MutationEvent而言MutationObserver极大地增加了灵活性，可以设置各种各样的选项来满足程序员对目标的观察。\n\n我们简单看几个例子：\n```html\n<div id=\'target\' class=\'block\' name=\'target\'>\n    target的第一个子节点\n    <p>\n       <span>target的后代</span>\n    </p>\n</div>\n```\n1.callback的回调次数\n```js\nvar target=document.getElementById(\'target\');\nvar i=0\nvar observe=new MutationObserver(function (mutations,observe) {\n    i++   \n});\nobserve.observe(target,{ childList: true});\ntarget.appendChild(docuemnt.createTextNode(\'1\'));\ntarget.appendChild(docuemnt.createTextNode(\'2\'));\ntarget.appendChild(docuemnt.createTextNode(\'3\'));\nconsole.log(i)                //1\n```\n\nMutationObserver的callback回调函数是异步的，只有在全部DOM操作完成之后才会调用callback。\n\n2.当只设置{ childList: true}时,表示观察目标子节点的变化\n```js\nvar observe=new MutationObserver(function (mutations,observe) {\n    debugger;\n    console.log(mutations);\n    //observe.discount();     \n});\n\nobserve.observe(target,{ childList: true});\ntarget.appendChild(document.createTextNode(\'新增Text节点\'));   //增加节点，观察到变化\ntarget.childNodes[0].remove();                                //删除节点，可以观察到\ntarget.childNodes[0].textContent=\'改变子节点的后代\';             //不会观察到\n```\n如果想要观察到子节点以及后代的变化需设置{childList: true, subtree: true}\n\nattributes选项用来观察目标属性的变化，用法类似与childList,目标属性的删除添加以及修改都会被观察到。\n\n3.我们需要注意的是characterData这个选项，它是用来观察CharacterData类型的节点的，只有在改变节点数据时才会观察到，如果你删除或者增加节点都不会进行观察，还有如果对不是CharacterData类型的节点的改变不会观察到，比如：\n```js\nobserve.observe(target,{ characterData: true, subtree: true});\ntarget.childNodes[0].textContent=\'改变Text节点\';              //观察到\ntarget.childNodes[1].textContent=\'改变p元素内容\';              //不会观察到\ntarget.appendChild(document.createTextNode(\'新增Text节点\'));  //不会观察到\ntarget.childNodes[0].remove();                               //删除TEXT节点也不会观察到\n```\n我们只需要记住只有对CharacterData类型的节点的数据改变才会被characterData为true的选项所观察到。\n\n4.最后关注一个特别有用的选项attributeFilter，这个选项主要是用来筛选要观察的属性，比如你只想观察目标style属性的变化，这时可以如下设置：\n```js\nobserve.observe(target,{ attributeFilter: [\'style\'], subtree: true});\ntarget.style=\'color:red\';                      //可以观察到\ntarget.removeAttribute(\'name\');                //删除name属性，无法观察到 \n```\ndisconnect方法是用来阻止观察的，当你不再想观察目标节点的变化时可以调用observe.disconnect()方法来取消观察。\n\ntakeRecords方法是用来取出记录队列中的记录。它的一个作用是，比如你对一个节点的操作你不想马上就做出反应，过段时间在显示改变了节点的内容。\n```js\nvar observe=new MutationObserver(function(){});\nobserve.observe(target,{ childList: true});\ntarget.appendChild(document.createTextNode(\'新增Text节点\'));\nvar record = observe.takeRecords();              //此时record保存了改变记录列表  \n//当调用takeRecords方法时，记录队列被清空因此不会触发MutationObserver中的callback回调方法。\ntarget.appendChild(document.createElement(\'span\'));\nobserve.disconnect();                            //停止对target的观察。\n//MutationObserver中的回调函数只有一个记录，只记录了新增span元素\n\n//之后可以对record进行操作\n//...\n```\n**MutationRecord**\n变动记录中的属性如下：\n\n1. **type**：如果是属性变化，返回\"attributes\"，如果是一个CharacterData节点（Text节点、Comment节点）变化，返回\"characterData\"，节点树变化返回\"childList\"\n2. **target**：返回影响改变的节点\n3. **addedNodes**：返回添加的节点列表\n4. **removedNodes**：返回删除的节点列表\n5. **previousSibling**：返回分别添加或删除的节点的上一个兄弟节点，否则返回null\n6. **nextSibling**：返回分别添加或删除的节点的下一个兄弟节点，否则返回null\n7. **attributeName**：返回已更改属性的本地名称，否则返回null\n8. **attributeNamespace**：返回已更改属性的名称空间，否则返回null\n9. **oldValue**：返回值取决于type。对于\"attributes\"，它是更改之前的属性的值。对于\"characterData\"，它是改变之前节点的数据。对于\"childList\"，它是null\n\n其中 **type**、**target**这两个属性不管是哪种观察方式都会有返回值，其他属性返回值与观察方式有关，比如只有当attributeOldValue或者characterDataOldValue为true时oldValue才有返回值，只有改变属性时，attributeName才有返回值等。', 1, 0, 1, '', '\r\nhttps://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/Study.png', 0, 0, 39, 1, '2022-4-7 10:54:38', '2022-4-7 10:58:40', 'https://segmentfault.com/a/1190000012787829', 0);
INSERT INTO `bs_post` (`id`, `user_id`, `title`, `summary`, `content`, `type`, `create_type`, `category_id`, `tags`, `thumbnail`, `is_top`, `status`, `view_count`, `is_comment`, `create_time`, `update_time`, `original_link`, `deleted`) VALUES (250, 10000, '12312312', '3123123123', '312312312312', 1, 0, 1, '', 'https://youyu-source.oss-cn-beijing.aliyuncs.com/firstImages/default/defaultFirstPic.png', 0, 0, 0, 1, '2023-3-5 12:52:49', '2023-3-5 12:52:49', '', 0);
